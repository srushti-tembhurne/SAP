package ariba::Ops::Startup::Monitoring;

# $Id: //ariba/services/tools/lib/perl/ariba/Ops/Startup/Monitoring.pm#92 $

use strict;

use File::Basename;
use File::Path;
use ariba::Ops::DBConnection;
use ariba::Ops::NetworkUtils;
use ariba::Ops::Startup::Common;
use ariba::rc::InstalledProduct;
use ariba::rc::Utils;
use ariba::Ops::PageFilter;
use ariba::Ops::DatacenterController;
use ariba::Ops::ServiceController;
use ariba::rc::Passwords;
use ariba::Ops::ProductAPIExtensions;

my $SUDO = ariba::rc::Utils::sudoCmd();

sub createDotForwardForAckparser
{
    my $forward = "$ENV{HOME}/.forward";

    print "Creating file $forward\n";
    open(FW, "> $forward") || die "Error: Could not create file $forward, $!\n";
    print FW "\"| $ENV{HOME}/bin/page/parse-ack-email\"\n";
    close(FW);
}

# http-watcher, etc have been migrated to using Query's exclusively.
sub removeWatcherDir {

    require ariba::monitor::misc;

    my $watcherDir = sprintf('%s/watcher', ariba::monitor::misc::monitorDir());

    if (-d $watcherDir) {
        rmtree($watcherDir);
    }
}

sub createObjectDirectories {
    my $role = shift;

    my $dir = ariba::Ops::PageFilter->dir();

    # create only if needed.
    unless (-d $dir) {
        r(mkdirCmd() . " -p $dir");
    }
    r("/bin/chmod -R 777 $dir");
}

sub createSymLinks
{
    my $buildname = shift;
    my $prodRoot  = dirname($main::INSTALLDIR);

    my $me = ariba::rc::InstalledProduct->new();
    my $logReportDir = $me->default('LogReportDir');

    require ariba::monitor::misc;

    unlink("$prodRoot/sql");
    symlink("$main::INSTALLDIR/sql", "$prodRoot/sql");

    unlink("$prodRoot/etc");
    symlink("$main::INSTALLDIR/etc", "$prodRoot/etc");

    my $autoDocroot = ariba::monitor::misc::autoGeneratedDocsDir();
    mkpath("$autoDocroot/metrics");

    if( $logReportDir ) {
        unlink("$main::INSTALLDIR/docroot/logreports");
        symlink($logReportDir, "$main::INSTALLDIR/docroot/logreports");
    }

    unlink("$main::INSTALLDIR/docroot/dynamic");
    symlink($autoDocroot, "$main::INSTALLDIR/docroot/dynamic");

    symlink("$main::INSTALLDIR/bin/recent-outages", "$main::INSTALLDIR/docroot/cgi-bin/recent-outages");
    symlink("$main::INSTALLDIR/bin/on-call/list-contacts", "$main::INSTALLDIR/docroot/cgi-bin/list-contacts");
    symlink("$main::INSTALLDIR/bin/on-call/show-schedule", "$main::INSTALLDIR/docroot/cgi-bin/show-schedule");
    symlink("$main::INSTALLDIR/bin/on-call/show-schedule-v2", "$main::INSTALLDIR/docroot/cgi-bin/show-schedule-v2");
    symlink("$main::INSTALLDIR/bin/on-call/show-fmkt-app-ownership", "$main::INSTALLDIR/docroot/cgi-bin/show-fmkt-app-ownership");
    symlink("$main::INSTALLDIR/bin/page/pagestatus", "$main::INSTALLDIR/docroot/cgi-bin/pagestatus");
    symlink("$main::INSTALLDIR/bin/rmanbackup-status", "$main::INSTALLDIR/docroot/cgi-bin/rmanbackup-status");
    symlink("$main::INSTALLDIR/docroot/cgi-bin/rmanbackup-status", "$main::INSTALLDIR/docroot/cgi-bin/rmanbackup-status-arch"); 

    unlink("$main::INSTALLDIR/bin/outofservice");
    symlink("$main::INSTALLDIR/bin/inservice", "$main::INSTALLDIR/bin/outofservice");

    my $queryDirSymlink = ariba::monitor::misc->queryStorageDirSymlink();
    unless (-l $queryDirSymlink) {
        ariba::rc::Utils::rmdirRecursively($queryDirSymlink);
        symlink(ariba::monitor::misc->queryStorageDir(), $queryDirSymlink);
    }
}

# create symlinks that should be on monserver only
sub createMonserverSymLinks
{
    require ariba::monitor::misc;

    my $outageDirSymlink = ariba::monitor::misc->outageStorageDirSymlink();
    unless (-l $outageDirSymlink) {
        ariba::rc::Utils::rmdirRecursively($outageDirSymlink);
        symlink(ariba::monitor::misc->outageStorageDir(), $outageDirSymlink);
    }
}

sub cleanSharedMemory {
    open(F,"/usr/bin/ipcs -m |");
    while(my $line = <F>) {
        chomp($line);
        next unless($line =~ /^0x/);
        my ($memid,$owner) = (split(/\s+/,$line))[1,2];
        next unless($owner eq (getpwuid($<))[0]);
        system("/usr/bin/ipcrm -m $memid");
    }
    close(F);
}

sub initializeCipherStore {
    my $me = shift;

    my $conditionalHashRef = {
        'user' => 1,

    };
    return initializeCipherStoreWithConditions($me, $conditionalHashRef, @_);
}

# store some values into shared memory that might be needed by some
# monitoring cronjobs these values are usually encrypted and since the
# cronjobs do not get master password, we need to tuck these away in
# advance.
sub initializeCipherStoreWithConditions {
    my ($me, $conditionHashRef, @products) = @_;
    my %cipherStore = ();

    #
    # save master password to clean up when done since this blows the
    # blowfish layer... ugg
    #
    my $master = ariba::rc::Passwords::lookup('master');

    my $service = $me->service();

    if ($conditionHashRef && $conditionHashRef->{'user'}) {
        my @users = (ariba::rc::Globals::allUsers($service), "oracle", "netapp", "networkAccess", "networkEnable", "cdotPassword");

        for my $user (@users) {
            my $password = ariba::rc::Passwords::lookup($user);
            $cipherStore{$user} = $password;
        }
    }

    for my $product (@products) {
        my $name = $product->name();
        my $storeNamePrefix;

        if ( $product->customer() ) {
            $storeNamePrefix = "$name/$service/" . $product->customer() . ":";
        } else {
            $storeNamePrefix = "$name/$service:";
        }

        my @connectionKeypaths = ariba::Ops::ProductAPIExtensions::connectionKeypathsForProduct($product);

        my @repConnectionKeypaths = ariba::Ops::ProductAPIExtensions::reportingConnectionKeypaths($product);
        push(@connectionKeypaths, @repConnectionKeypaths) if (@repConnectionKeypaths);

        my @storeKeys = (
            "cert.clientcert.password",
            "outboundhttps.identitykeystore.password",
            "outboundhttps.ediidentitykeystore.password",
            "payment.gevpayment.identitykeystore.password",
            "payment.amextpp.identitykeystore.password",
            "esigclient.identitykeystore.password",
            "fax.xpedite.xpeditepassword",
            "fax.xpedite.httpspost.password",
            "mccredentials.account1.password",
            "mccredentials.account2.password",
            "dbainfo.sys.password",
            "dbainfo.system.password",
            "dbainfo.ase.password",
            "dbainfo.hana.system.password",
            "dbainfo.hana.admin.password",
            "dbainfo.hana.backup.password",
            "dbainfo.redis.rlec.password",
            "dbainfo.redis.admin.password",
            "dbainfo.mysqlsystem.password",
            "dbainfo.sys.password",
            "dbainfo.perfstat.password",
            "dbainfo.backup.password",
            "dbainfo.rman.password",
            "dbainfo.bpm.influx.password",
            "ops.alertsite.password",
            "ops.gomez.password",
            "ops.netapp.password",
            "boomi.password",
            "System.Inspector.ReadOnlyPassword",
            "System.Inspector.AdminPassword",
            "System.Inspector.DebugPassword",
            "Safeword.database.password",
            "Cybersource.userlist.password",
            "Procuri.TotalSource.password",
            "Procuri.TotalContract.password",
            "Ops.AppInfo.ASMSharedSecret",
            "superuser.piwik.password",
            "Migration.password",
            "HANADBs.DBDirectory.password",
            "HANADBs.DBSupplier.password",
            "SSLCertificate.password",
            "System.Authentication.Keystores.AribaPrivateKeystore.StorePassword",
            "System.Authentication.Keystores.AppleProductionKeystore.StorePassword",
            "Logi.BusinessObject.password",
            "AUC.DB.Password",
            "AUC.BusinessObjectsUpload.User",
            "AUC.BusinessObjectsUpload.Password",
            "AUC.BusinessObjectsUpload.Url",
            "AUC.Support.Password",
            "AUC.MobileAPI.Password",
            "AUC.SubscriptionNode.Version001.Password",
            "AUC.AribaONDEncryption.AOD.Key",
            "AUC.SSO_FROM.AN.Key1",
            "AUC.SSO_FROM.AN.Key2",
            "AUC.SSO_FROM.S4.Key1",
            "AUC.SSO_FROM.S4.Key2",
            "AUC.SSO_FROM.P2P.Key1",
            "AUC.SSO_FROM.P2P.Key2",
            "AUC.SAPLDAP.Password",
            "AUC.GDPR_INTERNAL_APP.KEY.V1",
            "AUC.GDPR_INTERNAL_APP.KEY.V2",
            "AUC.Lithium.SSO.Key",
            "lumira.monitoring.subscriptions.password",
            "lumira.monitoring.srsservers.SRSServer-Dir.password",
            "lumira.monitoring.srsservers.SRSServer-Sup1.password",
            "lumira.monitoring.srsservers.SRSServer-Buy1.password",
            "lumira.monitoring.dsiconnections.SRSServer-Dir.password",
            "lumira.monitoring.dsiconnections.SRSServer-Sup1.password",
            "lumira.monitoring.dsiconnections.SRSServer-Buy1.password",
            "lumira.monitoring.srsagents.SRSAgent-Dir.password",
            "lumira.monitoring.srsagents.SRSAgent-Sup1.password",
            "lumira.monitoring.srsagents.SRSAgent-Buy1.password",
            "monitoring.srsservers.SRSServer-SSS5.password",
            "monitoring.srsagents.SRSAgent-SSS5.password",
            "monitoring.dsiconnections.SRSServer-SSS5.password",
            "SRSReplication.SRSRepserverInfo.password",
            "SRSReplication.SRSRepagentInfo.password",
            "SRSReplication.SRSDSIInfo.password",
            "SRSReplication.SRSAgentTargetHana.password",
            "AIGPortal.password",
            "BO.ftptransfer.Password",
        );

        for my $keyPath (@connectionKeypaths) {
            my $key;
            my $value;

            $key = "$keyPath.AribaDBPassword";
            $value = $product->default($key);

            unless ($value) {
                $key = "$keyPath.password";
                $value = $product->default($key);
            }

            $cipherStore{"$storeNamePrefix$key"} = $value if $value;
        }

        for my $key (@storeKeys) {
            my $value = $product->default($key);
            $cipherStore{"$storeNamePrefix$key"} = $value if $value;
        }
    }

    return unless(scalar(keys(%cipherStore)));

    eval "use ariba::rc::CipherStore"; die "Eval Error: $@\n" if ($@);

    # TODO:
    # do not make this call before any ariba::rc::Passwords. This
    # will reprime blowfish with a different key!
    my $cipherStore = ariba::rc::CipherStore->new($service);


    unless($cipherStore->storeHash(\%cipherStore)) {
        #
        # clean out any old, possibly bogus shm
        #
        cleanSharedMemory();
        unless($cipherStore->storeHash(\%cipherStore)) {
            die "ERROR: Failed to store contents in CipherStore: $!\n";
        }
    }

    if (scalar($cipherStore->keysNotStored())) {
        print "Error: the following keys failed saving to cipherstore (probably due to badly encrypted values):\n",
              "Error: ", join (",", $cipherStore->keysNotStored()), "\n",
              "Error: This is not a fatal error, but some parts of monitoring may not work because of this.\n";
    }

    #
    # now what we're done, replace the Password layer that we just hosed
    # (note, we have to tell it to re-init in this case, hence the reset call)
    #
    ariba::rc::Passwords::reset();
    ariba::rc::Passwords::initialize($service, $master);

    return 1;
}

sub buildEMCConfig {
    my $me   = shift;

    my $file = '/usr/emc/ECC/data/config';

    my $cluster   = $me->currentCluster();
    my $monserver = ariba::Ops::NetworkUtils::hostToAddr(
        ($me->hostsForRoleInCluster('monserver', $cluster))[0]
    );

    my %config = (
        'system_name'               => ariba::Ops::NetworkUtils::hostname(),
        'system_contact'            => $me->default('notify.email'),
        'system_location'           => 'Ariba',
        'udp_port_number'           => 30727,
        'xdr_port_number'           => 16024,
        'default_read_community'        => 'public',
        'default_write_community'       => 'public',
        'default_trap_community'        => 'SNMP_trap',
        'trap_client_registration(ip-port)' => "$monserver,162,10,ACTIVE",
        'default_symapisrv_port'        => 2707,
        'maximum_events'            => 200,
        'data_expiration(seconds)'      => 60,
        'discovery_frequency(seconds)'      => 86400,
        'partial_discovery_frequency(seconds)'  => 3600,
        'config_change_test_frequency(seconds)' => 60,
        'status_change_test_frequency(seconds)' => 60,
        'wla_retention_policy(days)'        => 7,
        'wla_maximum_file_xfr_size(bytes)'  => 7500000,
        'NT_EventLog_Key'           => 'none',
        'error_retention_period(seconds)'   => 180,
        'max_log_file_size(bytes)'      => 1000000,
        'wlaagent_auto_midnight_discovery'  => 1,
    );

    open(CONF, ">$file") || die "Can't open $file: $!";
    while (my ($key,$value) = each %config) {
        print CONF "$key: $value\n";
    }
    close(CONF);
}

sub restartECCAgent {
    my $me   = shift;

    my $script = '/usr/emc/ECC/data/eccagents -ecc';

    print "Stopping ECCAgent..\n";
    r("$SUDO $script stop");

    print "Starting ECCAgent..\n";
    r("$SUDO $script start");
}

sub buildSNMPTrapdConfig {
    my $me   = shift;   

    my $conf = $me->configDir() . "/snmptrapd.conf";
    my $prog = "$main::INSTALLDIR/bin/common/handle-snmptrap -e";

    if (-f $conf) {
        unlink $conf or die "Can't remove old config file [$conf]: $!";
    }

    open (CONF, ">$conf") || die "Can't write config file [$conf]: $!";

    print CONF "# automatically generated by startup. do not change.\n";

    for my $trap (qw(emcDeviceStatusTrap emcSymmetrixStatusTrap emcRatiosOutofRangeTrap 
             discoveryTableChange emcSymmetrixEventTrap)) {
    
        print CONF "traphandle EMC-MIB::$trap $prog\n";
    }

    close(CONF);
}

sub launchSNMPTrapd {
    my $me = shift; 

    my $envName = sharedLibEnvName();

    $ENV{$envName} = "/usr/local/lib:$ENV{$envName}";
    $ENV{'MIBDIRS'} = "+$ENV{'HOME'}/lib/mibs";
    $ENV{'MIBS'} = "+HP-UNIX:EMC-MIB:NETWORK-APPLIANCE-MIB";

    my $conf     = $me->configDir() . "/snmptrapd.conf";
    my $pidFile  = "/var/tmp/snmptrapd.pid";
    my $prog     = "/usr/local/sbin/snmptrapd -m all -OS -c $conf -u $pidFile";

    if (-f $pidFile) {
        chomp(my $pid = do { open PID, $pidFile and <PID> });
        r("$SUDO kill $pid");
    }

    r("$SUDO $prog");
}

#
# helper function to put this decision in one place
#
sub shouldRunNetworkSNMPForServiceAndDatacenter {
    my $service = shift;
    my $dc = shift;

    # always rebuild when not in devlab dc; in devlab, only do
    # certain services
    if ( !(ariba::Ops::DatacenterController::isDevlabDatacenters($dc)) || 
        ariba::Ops::ServiceController::isLoadServiceOnly($service)) {
        return 1;
    } 

    # don't rebuild otherwise
    return;
}
1;

__END__
