
filename:./bin/an/datalink-status
23,25c23,24
< sub usage
< {
<     my $error = shift;
---
> sub usage {
> 	my $error = shift; 
27c26
<     print <<USAGE;
---
> 	print <<USAGE;
30,33c29,32
<     -e    Enables sending of email for monitor query.
<     -p    Enables sending of pages for monitor query.
<     -d    Turns on debug mode. 
<     -h    Shows this help.
---
> 	-e    Enables sending of email for monitor query.
> 	-p    Enables sending of pages for monitor query.
> 	-d    Turns on debug mode. 
> 	-h    Shows this help.
37c36
<     print "(error) $error\n" if ($error);
---
> 	print "(error) $error\n" if ($error);
39c38
<     exit ();
---
> 	exit();
42,52c41,49
< sub main
< {
<     my $sendEmail = 0;
<     my $sendPage  = 0;
< 
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p$/o) {$sendPage  = 1; next;}
---
> sub main {
> 	my $sendEmail = 0;
> 	my $sendPage  = 0;
> 
> 	while (my $arg = shift) {
> 		if ($arg =~ /^-h$/o) { usage();			next; }
> 		if ($arg =~ /^-d$/o) { $debug++; 		next; }
> 		if ($arg =~ /^-e$/o) { $sendEmail = 1; 	next; }
> 		if ($arg =~ /^-p$/o) { $sendPage = 1; 	next; }
54,55c51,52
<         usage("Invalid argument: $arg");
<     }
---
> 		usage("Invalid argument: $arg");
> 	}
57c54
<     my $me      = ariba::rc::InstalledProduct->new();
---
> 	my $me = ariba::rc::InstalledProduct->new();
59,60c56,57
<     my $an      = ariba::rc::InstalledProduct->new('an', $service);
< 
---
>     my $an = ariba::rc::InstalledProduct->new('an', $service);
> 	
64,68c61,65
<     $queries{'Datalink Queue Length'} = {
<         crit             => 'answer > 500',
<         recordMaxResults => 35040,
<         sql              => q`
<             select /*+ INDEX(data_link_queue IND_EB809A47_20EB57A7) */ count(id) as queue_length_cnt
---
> 	$queries{'Datalink Queue Length'} = {
> 		crit	                        => 'answer > 500',
>         recordMaxResults                => 35040,
>         sql                             => q`
>             select /*+ INDEX(data_link_queue IND_EB809A47_20EB57A7) */ count(id)
73,77c70,73
<         correctiveActions => [
<                               Ops => "Escalate to AN development based on CIRS criteria",
<                              ],
<         inf_default => 0,
<                                         };
---
>         correctiveActions => [ 
>             Ops     => "Escalate to AN development based on CIRS criteria",
>         ],
> 	};
80,82c76,78
<     $queries{'Datalink Queue Items Stuck More Than 2 Hours'} = {
<         crit => 'numrows > 200',
<         sql  => q`
---
> 	$queries{'Datalink Queue Items Stuck More Than 2 Hours'} = {
> 		crit	                        => 'numrows > 200',
>         sql                             => q`
84c80
<                 id as id,ROOT_ID as root_id ,status as status,(sysdate-CREATED)*24 as stuck_time 
---
>                 id,ROOT_ID,status,(sysdate-CREATED)*24 stuck_time
91,92c87,88
<                               Ops => "Escalate to AN development based on CIRS criteria",
<                              ],
---
>             Ops     => "Escalate to AN development based on CIRS criteria",
>         ],
96,139c92,96
<     $queries{'Change Log Stuck'} = {
<         warn             => 'answer > 5000',
<         recordMaxResults => 35040,
<         sql              => q`
<             select count(*) as change_log_stuck_cnt from change_log
<         `,
<         description =>
< "Change Log stuck: The count of change_log is equivalent to the queue length. If it keeps growing, that means we are not processing it. This query warns when the count is greater than 5000 and turns critical if it stays that way for an hour.  This delay is to avoid alerting for a valid (temporary) spike in data processing.",
<         correctiveActions => [
<                               Ops => "Escalate to AN development based on CIRS criteria",
<                              ],
<         inf_default => 0,
<                                    };
< 
<     $queries{'DataSync GetChangeList failures'} = {
<         warn                         => 'answer > 3',
<         ticketOnWarnOpenAfterMinutes => 30,
<         recordMaxResults             => 8640,
<         description                  => "Number of DataSync GetChangeList failures in the past hour",
<         sql                          => q`SELECT
<             count(*) as datasync_getcl_failures
<         FROM
<             event_log
<         WHERE
<             event_name = 'EventDSGetChangeList'
<             AND status = -1
<             AND (sysdate - start_time < 60/1440);
<         `,
<         correctiveActions => [
<                               Ops => "Escalate to AN Engineering",
<                              ],
<         inf_default => 0,
<                                                   };
< 
<     $queries{'S4 Migration failures'} = {
<         description => "List of S4 Migration failures in the past day",
<         sql         => q`SELECT
<             user_id as user_id, info as info
<         FROM
<             event_log
<         WHERE
<             status = -1
<             AND event_name='EventS4Migration'
<             AND start_time > SYSDATE - 1
---
> 	$queries{'Change Log Stuck'} = {
>         warn                            => 'answer > 5000',
>         recordMaxResults                => 35040,
>         sql                             => q`
>             select count(*) from change_log
140a98,99
>         processAnswer                   => sub{  _processSQLReply() },
>         description       => "Change Log stuck: The count of change_log is equivalent to the queue length. If it keeps growing, that means we are not processing it. This query warns when the count is greater than 5000 and turns critical if it stays that way for an hour.  This delay is to avoid alerting for a valid (temporary) spike in data processing.",
142,145c101,139
<                               Ops => "See note",
<                              ],
<         note => "<html>See <a href=\"$s4MigrationDoc\">$s4MigrationDoc</a></html>",
<                                         };
---
>             Ops     => "Escalate to AN development based on CIRS criteria",
>         ],
>     };
> 
> 	$queries{'DataSync GetChangeList failures'} = {
> 		warn => 'answer > 3',
> 		ticketOnWarnOpenAfterMinutes => 30,
> 		recordMaxResults => 8640,
> 		description => "Number of DataSync GetChangeList failures in the past hour",
> 		sql => q`SELECT
> 			count(*)
> 		FROM
> 			event_log
> 		WHERE
> 			event_name = 'EventDSGetChangeList'
> 			AND status = -1
> 			AND (sysdate - start_time < 60/1440);
> 		`,
> 		correctiveActions => [
> 			Ops => "Escalate to AN Engineering",
> 		],
> 	};
> 
> 	$queries{'S4 Migration failures'} = {
> 		description => "List of S4 Migration failures in the past day",
> 		sql => q`SELECT
> 			user_id, info
> 		FROM
> 			event_log
> 		WHERE
> 			status = -1
> 			AND event_name='EventS4Migration'
> 			AND start_time > SYSDATE - 1
> 		`,
> 		correctiveActions => [
> 			Ops => "See note",
> 		],
> 		note => "<html>See <a href=\"$s4MigrationDoc\">$s4MigrationDoc</a></html>",
> 	};
149,150c143
<     $queries{influx_details} = {measurement => "an_datalink_status"};
<     my $qm = ariba::monitor::QueryManager->newWithDetails('datalink-status', 'an', $service, undef, \%queries);
---
> 	my $qm = ariba::monitor::QueryManager->newWithDetails('datalink-status', 'an', $service, undef, \%queries);
153c146
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
158c151,152
< __END__
---
> sub _processSQLReply{
>     my $self = $ariba::monitor::Query::_ourGlobalQuerySelf;
159a154,167
>     ## Per Josh's advice, this will fix Yajun's issue with the 'crit' condition not clearing
>     $self->setCrit( 0 );
> 
>     ## if we're in warn status
>     if ( $self->status() eq 'warn' 
>         ## and it's been an hour since the status changed
>         && time + $fifteenMinutes - $self->lastInfoResultTime() > $oneHourInSeconds ){
>             ## We should go critical
>             $self->setCrit( 1 );
>     }
>     return ( join( "\n", $self->results() ) );
> }
> 
> __END__
65c65
<             select /*+ INDEX(data_link_queue IND_EB809A47_20EB57A7) */ count(id) 
---
>             select /*+ INDEX(data_link_queue IND_EB809A47_20EB57A7) */ count(id)
73,74d72
<         inf_field => "queue_length",
<         inf_default => 0,
82c80
<                 id,ROOT_ID as root_id ,status,(sysdate-CREATED)*24 stuck_time
---
>                 id,ROOT_ID,status,(sysdate-CREATED)*24 stuck_time
91,92d88
<         inf_field => "hash",
<         inf_default => 0,
107,108d102
<         inf_field => "log_stuck",
<         inf_default => 0,
128,129d121
<         inf_field => "failures",
<         inf_default => 0,
147,148d138
<         inf_field => "hash",
<         inf_default => "none",
153d142
<     $queries{influx_details} = { measurement => "an_datalink_status" };
filename:./bin/an/discovery-status
18d17
< use Data::Dumper;
55,58c54
< 	my %queries             = ();
<     my %search_queries      = ();
<     $queries{"influx_details"} = { 'measurement' => "an_discovery_status_search_updater"};
<     $search_queries{"influx_details"} = { 'measurement' => "an_discovery_status_search"};
---
> 	my %queries  = ();
85,88d80
<                     inf_tags    => "node=\"$instanceId\"",
<                     inf_field   => "primary",
<                     inf_default => 0,
<                     group_by    => $instanceId,
105,108d96
<                         inf_tags  => "node=\"$instanceId\"",
<                         inf_field => $index."_since_last_crawl",
<                         inf_default => 0,
<                         group_by  => $instanceId,
118,121d105
<                         inf_tags  => "node=\"$instanceId\"",
<                         inf_field => $index."_crawl_total",
<                         inf_default => 0,
<                         group_by  => $instanceId,
131,134d114
<                         inf_tags  => "node=\"$instanceId\"",
<                         inf_field => $index."_crawl_number",
<                         inf_default => 0,
<                         group_by  => $instanceId,
152,155d131
<                         inf_tags  => "node=\"$instanceId\"",
<                         inf_field => $index."_since_last_backup",
<                         inf_default => 0,
<                         group_by  => $instanceId,
164,167d139
<                         inf_tags  => "node=\"$instanceId\"",
<                         inf_field => $index."_backup_number",
<                         inf_default => 0,
<                         group_by  => $instanceId,
175c147
< 				$search_queries{"$instanceId $index time since last pull"} = {
---
> 				$queries{"$instanceId $index time since last pull"} = {
185,188d156
<                     inf_tags  => "node=\"$instanceId\"",
<                     inf_field => $index."_time_since_last_pull",
<                     inf_default => 0,
<                     group_by  => $instanceId,
190c158
< 				$search_queries{"$instanceId $index pull number"} = {
---
> 				$queries{"$instanceId $index pull number"} = {
197,200d164
<                     inf_tags    => "node=\"$instanceId\"",
<                     inf_field   => $index ."_pull_number",
<                     inf_default => 0,
<                     group_by    => $instanceId,
208,212c172,174
< 	my $q = ariba::monitor::QueryManager->newWithDetails( "discovery-status", $an->name(), $service, undef, \%queries);
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
< 	my $sq = ariba::monitor::QueryManager->newWithDetails( "discovery-status", $an->name(), $service, undef, \%search_queries);
< 	$sq->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	my $q = ariba::monitor::QueryManager->newWithDetails(
> 		"discovery-status", $an->name(), $service, undef, \%queries
> 	);
213a176
> 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/edi-interchange-status
35c35
<               select id as id,document_type as document_type,round((sysdate-status_changed)*24,3) as status_changed
---
> 		      select id,document_type,(sysdate-status_changed)*24
43d42
<           inf_field => "hash",
52d50
<     $queries{influx_details} = { measurement => 'an_edi_interchange_status'};
filename:./bin/an/edi-queue-status
5a6
> use warnings;
19,20c20,21
< my %queries  = ();
< my $LOCKFILE = "/tmp/stratus-an-edi-queue-status";
---
> my %queries = ();
> my $LOCKFILE = "/tmp/an-edi-queue-status";
22,330c23,310
< sub main
< {
<     my $debug     = 0;
<     my $sendEmail = 0;
<     my $sendPage  = 0;
< 
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-d/o) {$debug     = 1;}
<         if ($arg =~ /^-e/o) {$sendEmail = 1;}
<         if ($arg =~ /^-p/o) {$sendPage  = 1;}
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $edi = ariba::rc::InstalledProduct->new("an", $me->service());
< 
<     my %rateQueues;
< 
<     my @queues = ("edi_interchange_queue", "edi_out_queue", "edi_outdisp_queue", "edi_status_update_queue", "edi_translation_queue", "edi_trans_queue", "edi_fa_queue", "edi_break_queue",);
< 
<     my $tm = time ();
<     my ($month, $year, $day) = (localtime ($tm - 259200))[4, 5, 3];
<     my $newCut = timelocal(0, 0, 0, $day, $month, $year);
<     $newCut .= "000";    # status_changed is 1/1000th seconds.
<     $month++;
<     $year += 1900;
<     my $cut = sprintf ("%4d-%02d-%02d", $year, $month, $day);
< 
<     for my $queue (@queues)
<     {
<         my $hours = 2;
<         if ($queue eq 'edi_status_update_queue')
<         {
<             $hours = 0.333;
<         }
<         my $longHours         = 6;
<         my $note              = undef;
<         my $critRows          = 10;
<         my $skipNotifications = 0;
<         my $openTicket        = undef;
<         my $stuckCrit         = undef;
< 
<         my $warn              = 30;
<         my $crit              = 100;
<         my $stuckSql          = "select id,item ,status,round((sysdate-status_changed)*24) stuck_time from $queue where status in ('Queued','Processing') and (sysdate-status_changed)*24 > $hours";
<         my $stuckSql6h        = "select id as id,item as item,status as status,round((sysdate-status_changed)*24) stuck_time from $queue where status in ('Queued','Processing') and (sysdate-status_changed)*24 > $longHours";
<         my $countSql          = "select count(id) as count from $queue where status in ('Queued','Processing')";
<         my $queuename         = $queue;
<         my $totalCountSql     = "select count(id) as count from $queue where status_changed > to_date('$cut', 'YYYY-MM-DD')";
<         my $completedCountSql = "select count(id) as count from $queue where status_changed > to_date('$cut', 'YYYY-MM-DD') AND status not in ('Queued', 'Processing')";
< 
<         if ($queue eq 'edi_fa_queue')
<         {
<             $warn = 1000;
<             $crit = 4000;
<         }
<         elsif ($queue eq 'edi_out_queue')
<         {
<             $warn = 100;
<             $crit = 150;
<         }
<         elsif ($queue eq 'edi_outdisp_queue')
<         {
<             $warn     = 100;
<             $crit     = 150;
<             $stuckSql = "select /*+ INDEX(edi_outdisp_queue IND_B3B26EEF_B1A4A7A0) */ id, item, decode(status, 1, 'Queued', 2, 'Processing', 'Unknown' ||  status),round(($tm - (status_changed/1000))/3600) stuck_time from $queue where status in (1, 2) and $tm - (status_changed/1000) > $hours * 3600";
<             $countSql = "select /*+ INDEX(edi_outdisp_queue IND_B3B26EEF_B1A4A7A0) */ count(id) as count from $queue where status in (1,2)";
<         }
<         elsif ($queue eq 'edi_break_queue')
<         {
<             $warn       = undef;
<             $crit       = undef;
<             $critRows   = undef;
<             $openTicket = 1;
<             $note       = 'see http://ops.ariba.com/documentation/prodops/common/query_notes/edi_queues.txt';
<         }
<         elsif ($queue eq 'edi_interchange_queue')
<         {
<             $warn = 40;
<         }
<         elsif ($queue eq 'edi_status_update_queue')
<         {
<             $warn     = undef;
<             $crit     = undef;
<             $critRows = undef;
<         }
<         elsif ($queue eq 'edi_translation_queue')
<         {
<             $warn = 300;
<             $crit = 3000;
<         }
<         elsif ($queue eq 'edi_trans_queue')
<         {
<             $warn     = 4000;
<             $crit     = 8000;
<             $stuckSql = "select /*+ INDEX(edi_trans_queue IND_AB537CA5_D5BE9811) */ id, item, decode(status, 1, 'Queued', 2, 'Processing', 'Unknown' || status),round(($tm - (status_changed/1000))/3600) stuck_time from $queue where status in (1, 2) and $tm - (status_changed/1000) > $hours * 3600";
<             $countSql = "select /*+ INDEX(edi_trans_queue IND_AB537CA5_D5BE9811) */ count(id) as count from $queue where status in (1,2)";
<         }
< 
<         if ($queue eq 'edi_trans_queue' || $queue eq 'edi_outdisp_queue')
<         {
<             #
<             # new style queues have slightly different table layout
<             #
<             $totalCountSql     = "select count(id) as count from $queue WHERE (status_changed) > $newCut";
<             $completedCountSql = "select count(id) as count from $queue WHERE (status_changed) > $newCut and status not in (1,2)";
<         }
< 
<         $rateQueues{$queuename} = 1;
< 
<         if ($queue eq 'edi_break_queue')
<         {
<             $queries{"$queuename: items stuck more than $longHours hrs"} = {
<                                                                             recordMaxResults => 20000,
<                                                                             recordDataType   => "gauge",
<                                                                             recordItem       => "numrows",
<                                                                             info             => "numrows > -1",
<                                                                             crit             => "numrows > 1",
<                                                                             format           => "$queue.id %d $queue.item %d  %s %d hours\n",
<                                                                             note             => $note,
<                                                                             sql              => $stuckSql6h,
<                                                                             inf_tags         => qq(type="$queuename",duration="$longHours hrs"),
<                                                                             group_by         => qq($queuename,$longHours),
<                                                                            };
<         }
< 
<         $stuckCrit = "numrows > $critRows" if defined ($critRows);
<         $queries{"$queuename: items stuck more than $hours hrs"} = {
<             recordMaxResults             => 20000,
<             recordDataType               => "gauge",
<             recordItem                   => "numrows",
<             info                         => "numrows > -1",
<             warn                         => "numrows > 0",
<             crit                         => $stuckCrit,
<             format                       => "$queue.id %d $queue.item %d  %s %d hours\n",
<             ticketOnWarnOpenAfterMinutes => $openTicket,
<             note                         => $note,
< 
<             sql      => $stuckSql,
<             inf_tags => qq(type="$queuename",duration="$hours hrs"),
<             group_by => qq($queuename,$hours),
<                                                                    };
< 
<         $warn = "answer > $warn" if defined ($warn);
<         $crit = "answer > $crit && previousAnswer > $crit" if defined ($crit);
<         if ($queue eq 'edi_outdisp_queue')
<         {
<             $queries{"$queuename: items stuck more than $hours hrs"} = {
<                 recordMaxResults             => 20000,
<                 recordDataType               => "gauge",
<                 recordItem                   => "numrows",
<                 info                         => "numrows > -1",
<                 crit                         => $crit,
<                 warn                         => $warn,
<                 format                       => "$queue.id %d $queue.item %d  %s %d hours\n",
<                 ticketOnWarnOpenAfterMinutes => $openTicket,
<                 note                         => $note,
< 
<                 sql      => $stuckSql,
<                 inf_tags => qq(type="$queuename",duration="$hours hrs"),
<                 group_by => qq($queuename,$hours),
<                                                                        };
<         }
< 
<         $queries{"$queuename: queue length (Queued, Processing)"} = {
<             recordMaxResults  => 20000,
<             recordDataType    => "gauge",
<             info              => "answer > -1",
<             warn              => $warn,
<             crit              => $crit,
<             skipNotifications => $skipNotifications,
< 
<             sql      => $countSql,
<             inf_tags => qq(type="$queuename"),
<             group_by => qq($queuename),
<                                                                     };
< 
<         $queries{"$queuename: total length"} = {
<                                                 info             => 1,
<                                                 recordMaxResults => 20000,
<                                                 recordDataType   => "gauge",
<                                                 uiHint           => "ignore",
<                                                 sql              => $totalCountSql,
<                                                 inf_tags         => qq(type="$queuename"),
<                                                 group_by         => qq($queuename),
<                                                };
< 
<         $queries{"$queuename: completed length"} = {
<                                                     info             => 1,
<                                                     recordMaxResults => 20000,
<                                                     recordDataType   => "gauge",
<                                                     uiHint           => "ignore",
<                                                     sql              => $completedCountSql,
<                                                     inf_tags         => qq(type="$queuename"),
<                                                     group_by         => qq($queuename),
<                                                    };
<     }
< 
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = {measurement => "an_edi_queue_status"};
<     my $q = ariba::monitor::QueryManager->newWithDetails("edi-queue-status", "an", $me->service, $me->customer(), \%queries);
< 
<     my $ediDbc = ariba::Ops::DBConnection->connectionsForProductOfDBType($edi, ariba::Ops::DBConnection::typeMainEdi());
<     $q->setSQLConnectInfoFromDBConnection($ediDbc);
< 
<     unless (dmail::LockLib::requestlock($LOCKFILE, 5))
<     {
<         die "can't grab lock\n";
<     }
<     $q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<     #
<     # XXXX -- this is a temporary high priority query for Sysco to
<     # detect a bug in AN49... it breaks some rules, so we should
<     # fix it eventually.
<     #
<     my %syscoQ;
<     $syscoQ{"Failed Interchanges at Break State"} = {
<         info => "numrows == 0",
<         crit => "numrows > 0",
<         sql  => "select inter.id,
<                 inter.control_number, base.created, break.status FROM
<                 edi_break_queue break, edi_interchange_document inter,
<                 edi_base_document base, edi_profile prof
<                 WHERE break.status = 'Failed' and  break.item = inter.id and
<                 inter.basedocument = base.id and
<                 base.document_type = 'Interchange' and base.direction=0 and
<                 base.profile = prof.id and prof.anid = 'AN01002330463' and
<                 break.STATUS_CHANGED > sysdate - 1
<                 order by base.created",
<     };
< 
<     my $emailCS = 0;
<     $emailCS = 1 if (ariba::Ops::ServiceController::isProductionServicesOnly($me->service()));
<     my $syscoQM = ariba::monitor::QueryManager->newWithDetails("edi-queue-status", "an", $me->service, $me->customer(), \%syscoQ);
<     $syscoQM->setSQLConnectInfoFromDBConnection($ediDbc);
<     $syscoQM->processQueries($debug, "dept_support_ants\@ariba.com", $emailCS, 0);
< 
<     my %qq;
<     foreach my $queue (keys %rateQueues)
<     {
<         my ($egress, $ingress, $delta) = (undef, undef, undef);
< 
<         my $qname          = "$queue: total length";
<         my $instance       = ariba::monitor::Query->generateInstanceName($qname, "an", $me->customer(), undef);
<         my $completedQuery = ariba::monitor::Query->new($instance);
< 
<         $qname = "$queue: completed length";
<         $instance = ariba::monitor::Query->generateInstanceName($qname, "an", $me->customer(), undef);
<         my $totalQuery = ariba::monitor::Query->new($instance);
< 
<         #
<         # at midnight, when seven days ago changes, our result counters
<         # will shrink.  We'll just skip this pass.
<         #
<         if (   $totalQuery->hasAttribute('previousResults')
<             && $totalQuery->results() >= $totalQuery->previousResults())
<         {
<             my $interval = $totalQuery->checkTime() - $totalQuery->previousCheckTime();
<             $interval /= 3600;
<             $egress  = ($completedQuery->results() - $completedQuery->previousResults()) / $interval;
<             $egress  = (int ($egress * 100)) / 100;
<             $ingress = ($totalQuery->results() - $totalQuery->previousResults()) / $interval;
<             $ingress = (int ($ingress * 100)) / 100;
< 
<             $delta = $ingress - $egress;
<             $delta = (int ($delta * 100)) / 100;
<         }
< 
<         $qq{"$queue egress rate (items/hour)"} = {
<                                                   info             => 1,
<                                                   perl             => $egress,
<                                                   recordMaxResults => 20000,
<                                                   recordDataType   => "gauge",
<                                                   recordDataUnits  => "items/hour",
<                                                   recordItem       => "answer",
<                                                   inf_field        => "value",
<                                                   inf_tags         => qq(queue_name="$queue",type="egress_rate"),
<                                                   inf_default      => 0,
<                                                   group_by         => qq($queue,"egress_rate"),
<                                                  };
< 
<         $qq{"$queue ingress rate (items/hour)"} = {
<                                                    info             => 1,
<                                                    perl             => $ingress,
<                                                    recordMaxResults => 20000,
<                                                    recordDataType   => "gauge",
<                                                    recordDataUnits  => "items/hour",
<                                                    recordItem       => "answer",
<                                                    inf_field        => "value",
<                                                    inf_default      => 0,
<                                                    inf_tags         => qq(queue_name="$queue",type="ingress_rate"),
<                                                    group_by         => qq($queue,"ingress_rate"),
<                                                   };
< 
<         $qq{"$queue size change rate (items/hour)"} = {
<                                                        info             => 1,
<                                                        perl             => $delta,
<                                                        recordMaxResults => 20000,
<                                                        recordDataType   => "gauge",
<                                                        recordDataUnits  => "items/hour",
<                                                        recordItem       => "answer",
<                                                        inf_field        => "value",
<                                                        inf_default      => 0,
<                                                        inf_tags         => qq(queue_name="$queue",type="change_rate"),
<                                                        group_by         => qq($queue,"change_rate"),
<                                                       };
<     }
<     $qq{'influx_details'} = {'measurement' => "an_edi_queue_egress_ingress"};
---
> sub main{
> 	my $debug = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 
> 	while(my $arg=shift(@ARGV)){
> 		if($arg =~ /^-d/o){ $debug = 1; }
> 		if($arg =~ /^-e/o){ $sendEmail = 1; };
> 		if($arg =~ /^-p/o){ $sendPage = 1; };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $edi = ariba::rc::InstalledProduct->new("an", $me->service());
> 
> 	my %rateQueues;
> 
> 	my @queues=(
> 		"edi_interchange_queue",
> 		"edi_out_queue",
> 		"edi_outdisp_queue",
> 		"edi_status_update_queue",
> 		"edi_translation_queue",
> 		"edi_trans_queue",
> 		"edi_fa_queue",
> 		"edi_break_queue",
> 	);
> 
> 	my $tm = time();
> 	my ($month, $year, $day) = (localtime($tm - 259200))[4,5,3];
> 	my $newCut = timelocal( 0,0,0,$day,$month,$year );
> 	$newCut .= "000"; # status_changed is 1/1000th seconds.
> 	$month++;
> 	$year+=1900;
> 	my $cut = sprintf("%4d-%02d-%02d", $year, $month, $day);
> 
> 	for my $queue (@queues){
> 		my $hours = 2;
> 		if ($queue eq 'edi_status_update_queue') {
> 			$hours = 0.333;
> 		}
> 		my $longHours = 6;
> 		my $note = undef;
> 		my $critRows = 10;
> 		my $skipNotifications = 0;
> 		my $openTicket = undef;
> 		my $stuckCrit = undef;
> 
> 		my $warn = 30;
> 		my $crit = 100;
> 		my $stuckSql = "select id,item,status,(sysdate-status_changed)*24 stuck_time from $queue where status in ('Queued','Processing') and (sysdate-status_changed)*24 > $hours";
> 		my $stuckSql6h = "select id,item,status,(sysdate-status_changed)*24 stuck_time from $queue where status in ('Queued','Processing') and (sysdate-status_changed)*24 > $longHours";
> 		my $countSql = "select count(id) from $queue where status in ('Queued','Processing')";
> 		my $queuename = $queue;
> 		my $totalCountSql = "select count(id) from $queue where status_changed > to_date('$cut', 'YYYY-MM-DD')";
> 		my $completedCountSql = "select count(id) from $queue where status_changed > to_date('$cut', 'YYYY-MM-DD') AND status not in ('Queued', 'Processing')";
> 
> 		if ($queue eq 'edi_fa_queue') {
> 			$warn = 1000;
> 			$crit = 4000;
> 		} elsif ($queue eq 'edi_out_queue') {
> 			$warn = 100;
> 			$crit = 150;
> 		} elsif ($queue eq 'edi_outdisp_queue') {
> 			$warn = 100;
> 			$crit = 150;
> 			$stuckSql = "select /*+ INDEX(edi_outdisp_queue IND_B3B26EEF_B1A4A7A0) */ id, item, decode(status, 1, 'Queued', 2, 'Processing', 'Unknown' ||  status),round(($tm - (status_changed/1000))/3600) stuck_time from $queue where status in (1, 2) and $tm - (status_changed/1000) > $hours * 3600";
> 			$countSql = "select /*+ INDEX(edi_outdisp_queue IND_B3B26EEF_B1A4A7A0) */ count(id) from $queue where status in (1,2)";
> 		} elsif ($queue eq 'edi_break_queue') {
> 			$warn = undef;
> 			$crit = undef;
> 			$critRows = undef;
> 			$openTicket = 1;
> 			$note = 'see http://ops.ariba.com/documentation/prodops/common/query_notes/edi_queues.txt';
> 		} elsif ($queue eq 'edi_interchange_queue') {
> 			$warn = 40;
> 		} elsif ($queue eq 'edi_status_update_queue') {
> 			$warn = undef;
> 			$crit = undef;
> 			$critRows = undef;
> 		} elsif ($queue eq 'edi_translation_queue') {
> 			$warn = 300;
> 			$crit = 3000;
> 		} elsif ($queue eq 'edi_trans_queue') {
> 			$warn=4000;
> 			$crit=8000;
> 			$stuckSql = "select /*+ INDEX(edi_trans_queue IND_AB537CA5_D5BE9811) */ id, item, decode(status, 1, 'Queued', 2, 'Processing', 'Unknown' || status),round(($tm - (status_changed/1000))/3600) stuck_time from $queue where status in (1, 2) and $tm - (status_changed/1000) > $hours * 3600";
> 			$countSql = "select /*+ INDEX(edi_trans_queue IND_AB537CA5_D5BE9811) */ count(id) from $queue where status in (1,2)";
> 		}
> 
> 		if($queue eq 'edi_trans_queue' || $queue eq 'edi_outdisp_queue') {
> 			#
> 			# new style queues have slightly different table layout
> 			#
> 			$totalCountSql = "select count(id) from $queue WHERE (status_changed) > $newCut";
> 			$completedCountSql = "select count(id) from $queue WHERE (status_changed) > $newCut and status not in (1,2)";
> 		}
> 
> 		$rateQueues{$queuename} = 1;
> 
> 		if ($queue eq 'edi_break_queue') {
> 			$queries{"$queuename: items stuck more than $longHours hrs"}= 
> 			{
> 			  	recordMaxResults => 20000,
> 			  	recordDataType=> "gauge",
> 			  	recordItem => "numrows",
> 			  	info => "numrows > -1",
> 			  	crit => "numrows > 1",
> 			  	format => "$queue.id %d $queue.item %d  %s %d hours\n",
> 			  	note => $note,
> 
> 			  	sql => $stuckSql6h,
> 			};
> 		}
> 
> 		$stuckCrit = "numrows > $critRows" if defined($critRows);
> 		$queries{"$queuename: items stuck more than $hours hrs"}=
> 		{
>         recordMaxResults => 20000,
>         recordDataType=> "gauge",
>         recordItem => "numrows",
>         info => "numrows > -1",
>         warn => "numrows > 0",
>         crit => $stuckCrit,
>         format => "$queue.id %d $queue.item %d  %s %d hours\n",
>         ticketOnWarnOpenAfterMinutes => $openTicket,
>         note => $note,
> 
>         sql => $stuckSql,
> 		};
> 
> 
> 
> 		$warn = "answer > $warn" if defined($warn);
> 		$crit = "answer > $crit && previousAnswer > $crit" if defined($crit);
> 		if ($queue eq 'edi_outdisp_queue') {
> 			$queries{"$queuename: items stuck more than $hours hrs"}= 
> 			{
> 			  	recordMaxResults => 20000,
> 			  	recordDataType=> "gauge",
> 			  	recordItem => "numrows",
> 			  	info => "numrows > -1",
> 			  	crit => $crit,
> 			  	warn => $warn,
> 			  	format => "$queue.id %d $queue.item %d  %s %d hours\n",
> 					ticketOnWarnOpenAfterMinutes => $openTicket,
> 			  	note => $note,
> 
> 			  	sql => $stuckSql,
> 			};
> 		} 
> 
> 		$queries{"$queuename: queue length (Queued, Processing)"}=
> 		{
> 			recordMaxResults => 20000,
> 			recordDataType=> "gauge",
> 			info => "answer > -1",
> 			warn => $warn,
> 			crit => $crit,
> 			skipNotifications => $skipNotifications,
> 
> 			sql => $countSql,
> 		};
> 
> 		$queries{"$queuename: total length"} = {
> 			info => 1,
> 			recordMaxResults => 20000,
> 			recordDataType=> "gauge",
> 			uiHint => "ignore",
> 			sql => $totalCountSql,
> 			};
> 
> 		$queries{"$queuename: completed length"} = {
> 			info => 1,
> 			recordMaxResults => 20000,
> 			recordDataType=> "gauge",
> 			uiHint => "ignore",
> 			sql => $completedCountSql,
> 		};
> 	}
> 
> 	my $email = $me->default('notify.email');
> 
> 	my $q = ariba::monitor::QueryManager->newWithDetails(
> 		"edi-queue-status", "an", $me->service, $me->customer(), \%queries
> 	);
> 
> 	my $ediDbc = ariba::Ops::DBConnection->connectionsForProductOfDBType($edi, ariba::Ops::DBConnection::typeMainEdi());
> 	$q->setSQLConnectInfoFromDBConnection( $ediDbc );
> 
> 	unless (dmail::LockLib::requestlock($LOCKFILE,5)) {
> 		die "can't grab lock\n";
> 	};
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
> 
> 	#
> 	# XXXX -- this is a temporary high priority query for Sysco to
> 	# detect a bug in AN49... it breaks some rules, so we should
> 	# fix it eventually.
> 	#
> 	my %syscoQ;
> 	$syscoQ{"Failed Interchanges at Break State"} = {
> 		info => "numrows == 0",
> 		crit => "numrows > 0",
> 		sql => "select inter.id,
> 				inter.control_number, base.created, break.status FROM
> 				edi_break_queue break, edi_interchange_document inter,
> 				edi_base_document base, edi_profile prof
> 				WHERE break.status = 'Failed' and  break.item = inter.id and
> 				inter.basedocument = base.id and
> 				base.document_type = 'Interchange' and base.direction=0 and
> 				base.profile = prof.id and prof.anid = 'AN01002330463' and
> 				break.STATUS_CHANGED > sysdate - 1
> 				order by base.created",
> 	};
> 
> 	my $emailCS = 0;
> 	$emailCS = 1 if(ariba::Ops::ServiceController::isProductionServicesOnly($me->service()));
> 	my $syscoQM = ariba::monitor::QueryManager->newWithDetails(
> 		"edi-queue-status", "an", $me->service, $me->customer(), \%syscoQ
> 	);
> 	$syscoQM->setSQLConnectInfoFromDBConnection( $ediDbc );
> 	$syscoQM->processQueriesUsingServer($debug, "dept_support_ants\@ariba.com", $emailCS, 0);
> 
> 	my %qq;
> 	foreach my $queue (keys %rateQueues) {
> 		my ($egress, $ingress, $delta) = (undef, undef, undef);
> 
> 		my $qname = "$queue: total length";
> 		my $instance = ariba::monitor::Query->generateInstanceName(
> 			$qname, "an", $me->customer(), undef
> 		);
> 		my $completedQuery = ariba::monitor::Query->new($instance);
> 
> 		$qname = "$queue: completed length";
> 		$instance = ariba::monitor::Query->generateInstanceName(
> 			$qname, "an", $me->customer(), undef
> 		);
> 		my $totalQuery = ariba::monitor::Query->new($instance);
> 
> 		#
> 		# at midnight, when seven days ago changes, our result counters
> 		# will shrink.  We'll just skip this pass.
> 		#
> 		if( $totalQuery->hasAttribute('previousResults') &&
> 			$totalQuery->results() >= $totalQuery->previousResults()
> 		) {
> 			my $interval = $totalQuery->checkTime() - $totalQuery->previousCheckTime();
> 			$interval /= 3600;
> 			$egress = ($completedQuery->results() - $completedQuery->previousResults()) / $interval;
> 			$egress = (int($egress*100))/100;
> 			$ingress = ($totalQuery->results() - $totalQuery->previousResults()) / $interval;
> 			$ingress = (int($ingress*100))/100;
> 
> 			$delta = $ingress - $egress;
> 			$delta = (int($delta*100))/100;
> 		}
> 
> 		$qq{"$queue egress rate (items/hour)"} = {
> 			info => 1,
> 			perl => $egress,
> 			recordMaxResults => 20000,
> 			recordDataType => "gauge",
> 			recordDataUnits => "items/hour",
> 			recordItem => "answer",
> 		};
> 
> 		$qq{"$queue ingress rate (items/hour)"} = {
> 			info => 1,
> 			perl => $ingress,
> 			recordMaxResults => 20000,
> 			recordDataType => "gauge",
> 			recordDataUnits => "items/hour",
> 			recordItem => "answer",
> 		};
> 
> 		$qq{"$queue size change rate (items/hour)"} = {
> 			info => 1,
> 			perl => $delta,
> 			recordMaxResults => 20000,
> 			recordDataType => "gauge",
> 			recordDataUnits => "items/hour",
> 			recordItem => "answer",
> 		};
> 	}
> 
> 	my $qqm = ariba::monitor::QueryManager->newWithDetails(
> 		"edi-queue-egress-and-ingress", "an", $me->service(), $me->customer(), \%qq
> 	);
332c312
<     my $qqm = ariba::monitor::QueryManager->newWithDetails("edi-queue-egress-and-ingress", "an", $me->service(), $me->customer(), \%qq);
---
> 	$qqm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
334,336c314
<     $qqm->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<     dmail::LockLib::releaselock($LOCKFILE);
---
> 	dmail::LockLib::releaselock($LOCKFILE);
287,288d286
<             inf_field => "$queue"."_egress_rate",
<             inf_default => 0,
298,299d295
<             inf_field => "$queue"."_ingress_rate",
<             inf_default => 0,
309,310d304
<             inf_field => "$queue"."_change_rate",
<             inf_default => 0,
313d306
<     $qq{'influx_details'} = { 'measurement' => "an_edi_ingress_egress_details"};
filename:./bin/an/esig-status
54,60c54,60
< 				  CXML_DOC_PENDING_OPS.SHOULD_SIGN as should_sign,
< 				  CXML_DOC_PENDING_OPS.SHOULD_VERIFY as should_verify,
< 				  TO_CHAR(CXML_DOC_PENDING_OPS.DOCUMENT) as document,
< 				  CXML_DOCUMENT.DOCUMENT_NUMBER as document_number,
< 				  CURRENT_TIMESTAMP as current_timestamp,
< 				  CXML_DOCUMENT.STATUS_CHANGED as status_changed,
< 				  CURRENT_TIMESTAMP - 0.01 as current_timestamp2
---
> 				  CXML_DOC_PENDING_OPS.SHOULD_SIGN,
> 				  CXML_DOC_PENDING_OPS.SHOULD_VERIFY,
> 				  TO_CHAR(CXML_DOC_PENDING_OPS.DOCUMENT),
> 				  CXML_DOCUMENT.DOCUMENT_NUMBER,
> 				  CURRENT_TIMESTAMP,
> 				  CXML_DOCUMENT.STATUS_CHANGED,
> 				  CURRENT_TIMESTAMP - 0.01
40d39
<             inf_field         => "hash",
54,61c53,60
< 				  /*+ ordered use_nl(CXML_DOC_PENDING_OPS, CXML_DOCUMENT) */
---
> 				  /*+ ordered use_nl(CXML_DOC_PENDING_OPS, CXML_DOCUMENT) */
89d87
<     $queries{"influx_details"} = { measurement => "an_esig_status"};
filename:./bin/an/exchange-rate-status
8d7
< use Data::Dumper;
46,47c45
< 			sql  => "select ((timestamp - to_date('01-01-1970','MM-DD-YYYY')) * 86400) as last_updated from fx_spot where id = 100",
<             inf_field => "last_updated",
---
> 			sql  => "select ((timestamp - to_date('01-01-1970','MM-DD-YYYY')) * 86400) from fx_spot where id = 100",
52d49
<     $queries{influx_details} = { measurement => "exchange_rate_status" };
filename:./bin/an/flowExtension
63d62
< 
94d92
<     $queries{influx_details} = { measurement => 'flowextension_status'};
101,102c99
<        sql => q`SELECT COUNT(*) as queued_state FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 2/24) < SYSDATE AND STATUS = 'QUEUED'`,
<        inf_default => 0,
---
>        sql => q`SELECT COUNT(*) FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 2/24) < SYSDATE AND STATUS = 'QUEUED'`,
110,111c107
<        sql => q`SELECT COUNT(*) as expired_state FROM FLOW_EXT_EVENT WHERE (EXPIRY + 8/24) < SYSDATE AND STATUS NOT IN ('EXPIRED', 'ERROR', 'SUCCESSFUL', 'QUEUED', 'RECEIVED')`,
<        inf_default => 0,
---
>        sql => q`SELECT COUNT(*) FROM FLOW_EXT_EVENT WHERE (EXPIRY + 8/24) < SYSDATE AND STATUS NOT IN ('EXPIRED', 'ERROR', 'SUCCESSFUL', 'QUEUED', 'RECEIVED')`,
118,119c114
<        sql => q`SELECT COUNT(*) as prepared_state_warn FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 1) < SYSDATE AND STATUS = 'PREPARED'`,
<        inf_default => 0,
---
>        sql => q`SELECT COUNT(*) FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 1) < SYSDATE AND STATUS = 'PREPARED'`,
127,128c122
<        sql => q`SELECT COUNT(*) as prepared_state_crit FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 2) < SYSDATE AND STATUS = 'PREPARED'`,
<        inf_default => 0,
---
>        sql => q`SELECT COUNT(*) FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 2) < SYSDATE AND STATUS = 'PREPARED'`,
135,136c129
<        sql => q`SELECT COUNT(*) as received_state_warn FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 2/24) < SYSDATE AND STATUS = 'RECEIVED'`,
<        inf_default => 0,
---
>        sql => q`SELECT COUNT(*) FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 2/24) < SYSDATE AND STATUS = 'RECEIVED'`,
144,145c137
<        sql => q`SELECT COUNT(*) as received_state_crit FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 4/24) < SYSDATE AND STATUS = 'RECEIVED'`,
<        inf_default => 0,
---
>        sql => q`SELECT COUNT(*) FROM FLOW_EXT_EVENT WHERE (LAST_STATUS_CHANGED + 4/24) < SYSDATE AND STATUS = 'RECEIVED'`,
147a140,141
> 
> 
151c145
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/intermedia-status
84c84
< 				$validitySQL = "select count(1) as count_$column from org where id = $id and contains($column, '{$word}') > 0";
---
> 				$validitySQL = "select count(1) from org where id = $id and contains($column, '{$word}') > 0";
96c96
< 				sql	=> "select count(1) as sv_$column from org where id = $id and contains($column, '{$word}') > 0",
---
> 				sql	=> "select count(1) from org where id = $id and contains($column, '{$word}') > 0",
129c129
< 			$rfxCountSQL = "select count(1) as rfx_event from rfx_event where id = $id and contains(keywords, '{$word}') > 0";
---
> 			$rfxCountSQL = "select count(1) from rfx_event where id = $id and contains(keywords, '{$word}') > 0";
190,193d189
<                 inf_field => "last_sync",
<                 inf_tags => qq(index_name="$indexName"),
<                 inf_default => 0,
<                 group_by => $indexName,
203,206d198
<                 inf_field =>  "last_optimize",
<                 inf_tags => qq(index_name="$indexName"),
<                 inf_default => 0,
<                 group_by => $indexName,
219,220c211,212
< 			sql	=> "select max(round((maintenance_end - maintenance_start)*24*60,2)) as duration_$type
< 				from ndr_text_index_log where maintenance_type = '$type'",
---
> 			sql	=> "select max(round((maintenance_end - maintenance_start)*24*60,2))
> 				from ndr_text_index_log where maintenance_type = '$type'"
6d5
< use Data::Dumper;
9c8
< use lib "$FindBin::Bin/../../lib";
---
> use lib "$FindBin::Bin/../../../lib";
25d23
< 	my $queries_summary = {};
72c70
< 			my ($id, $word) = ($results[0]->{'ID'}, $results[0]->{'WORD'});
---
> 			my ($id, $word) = split($oc->colsep(), $results[0]);
92c90
< 			$queries_summary->{"Search validity for org.$column"} = {
---
> 			$queries->{"Search validity for org.$column"} = {
97,98d94
<                 inf_field => "search_validity_". lc($word),
<                 inf_default => "none",
120c116
<  		my ($id, $word) = ($results[0]->{'ID'}, $results[0]->{'WORD'});
---
> 		my ($id, $word)  = split($oc->colsep(), $results[0]);
139c135
< 		$queries_summary->{"Search validity for rfx_event"} = {
---
> 		$queries->{"Search validity for rfx_event"} = {
143,145c139
< 			sql	    => $rfxCountSQL,
< 			inf_field => "rfx_event",
< 			inf_default => 0,
---
> 			sql	=> $rfxCountSQL,
163,167c157
<             my $indexName           = $row->{'INDEX_NAME'};
<             my $synchronizeInterval = $row->{'SYNCHRONIZE_INTERVAL'};
<             my $lastSynchronized    = $row->{'LAST_SYNCHRONIZED'};
<             my $optimizeInterval    = $row->{'OPTIMIZE_INTERVAL'};
<             my $lastOptimized       = $row->{'LAST_OPTIMIZED'};
---
> 			my ($indexName, $synchronizeInterval, $lastSynchronized, $optimizeInterval, $lastOptimized) = split($oc->colsep(), $row);
192,195d181
<                 inf_field => "last_sync",
<                 inf_tags => "index_name=\"$indexName\"",
<                 inf_default => 0,
<                 group_by => $indexName,
205,208d190
<                 inf_field =>  "last_optimize",
<                 inf_tags  => "index_name=\"$indexName\"",
<                 inf_default => 0,
<                 group_by => $indexName,
217c199
< 		$queries_summary->{"Max duration of $type in minutes"} = {
---
> 		$queries->{"Max duration of $type in minutes"} = {
221,224c203,204
< 			sql	=> "select max(round((maintenance_end - maintenance_start)*24*60,2)) as duration
< 				from ndr_text_index_log where maintenance_type = '$type'",
<             inf_field => "max_duration". lc("_$type"),
<             inf_default => 0,
---
> 			sql	=> "select max(round((maintenance_end - maintenance_start)*24*60,2))
> 				from ndr_text_index_log where maintenance_type = '$type'"
229,230c209
<     $queries->{influx_details} = { measurement => "intermedia_status" };
<     $queries_summary->{influx_details} = { measurement => "intermedia_status_summary" };
---
> 	my $q = ariba::monitor::QueryManager->newWithDetails('intermedia-status', 'an', $me->service(), $me->customer(), $queries);
232,234c211
<     my $q  = ariba::monitor::QueryManager->newWithDetails('intermedia-status', 'an', $me->service(), $me->customer(), $queries);
<     $q->setSQLConnectInfoFromOracleClient($oc);
<     $q->processQueries($debug, $me->default('notify.email'), $sendEmail, $sendPage);
---
> 	$q->setSQLConnectInfoFromOracleClient($oc);
236,239c213
< 
<     my $qs = ariba::monitor::QueryManager->newWithDetails('intermedia-status', 'an', $me->service(), $me->customer(), $queries_summary);
<     $qs->setSQLConnectInfoFromOracleClient($oc);
<     $qs->processQueries($debug, $me->default('notify.email'), $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $me->default('notify.email'), $sendEmail, $sendPage);
filename:./bin/an/messaging-queue-status
1,2c1,2
< #!/usr/local/tools/perl-5.22.1/bin/perl 
< # $Id: //ariba/services/monitor/bin/an/messaging-queue-status#1 $
---
> #!/usr/local/tools/perl-5.22.1/bin/perl
> # $Id: //ariba/services/monitor/bin/an/messaging-queue-status#2 $
4a5
> use warnings;
106c107
<     #print "\nappname --> ".$instance->appName if($debug);
---
> 	#print "\nappname --> ".$instance->appName if($debug);
190,191c191,192
<             my $queryname = ( $queue ) ? qq($queue m $display) : qq(m $display);
<             $queryname =~ s/\s+/_/g;
---
> 
>             my $queryname = "$queue m$display";
199c200
<         correctiveActions => [
---
> 		correctiveActions => [
201,204c202,203
<         Engr => 'Evaluate the KR Logs of CollabPlatform and CollabQueueListeners nodes and take appropriate action.',
<             ],      
<                 inf_field => lc($queryname),
<                 inf_default => 0
---
> 		Engr => 'Evaluate the KR Logs of CollabPlatform and CollabQueueListeners nodes and take appropriate action.',
>         	],		
82d83
< $queries->{'influx_details'} = { 'measurement' => "an_messaging_queue_status" };
204,205d204
<                 inf_field => lc($queue). "_size",
<                 inf_default => 0
filename:./bin/an/micro-queue-status
170d169
< 
194,196d192
< 
<             ### Replace '-' with '_'
<             $queue =~ s/-/_/g;
268d263
< 
82d83
< $queries->{influx_details} = { measurement => 'an_micro_queue_status' };
198,199d198
<                 inf_field => lc($queue),
<                 inf_default => 0,
filename:./bin/an/order-methods
8c8
< use lib "$FindBin::Bin/../../lib";
---
> use lib "$FindBin::Bin/../../../lib";
70,71d69
<             	  inf_field => 'hash',
<             	  inf_sort => 0,
75,76d72
<     $queries{influx_details} = {measurement => "order_details"};
< 
filename:./bin/an/order-status
81d80
<             inf_field => 'hash',
97d95
<          inf_field => 'hash',
132,133d129
<          inf_field => 'hash',
< 
167d162
<          inf_field => 'hash',
202d196
<          inf_field => 'hash',
238d231
<          inf_field => 'hash',
298d290
<          inf_field => 'hash',
303d294
<     $queries{influx_details} = { measurement => 'an_order_status'};
317c308
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/payments-an
61c61
< use  lib "$FindBin::Bin/../../lib";
---
> use lib "$FindBin::Bin/../../lib";
102c102
<        sql => q`Select p.payment_proposal_id, o.anid as buyer_anid, o1.anid as supplier_anid, p.status as payment_status
---
>        sql => q`Select p.payment_proposal_id, o.anid as BUYER_ANID, o1.anid as SUPPLIER_ANID, p.status as PAYMENT_STATUS
106d105
<         inf_field => "hash",
115c114
<        sql => q`Select p.payment_proposal_id, o.anid as buyer_anid, o1.anid as supplier_anid, p.status as payment_status
---
>        sql => q`Select p.payment_proposal_id, o.anid as BUYER_ANID, o1.anid as SUPPLIER_ANID, p.status as PAYMENT_STATUS
119d117
<         inf_field => "hash",
128c126
<        sql => q`Select p.payment_proposal_id, o.anid as buyer_anid, o1.anid as supplier_anid, p.status as payment_status
---
>        sql => q`Select p.payment_proposal_id, o.anid as BUYER_ANID, o1.anid as SUPPLIER_ANID, p.status as PAYMENT_STATUS
133d130
<         inf_field => "hash",
136,137d132
<     $queries{"influx_details"} = { 'measurement' => "payments_an" };
< 
141c136
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/replication-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
10c10
< use ariba::monitor::Query;
---
> use ariba::monitor::Query; 
15c15
< use ariba::Ops::DateTime;
---
> use ariba::Ops::DateTime; 
17,44c17,223
< sub processDurationAnswer
< {
<     my $repairingCommunitiesRef = shift;
<     my $query                   = $ariba::monitor::Query::_ourGlobalQuerySelf;
< 
<     if ($repairingCommunitiesRef->{$query->communityId()})
<     {
<         $query->setWarn("answer > 1200 && previousAnswer > 1200");
<         if (   $query->anReplicatorIsRepairing()
<             && $query->anReplicatorIsRepairing() eq 'false')
<         {
<             $query->setAnReplicatorIsRepairingStartTime(time ());
<         }
<         $query->setAnReplicatorIsRepairing('true');
<     }
<     else
<     {
<         if (   $query->anReplicatorIsRepairing()
<             && $query->anReplicatorIsRepairing() eq 'true'
<             && $query->anReplicatorIsRepairingStartTime())
<         {
<             $query->setAnReplicatorLastRepairStartTime($query->anReplicatorIsRepairingStartTime());
<             $query->setAnReplicatorLastRepairEndTime(time ());
<             $query->setAnReplicatorLastRepairLength(ariba::Ops::DateTime::scaleTime($query->anReplicatorLastRepairEndTime() - $query->anReplicatorLastRepairStartTime()));
<             $query->deleteAnReplicatorIsRepairingStartTime();
<         }
<         $query->setAnReplicatorIsRepairing('false');
<     }
---
> sub processDurationAnswer { 
> 	my $repairingCommunitiesRef = shift; 
> 	my $query = $ariba::monitor::Query::_ourGlobalQuerySelf; 
> 
> 	if ($repairingCommunitiesRef->{$query->communityId()}) { 
> 		$query->setWarn("answer > 1200 && previousAnswer > 1200"); 
> 		if ($query->anReplicatorIsRepairing() && 
> 			$query->anReplicatorIsRepairing() eq 'false') { 
> 			$query->setAnReplicatorIsRepairingStartTime(time()); 
> 		}
> 		$query->setAnReplicatorIsRepairing('true'); 		
> 	} else { 
> 		if ($query->anReplicatorIsRepairing() && 
> 			$query->anReplicatorIsRepairing() eq 'true' && 
> 			$query->anReplicatorIsRepairingStartTime()) { 
> 			$query->setAnReplicatorLastRepairStartTime($query->anReplicatorIsRepairingStartTime()); 
> 			$query->setAnReplicatorLastRepairEndTime(time()); 
> 			$query->setAnReplicatorLastRepairLength(ariba::Ops::DateTime::scaleTime($query->anReplicatorLastRepairEndTime() - $query->anReplicatorLastRepairStartTime())); 
> 			$query->deleteAnReplicatorIsRepairingStartTime(); 
> 		} 
> 		$query->setAnReplicatorIsRepairing('false'); 
> 	}
> 
> 	return $query->results(); 
> } 
> 
> sub processStalledReplicationAnswer { 
> 	my $repairingCommunitiesRef = shift; 
> 	my $minutes = shift;  
> 	my $query = $ariba::monitor::Query::_ourGlobalQuerySelf; 
> 
> 	if ($repairingCommunitiesRef->{$query->communityId()}) { 
> 		$query->deleteWarn() if ($minutes == 10); 
> 		$query->setTicketOnWarnOpenAfterMinutes(($minutes == 60) ? 10 : 0);  
> 		$query->setAnReplicatorIsRepairing('true'); 
> 	} else { 
> 		$query->setTicketOnWarnOpenAfterMinutes(($minutes == 30) ? 10 : 0);  
> 		$query->setAnReplicatorIsRepairing('false'); 
> 	} 
> 
> 	return $query->results(); 
> } 
> 
> sub main{
> 	my $debug = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my %repairingCommunities;
> 
> 	while(my $arg=shift(@ARGV)){
> 		if($arg =~ /^-d/o){ $debug = 1; }
> 		if($arg =~ /^-e/o){ $sendEmail = 1; };
> 		if($arg =~ /^-p/o){ $sendPage = 1; };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $an = ariba::rc::InstalledProduct->new("an", $me->service());
> 	
> 	my @communityIds = ariba::Ops::ProductAPIExtensions::communityIdsForProduct($an);
> 	my $communitiesList = join(", ", @communityIds);
> 	
> 	my @replicatorInstances = grep { $_->appName() =~ /ANReplicatorDaemon/ } $an->appInstancesInCluster($me->currentCluster());
> 	for my $instance (@replicatorInstances) {
> 		my $monStats = ariba::monitor::AppInstanceStats->newFromAppInstance($instance);
> 		$monStats->fetch();
> 		$repairingCommunities{$instance->community()} = 1 if ($monStats->isRepairing() eq 'true');
> 	}
> 
> 	my %queries = (
> 		"Replication errors, row count does not match" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  aggregationMethod => "counts",
> 		  info => "answer > -1",
> 		  warn => "answer > 0 && previousAnswer > 0",
> 		  ticketOnWarnOpenAfterMinutes => 10,
> 
> 		  sql => q`
> 			select count(id) from replication_error where fixed is null and nvl(fix_attempts,0) >= 3
> 		    `,
> 		},
> 
> 		"Replication errors some rows have failed" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  aggregationMethod => "counts",
> 		  info => "answer > -1",
> 		  warn => "answer > 0 && previousAnswer > 0",
> 		  ticketOnWarnOpenAfterMinutes => 10,
> 
> 		  sql => q`
> 			select count(id) from replication_error_rows where fixed is null and nvl(fix_attempts,0) >= 3
> 		    `,
> 		},
> 
> 		#
> 		# Pass 1 runs every minute and replicates data from last
> 		# 1 minute, make sure it can run in under a min.
> 		#
> 		"Duration in secs of the longest Pass 1 replication task" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  info => "answer > -1",
> 		  warn => "answer > 200 && previousAnswer > 200",
> 		  ticketOnWarnOpenAfterMinutes => 10,
> 		  recordMaxResults => 20000,
> 		  recordDatatype => "gauge",
> 		  recordItem => "answer",
> 		  format => "%0.2f",
> 		  processAnswer => sub { return main::processDurationAnswer(\%repairingCommunities); }, 
> 		  sql => q`
> 			select max(duration) from ( 
> 				select source, sum(rep_execution_finish-rep_execution_start)*24*3600
> 				duration from replication_status 
> 				where pass = 1 
> 				group by source)
> 		    `,
> 		},
> 
> 		#
> 		# Pass 2 runs every 20 mins and replicates data from last 1 min AND
> 		# data from 1 hour and 1 hour and 20 mins ago. This takes longer
> 		# than Pass 1, but should still finish fast enough.
> 		#
> 		"Duration in secs of the longest Pass 2 replication task" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  info => "answer > -1",
> 		  warn => "answer > 240 && previousAnswer > 240",
> 		  recordMaxResults => 20000,
> 		  recordDatatype => "gauge",
> 		  recordItem => "answer",
> 		  format => "%0.2f",
> 		  processAnswer => sub { return main::processDurationAnswer(\%repairingCommunities); }, 
> 		  sql => q`
> 			select max(duration) from ( 
> 				select source, sum(rep_execution_finish-rep_execution_start)*24*3600
> 				duration from replication_status 
> 				where pass = 2 
> 				group by source)
> 		    `,
> 		},
> 
> 		"Stalled Pass 1 replication tasks for more than 10 mins" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  aggregationMethod => "counts",
> 		  info => "answer > -1",
> 		  warn => "answer > 0 && previousAnswer > 0",
> 		  recordMaxResults => 20000,
> 		  recordDatatype => "gauge",
> 		  recordItem => "answer",
> 		  processAnswer => sub { return main::processStalledReplicationAnswer(\%repairingCommunities, 10); }, 
> 		  sql => q`
> 			select count(id) from replication_status where pass=1 and
> 			(rep_execution_finish < sysdate - 10/(24*60))
> 		    `,
> 		},
> 
> 		"Stalled Pass 1 replication tasks for more than 30 mins. Replication is stopped" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  aggregationMethod => "counts",
> 		  info => "answer > -1",
> 		  warn => "answer > 0 && previousAnswer > 0",
> 		  recordMaxResults => 20000,
> 		  recordDatatype => "gauge",
> 		  recordItem => "answer",
> 		  processAnswer => sub { return main::processStalledReplicationAnswer(\%repairingCommunities, 30); }, 
> 		  sql => q`
> 			select count(id) from replication_status where pass=1 and
> 			(rep_execution_finish < sysdate - 30/(24*60))
> 		    `,
> 		},
> 
> 		"Stalled Pass 1 replication tasks for more than 60 mins. Replication is stopped" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  aggregationMethod => "counts",
> 		  info => "answer > -1",
> 		  warn => "answer > 0 && previousAnswer > 0",
> 		  recordMaxResults => 20000,
> 		  recordDatatype => "gauge",
> 		  recordItem => "answer",
> 		  processAnswer => sub { return main::processStalledReplicationAnswer(\%repairingCommunities, 60); }, 
> 		  sql => q`
> 			select count(id) from replication_status where pass=1 and
> 			(rep_execution_finish < sysdate - 60/(24*60))
> 		    `,
> 		},
> 
> 		"Stalled Pass 2 replication tasks for more than 2 hours. Replication is stopped" =>
> 		{
> 		  runForCommunities => $communitiesList,
> 		  aggregationMethod => "counts",
> 		  info => "answer > -1",
> 		  warn => "answer > 0 && previousAnswer > 0",
> 		  recordMaxResults => 20000,
> 		  recordDatatype => "gauge",
> 		  recordItem => "answer",
> 		  sql => q`
> 			select count(id) from replication_status where pass=2 and
> 			(rep_execution_finish < sysdate - 2/24)
> 		    `,
> 		},
> 
> 	);
46,68c225
<     return $query->results();
< }
< 
< sub processStalledReplicationAnswer
< {
<     my $repairingCommunitiesRef = shift;
<     my $minutes                 = shift;
<     my $query                   = $ariba::monitor::Query::_ourGlobalQuerySelf;
< 
<     if ($repairingCommunitiesRef->{$query->communityId()})
<     {
<         $query->deleteWarn() if ($minutes == 10);
<         $query->setTicketOnWarnOpenAfterMinutes(($minutes == 60) ? 10 : 0);
<         $query->setAnReplicatorIsRepairing('true');
<     }
<     else
<     {
<         $query->setTicketOnWarnOpenAfterMinutes(($minutes == 30) ? 10 : 0);
<         $query->setAnReplicatorIsRepairing('false');
<     }
< 
<     return $query->results();
< }
---
> 	my $email = $me->default('notify.email');
70,232c227
< sub main
< {
<     my $debug     = 0;
<     my $sendEmail = 0;
<     my $sendPage  = 0;
<     my %repairingCommunities;
< 
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-d/o) {$debug     = 1;}
<         if ($arg =~ /^-e/o) {$sendEmail = 1;}
<         if ($arg =~ /^-p/o) {$sendPage  = 1;}
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $an = ariba::rc::InstalledProduct->new("an", $me->service());
< 
<     my @communityIds = ariba::Ops::ProductAPIExtensions::communityIdsForProduct($an);
<     my $communitiesList = join (", ", @communityIds);
< 
<     my @replicatorInstances = grep {$_->appName() =~ /ANReplicatorDaemon/} $an->appInstancesInCluster($me->currentCluster());
<     for my $instance (@replicatorInstances)
<     {
<         my $monStats = ariba::monitor::AppInstanceStats->newFromAppInstance($instance);
<         $monStats->fetch();
<         $repairingCommunities{$instance->community()} = 1 if ($monStats->isRepairing() eq 'true');
<     }
< 
<     my %queries = (
<         "Replication errors, row count does not match" => {
<             runForCommunities            => $communitiesList,
<             aggregationMethod            => "counts",
<             info                         => "answer > -1",
<             warn                         => "answer > 0 && previousAnswer > 0",
<             ticketOnWarnOpenAfterMinutes => 10,
< 
<             sql => q`
<             select count(id) as row_count_does_not_match from replication_error where fixed is null and nvl(fix_attempts,0) >= 3
<             `,
<         },
< 
<         "Replication errors some rows have failed" => {
<             runForCommunities            => $communitiesList,
<             aggregationMethod            => "counts",
<             info                         => "answer > -1",
<             warn                         => "answer > 0 && previousAnswer > 0",
<             ticketOnWarnOpenAfterMinutes => 10,
< 
<             sql => q`
<             select count(id) as failed_rows from replication_error_rows where fixed is null and nvl(fix_attempts,0) >= 3
<             `,
<         },
< 
<         #
<         # Pass 1 runs every minute and replicates data from last
<         # 1 minute, make sure it can run in under a min.
<         #
<         "Duration in secs of the longest Pass 1 replication task" => {
<             runForCommunities            => $communitiesList,
<             info                         => "answer > -1",
<             warn                         => "answer > 200 && previousAnswer > 200",
<             ticketOnWarnOpenAfterMinutes => 10,
<             recordMaxResults             => 20000,
<             recordDatatype               => "gauge",
<             recordItem                   => "answer",
<             format                       => "%0.2f",
<             processAnswer                => sub {return main::processDurationAnswer(\%repairingCommunities);},
<             sql                          => q`
<             select round(max(duration),3) as longest_pass_1 from ( 
<                 select source, sum(rep_execution_finish-rep_execution_start)*24*3600
<                 duration from replication_status 
<                 where pass = 1 
<                 group by source)
<             `,
<         },
< 
<         #
<         # Pass 2 runs every 20 mins and replicates data from last 1 min AND
<         # data from 1 hour and 1 hour and 20 mins ago. This takes longer
<         # than Pass 1, but should still finish fast enough.
<         #
<         "Duration in secs of the longest Pass 2 replication task" => {
<             runForCommunities => $communitiesList,
<             info              => "answer > -1",
<             warn              => "answer > 240 && previousAnswer > 240",
<             recordMaxResults  => 20000,
<             recordDatatype    => "gauge",
<             recordItem        => "answer",
<             format            => "%0.2f",
<             processAnswer     => sub {return main::processDurationAnswer(\%repairingCommunities);},
<             sql               => q`
<             select round(max(duration),3) as longest_pass_2 from ( 
<                 select source, sum(rep_execution_finish-rep_execution_start)*24*3600
<                 duration from replication_status 
<                 where pass = 2 
<                 group by source)
<             `,
<         },
< 
<         "Stalled Pass 1 replication tasks for more than 10 mins" => {
<             runForCommunities => $communitiesList,
<             aggregationMethod => "counts",
<             info              => "answer > -1",
<             warn              => "answer > 0 && previousAnswer > 0",
<             recordMaxResults  => 20000,
<             recordDatatype    => "gauge",
<             recordItem        => "answer",
<             processAnswer     => sub {return main::processStalledReplicationAnswer(\%repairingCommunities, 10);},
<             sql               => q`
<             select count(id) as pass1_more_than_10_mins from replication_status where pass=1 and
<             (rep_execution_finish < sysdate - 10/(24*60))
<             `,
<         },
< 
<         "Stalled Pass 1 replication tasks for more than 30 mins. Replication is stopped" => {
<             runForCommunities => $communitiesList,
<             aggregationMethod => "counts",
<             info              => "answer > -1",
<             warn              => "answer > 0 && previousAnswer > 0",
<             recordMaxResults  => 20000,
<             recordDatatype    => "gauge",
<             recordItem        => "answer",
<             processAnswer     => sub {return main::processStalledReplicationAnswer(\%repairingCommunities, 30);},
<             sql               => q`
<             select count(id) as pass1_more_than_30_mins from replication_status where pass=1 and
<             (rep_execution_finish < sysdate - 30/(24*60))
<             `,
<         },
< 
<         "Stalled Pass 1 replication tasks for more than 60 mins. Replication is stopped" => {
<             runForCommunities => $communitiesList,
<             aggregationMethod => "counts",
<             info              => "answer > -1",
<             warn              => "answer > 0 && previousAnswer > 0",
<             recordMaxResults  => 20000,
<             recordDatatype    => "gauge",
<             recordItem        => "answer",
<             processAnswer     => sub {return main::processStalledReplicationAnswer(\%repairingCommunities, 60);},
<             sql               => q`
<             select count(id) as pass1_more_than_60_mins from replication_status where pass=1 and
<             (rep_execution_finish < sysdate - 60/(24*60))
<             `,
<         },
< 
<         "Stalled Pass 2 replication tasks for more than 2 hours. Replication is stopped" => {
<             runForCommunities => $communitiesList,
<             aggregationMethod => "counts",
<             info              => "answer > -1",
<             warn              => "answer > 0 && previousAnswer > 0",
<             recordMaxResults  => 20000,
<             recordDatatype    => "gauge",
<             recordItem        => "answer",
<             sql               => q`
<             select count(id) as pass2_more_than_2_hours from replication_status where pass=2 and
<             (rep_execution_finish < sysdate - 2/24)
<             `,
<         },
< 
<     );
< 
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = {measurement => "an_replication_status"};
<     my $q = ariba::monitor::QueryManager->newWithDetails("replication-status", "an", $me->service(), $me->customer(), \%queries);
---
> 	my $q = ariba::monitor::QueryManager->newWithDetails("replication-status", "an", $me->service(), $me->customer(), \%queries);
234c229
<     ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $q);
---
> 	ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $q);
236c231
<     $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
97,98d96
<             inf_field => "row_count_does_not_match",
<             inf_default => 0,
112,113d109
<             inf_field => "failed_rows",
<             inf_default => 0,
138,139d133
<             inf_field => "longest_pass_1",
<             inf_default => 0,
164,165d157
<             inf_field => "longest_pass_2",
<             inf_default => 0,
182,183d173
<             inf_field => "stalled_pass_1_more_than_10_mins",
<             inf_default => 0,
200,201d189
<             inf_field => "stalled_pass_1_more_than_30_mins",
<             inf_default => 0,
218,219d205
<             inf_field => "stalled_pass_1_more_than_60_mins",
<             inf_default => 0,
235,236d220
<             inf_field => "stalled_pass_2_more_than_2_hours",
<             inf_default => 0,
242c226
<    $queries{influx_details} = { measurement => "an_replication_status" }; 
---
> 
filename:./bin/an/rfx-digest-status
90,102c90
<     $q_failed->{'discovery digest failed tasks'} = {
<         info => 1,
<         uiHint => 'failed tasks',
<         crit => 'numrows > 0',
<         sql => q(select * from st_disp_queue where DESTINATION0 in
<                 ( 'ADSendRfxDigestsTask', 'ADSendRfxUrgentDigestsTask')
<                 and status=4),
<         runForCommunities => $communitiesList,
<         recordMaxResults => 20000,
<         recordDataType => "gauge",
<     };
< 
< 	$q_event->{'E-Intro in quarantine'} = {
---
> 	$q->{'E-Intro in quarantine'} = {
105c93
< 		sql => 'select count(1) as qurantine from rfx_event where event_state = 1005',
---
> 		sql => 'select count(1) from rfx_event where event_state = 1005',
110c98
< 	$q_event->{'E-Intro in pre-quarantine'} = {
---
> 	$q->{'E-Intro in pre-quarantine'} = {
113c101
< 		sql => 'select count(1) as pre_qurantine from rfx_event where event_state = 1004',
---
> 		sql => 'select count(1) from rfx_event where event_state = 1004',
9,10c9
< #use lib "$FindBin::Bin/../../../lib";
< use lib "$FindBin::Bin/../../lib";
---
> use lib "$FindBin::Bin/../../../lib";
53,59c52
<     my $q_digest_status;
<     my $q_failed;
<     my $q_event;
< 
<     $q_digest_status->{influx_details} = { measurement => "rfx_digest_status"};
<     $q_event->{influx_details}         = { measurement => "rfx_event"};
<     $q_failed->{influx_details}        = { measurement => "rfx_failed"};
---
> 	my $q;
61c54
< 	$q_digest_status->{'rfx digest items not processed for 24 hours'} = {
---
> 	$q->{'rfx digest items not processed for 24 hours'} = {
65c58
< 		sql => 'select count(1) as not_processed_for_24_hours from rfx_digest_item rdi where rdi.disabled = 0 and not exists (select 1 from rfx_digest_event rd where rd.event = rdi.event) and rdi.digest_time < (sysdate - 1) and not exists (select 1 from rfx_event_an where id = rdi.event and event_state != 19)',
---
> 		sql => 'select count(1) from rfx_digest_item rdi where rdi.disabled = 0 and not exists (select 1 from rfx_digest_event rd where rd.event = rdi.event) and rdi.digest_time < (sysdate - 1) and not exists (select 1 from rfx_event_an where id = rdi.event and event_state != 19)',
71c64,76
< 	$q_digest_status->{'rfx digest items not processed for 8 hours'} = {
---
>     $q->{'discovery digest failed tasks'} = {
>         info => 1,
>         uiHint => 'failed tasks',
>         crit => 'numrows > 0',
>         sql => q(select * from st_disp_queue where DESTINATION0 in
>                 ( 'ADSendRfxDigestsTask', 'ADSendRfxUrgentDigestsTask')
>                 and status=4),
>         runForCommunities => $communitiesList,
>         recordMaxResults => 20000,
>         recordDataType => "gauge",
>     };
> 
> 	$q->{'rfx digest items not processed for 8 hours'} = {
75c80
< 		sql => 'select count(1) as not_processed_for_8_hours from  rfx_digest_item rdi where rdi.digest_time < (sysdate - 8/24) and rdi.disabled = 0 and not exists (select 1 from rfx_digest_event rd where rd.event = rdi.event)',
---
> 		sql => 'select count(1) from  rfx_digest_item rdi where rdi.digest_time < (sysdate - 8/24) and rdi.disabled = 0 and not exists (select 1 from rfx_digest_event rd where rd.event = rdi.event)',
81c86
< 	$q_digest_status->{'rfx digest items waiting to be sent'} = {
---
> 	$q->{'rfx digest items waiting to be sent'} = {
84c89
< 		sql => 'select count(1) as waiting_to_send from  rfx_digest_item rdi where  rdi.disabled = 0 and not exists (select 1 from rfx_digest_event rd where rd.event = rdi.event)',
---
> 		sql => 'select count(1) from  rfx_digest_item rdi where  rdi.disabled = 0 and not exists (select 1 from rfx_digest_event rd where rd.event = rdi.event)',
88d92
<         inf_field => "awaiting",
110,111d100
<         	inf_field => "qurantine",
<         	inf_default => 0,
120,121d108
<         	inf_field => "pre_qurantine",
<         	inf_default => 0,
124c111
< 	my $qm = ariba::monitor::QueryManager->newWithDetails('rfx', 'an', $service, undef, $q_digest_status);
---
> 	my $qm = ariba::monitor::QueryManager->newWithDetails('rfx', 'an', $service, undef, $q);
127c114
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
129,137d115
< 	my $qm2 = ariba::monitor::QueryManager->newWithDetails('rfx', 'an', $service, undef, $q_event);
< 	$qm2->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($an));
< 	ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $qm2);
< 	$qm2->processQueries($debug, $email, $sendEmail, $sendPage);
< 
< 	my $qm3 = ariba::monitor::QueryManager->newWithDetails('rfx', 'an', $service, undef, $q_failed);
< 	$qm3->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($an));
< 	ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $qm3);
< 	$qm3->processQueries($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/rfx-notification
52c52
< 		sql => 'select count(1) as pending_notification from rfx_pending_notification',
---
> 		sql => 'select count(1) from rfx_pending_notification',
62c62
< 		sql => 'SELECT COUNT(*) as stale_event_notification FROM rfx_pending_notification n JOIN rfx_event event ON event.id = n.event JOIN org o ON o.id = event.sourcing_org WHERE (o.type <> 110) AND n.ACTION_DATE < SYSDATE - 2 AND n.ACTION is not null AND event.is_test = 0',
---
> 		sql => 'SELECT COUNT(*) FROM rfx_pending_notification n JOIN rfx_event event ON event.id = n.event JOIN org o ON o.id = event.sourcing_org WHERE (o.type <> 110) AND n.ACTION_DATE < SYSDATE - 2 AND n.ACTION is not null AND event.is_test = 0',
9c9
< use lib "$FindBin::Bin/../../lib";
---
> use lib "$FindBin::Bin/../../../lib";
47d46
<     	$q->{influx_details} = { measurement => 'rfx_notification'};
55,56d53
<         	inf_field => "pending_notification",
<         	inf_default => 0,
69,70d65
<         	inf_field => "stale_event_notification",
<         	inf_default => 0,
75c70
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/smi-status
40c40
< 		sql		=> "select id as id, schema_community as schema_community from smi_pending_charge where status = -1",
---
> 		sql		=> "select id, schema_community from smi_pending_charge where status = -1",
50c50
< 		sql		=> "select id as id , schema_community as schema_community from smi_pending_charge where status = 10 and next_attempt_date < (sysdate - (2/24))",
---
> 		sql		=> "select id, schema_community from smi_pending_charge where status = 10 and next_attempt_date < (sysdate - (2/24))",
40,41c40
<         	inf_field	=> "hash",
---
51,52c50
<         	inf_field => "hash",
---
57d54
<     	$queries->{influx_details} = { measurement => "smi_status" };
filename:./bin/an/supplierTracker
95d94
<     $queries_summary{'influx_details'} = { 'measurement' => "an_supplier_tracker_summary"};
103,104c102
<         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB)*/ count( * ) as stuck_more_than_500 from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processing')`,
<     };
---
>         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB)*/ count( * ) from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processing')`,
106,109c104
<     my $qm = ariba::monitor::QueryManager->newWithDetails('supplierTracker', $an->name(), $mon->service(), undef, \%queries_summary);
<     $qm->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($an));
<     ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $qm);
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     };
111d105
<     $queries_details{'influx_details'} = { 'measurement' => "an_supplier_tracker_details"};
113c107
<     $queries_details{"number of items stuck is more than 3 hours in community"}  = {
---
>     $queries{"number of items stuck is more than 3 hours in community"}  = {
119c113,114
<         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB) */ id as id,item,schema_community,status,(sysdate-status_changed)*24 as stuck_time from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processing') and (sysdate-status_changed)*24 > 3`,
---
>         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB) */ id,item,schema_community,status,(sysdate-status_changed)*24 stuck_time from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processing') and (sysdate-status_changed)*24 > 3`,
> 
92,93c92
<     my %queries_summary = ();
<     my %queries_details = ();
---
>     my %queries = ();
95d93
<     $queries_summary{'influx_details'} = { 'measurement' => "supplier_tracker_summary"};
97c95
<     $queries_summary{"number of items stuck is more than 500 in community"}  = {
---
>     $queries{"number of items stuck is more than 500 in community"}  = {
103,104c101
<         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB)*/ count( * ) as stuck_more_than_500 from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processed')`,
<         inf_field => "hash",  
---
>         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB)*/ count( * ) from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processing')`,
108,111d104
<     my $qm = ariba::monitor::QueryManager->newWithDetails('supplierTracker', $an->name(), $mon->service(), undef, \%queries_summary);
<     $qm->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($an));
<     ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $qm);
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
113,115c106
<     $queries_details{'influx_details'} = { 'measurement' => "supplier_tracker_details"};
< 
<     $queries_details{"number of items stuck is more than 3 hours in community"}  = {
---
>     $queries{"number of items stuck is more than 3 hours in community"}  = {
121,122c112,113
<         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB) */ id as id,item,schema_community,status,(sysdate-status_changed)*24 as stuck_time from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processed') and (sysdate-status_changed)*24 > 3`,
<         inf_field => "hash",  
---
>         sql => q`select /*+ INDEX(SUP_TRKR_EVLTR_QUEUE IND_21F5D32E_CF6759DB) */ id,item,schema_community,status,(sysdate-status_changed)*24 stuck_time from SUP_TRKR_EVLTR_QUEUE where status in ('Queued','Processing') and (sysdate-status_changed)*24 > 3`,
> 
125c116,118
<     $qm = ariba::monitor::QueryManager->newWithDetails('supplierTracker', $an->name(), $mon->service(), undef, \%queries_details);
---
> 
> 
>     my $qm = ariba::monitor::QueryManager->newWithDetails('supplierTracker', $an->name(), $mon->service(), undef, \%queries);
128,129c121
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
< 
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/clean-archivelogs-hana
165,168d164
<                 'inf_tags'   => "cluster=\"$cluster\"",
<                 'inf_field'  => "status",
<                 'inf_default'=> "none",
<                 'group_by'   => $cluster,
172,173d171
<         $queries{influx_details} = { measurement => 'clean_archive_logs_hana' };
< 
filename:./bin/common/aql-metrics
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
10d9
< use lib "$FindBin::Bin/../../bin";
196c195
< 	my $service = $me->service();
---
> 
273,276d271
< 				'inf_field' => "result",
< 				'inf_default' => 0,
< 				'inf_tags' =>  "aqlfile=\"$aqlBaseFile\"",
< 				'group_by' =>  "$aqlBaseFile"
307,308c302
< 		$queries{"influx_details"} = { 'measurement' => 'aql_metrics'};
---
> 		
312a307
> 
316d310
< 
filename:./bin/common/cds-health
52,281c52,236
<     my $debug = 0;
<     my $quiet = 0;
<     my $sendEmail = 0;
<     my $sendPage = 0;
<     my $productName;
< 
<     while(my $arg=shift(@ARGV)){
<             print STDERR "parsing arg $arg\n" if $debug && !$quiet;
<             if($arg =~ /^-d/o){ ++$debug; }
<             if($arg =~ /^-e/o){ $sendEmail=1; };
<             if($arg =~ /^-p$/o){ $sendPage=1; };
<             if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
<     my $email = $me->default('notify.email');
< 
<     my @products;
< 
<     my $isAspProduct = 0;
<     if (ariba::rc::Globals::isASPProduct($productName)) {
<         @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
<         $isAspProduct = 1;
< 
<     } else {
<         unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
<             exit(0);
<         }
< 
<         @products = (ariba::rc::InstalledProduct->new($productName, $service));
<         my $product = $products[0];
< 
<     }
< 
<     for my $product (@products) {
<         my $skip = 0;
< 
<         my %queries  = ();
<         my %communitiesDone;
<         my $incremental_pull_status = 0;
<         
<         for my $instance ($product->appInstancesInCluster($cluster)) {
< 
<             my $community = $instance->community();
<             if ($community) {
<                 $community = "community $community";
<             } else {
<                 $community = "default community";
<             }
< 
<             next if ($communitiesDone{$community});
<             $communitiesDone{$community} = 1;
< 
<             my ($uiHint, $communityString);
<             if ($isAspProduct) {
<                 $uiHint = undef;
<                 $communityString = "";
<             } else {
<                 $uiHint = $community;
<                 $communityString = "in $community";
<             }
< 
<             my $url = $instance->cdsActivityURL();
<             next unless $url;
< 
<             print "url = $url\n" if ($debug);
< 
<             my $cdsActivity = ariba::monitor::Url->new($url);
< 
<             my @results = $cdsActivity->request(45);
< 
<             print "\n---\n", join("", @results), "\n---\n" if ($debug > 1);
< 
<             my ($peerProductStatus, $workingRealmsRef, $errorRealmsRef, $taskErrorsRef, $error) = parseCdsActivityDetails(\@results);
< 
<             #
<             # Note the peer products health
<             #
<             $queries{"CDS peer product status $communityString"} = {
< 
<                 'info' => 1,
<                 'skip' => $skip,
<                 'warn' => "!defined(answer) || answer !~ /OK/",
<                 'error' => $error,
<                 'note' => $error,
<                 'uiHint' => $uiHint,
<                 'perl' => sub { return $peerProductStatus},
<                 'inf_field' => "peer_prod_status",
<                 'inf_default' => "none",
<                 'inf_tags' =>  qq(community="$community"),
<                 'group_by' =>  "$community"
<             };
< 
<             #
<             # working cds integrated realms
<             #
<             $queries{"CDS integrated realms with working peer connection $communityString"} = {
< 
<                 'info' => 1,
<                 'skip' => $skip,
<                 'uiHint' => $uiHint,
<                 'error' => $error,
<                 'note' => $error,
<                 'perl' => sub { return join("\n", @$workingRealmsRef); },
<                 'inf_field' => "integrated_realms_with_working_peer",
<                 'inf_default' => "none",
<                 'inf_tags' =>  "community=\"$community\"",
<                 'group_by' =>  "$community"
<             };
< 
<             $queries{"CDS integrated realms with working peer connection count $communityString"} = {
< 
<                 'info' => 1,
<                 'skip' => $skip,
<                 'uiHint' => $uiHint,
<                 'error' => $error,
<                 'note' => $error,
<                 'perl' => sub { return scalar(@$workingRealmsRef); },
<                 'inf_field' => "integrated_realms_with_working_peer_cnt",
<                 'inf_default' => 0,
<                 'inf_tags' =>  qq(community="$community"),
<                 'group_by' =>  "$community"
<             };
< 
<             #
<             # cds integrated realms that have problems
<             #
<             $queries{"CDS integrated realms with peer connection in error $communityString"} = {
< 
<                 'info' => 1,
<                 'warn' => "numrows > 1",
<                 'crit' => "numrows > 5 and previousAnswer > 5",
<                 'skip' => $skip,
<                 'uiHint' => $uiHint,
<                 'note' => $error,
<                 'perl' => sub { return join("\n", @$errorRealmsRef); },
<                 'inf_field' => "integrated_realms_with_peer_error",
<                 'inf_default' => "none",
<                 'inf_tags' =>  "community=\"$community\"",
<                 'group_by' =>  "$community"
<             };
< 
<             $queries{"CDS integrated realms with peer connection in error cnt $communityString"} = {
< 
<                 'info' => 1,
<                 'warn' => "numrows > 1",
<                 'crit' => "numrows > 5 and previousAnswer > 5",
<                 'skip' => $skip,
<                 'uiHint' => $uiHint,
<                 'note' => $error,
<                 'perl' => sub { return scalar(@$errorRealmsRef); },
<                 'inf_field' => "integrated_realms_with_peer_error_cnt",
<                 'inf_default' => 0,
<                 'inf_tags' =>  qq(community="$community"),
<                 'group_by' =>  "$community"
<             };
<             #
<             # tasks that had errors
<             $queries{"CDS tasks with errors $communityString"} = {
<                 'info' => 1,
<                 'warn' => "numrows > 0",
<                 #'ticketOnWarnOpenAfterMinutes' => 10,
<                 'error' => $error,
<                 'note' => $error,
<                 'uiHint' => $uiHint,
<                 'skip' => $skip,
<                 'perl' => sub { return join("\n", @$taskErrorsRef); },
<                 'inf_field' => "tasks_with_errors",
<                 'inf_default' => "none",
<                 'inf_tags' =>  "community=\"$community\"",
<                 'group_by' =>  "$community"
<             };
< 
<     
<             #
<             #ForMasterDataPullErrors
<             #
<             #skipping if DA is parsed already .For first time $incremental_pull_status is set as zero.Next it is set as 1
<             unless( $incremental_pull_status ) {
<                 my $pull_url = $instance->incrementalPullStatusURL();
<                 next unless $pull_url;
<                 print "url = $pull_url\n" if ($debug);
<     
<                 my $incrementalPullStatus = ariba::monitor::Url->new($pull_url);
<                 my $xml_results = $incrementalPullStatus->request(45);
<                 print "\n---\n", join("", $xml_results), "\n---\n" if ($debug > 4);
<                 my ($xml_ref) = parseIncrementalPullStatusDetails($xml_results);
<     
<                 if($xml_ref) {  
<                     
<                     print Dumper($xml_ref) if( $debug > 1);
<                     my $pull_status;
<                     foreach my $realm_id( keys( %{$xml_ref->{realm}} ) ) {
<                     
<                         my $failure_count = $xml_ref->{realm}->{$realm_id}->{'failure_count'};
<                         my $pull_error = Dumper($xml_ref->{realm}->{$realm_id}->{'message'});
<                         print "realm_id:$realm_id,failure_count:$failure_count,errors:$pull_error\n" if($debug >1);
<                     
<                         my ($pull_note,$pull_severity);
<                         if($failure_count > 20 ) {
<                             $pull_severity = 1;
<                             $pull_note = "Notify Dinesh Kumar";
<                             $pull_status .= "CRITICAL realm $realm_id: $failure_count\n";
<                         }elsif($failure_count > 10 ) {
<                             $pull_note = "Notify Dinesh Kumar, Raghavendra Rao, Namrata Sarada";#This will be replaced with team-specific DL
<                             $pull_status .= "Warning  realm $realm_id: $failure_count\n";
<                         }
<                 
<                         $queries{"Master Data Pull Error Failure Count "} = {
<                             'warn' => "answer =~/Warning/si",
<                             'crit' => "answer =~/Critical/si",
<                             'url'  => $pull_url,
<                             'correctiveActions' => "$pull_note",
<                             'severity' => $pull_severity,
<                             'perl' => sub { return "$pull_status"; },
<                             inf_field => "master_data_pull_error_cnt",
<                             inf_default  => 0,
<                         };
<                     }
<                 }
<                 $incremental_pull_status = 1;
<             }
<         }
< 
<             $queries{"influx_details"} = { 'measurement' => "cds_health"  };
<         my $q = ariba::monitor::QueryManager->newWithDetails( "cds-health", $product->name(), $service, $product->customer(), \%queries);
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
<     }
---
> 	my $debug = 0;
> 	my $quiet = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while(my $arg=shift(@ARGV)){
> 			print STDERR "parsing arg $arg\n" if $debug && !$quiet;
> 			if($arg =~ /^-d/o){ ++$debug; }
> 			if($arg =~ /^-e/o){ $sendEmail=1; };
> 			if($arg =~ /^-p$/o){ $sendPage=1; };
> 			if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 	my $email = $me->default('notify.email');
> 
> 	my @products;
> 
> 	my $isAspProduct = 0;
> 	if (ariba::rc::Globals::isASPProduct($productName)) {
> 		@products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
> 		$isAspProduct = 1;
> 
> 	} else {
> 		unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
> 			exit(0);
> 		}
> 
> 		@products = (ariba::rc::InstalledProduct->new($productName, $service));
> 		my $product = $products[0];
> 
> 	}
> 
> 	for my $product (@products) {
> 		my $skip = 0;
> 
> 		my %queries  = ();
> 		my %communitiesDone;
> 		my $incremental_pull_status = 0;
> 		
> 		for my $instance ($product->appInstancesInCluster($cluster)) {
> 
> 			my $community = $instance->community();
> 			if ($community) {
> 				$community = "community $community";
> 			} else {
> 				$community = "default community";
> 			}
> 
> 			next if ($communitiesDone{$community});
> 			$communitiesDone{$community} = 1;
> 
> 			my ($uiHint, $communityString);
> 			if ($isAspProduct) {
> 				$uiHint = undef;
> 				$communityString = "";
> 			} else {
> 				$uiHint = $community;
> 				$communityString = "in $community";
> 			}
> 
> 			my $url = $instance->cdsActivityURL();
> 			next unless $url;
> 
> 			print "url = $url\n" if ($debug);
> 
> 			my $cdsActivity = ariba::monitor::Url->new($url);
> 
> 			my @results = $cdsActivity->request(45);
> 
> 			print "\n---\n", join("", @results), "\n---\n" if ($debug > 1);
> 
> 			my ($peerProductStatus, $workingRealmsRef, $errorRealmsRef, $taskErrorsRef, $error) = parseCdsActivityDetails(\@results);
> 
> 			#
> 			# Note the peer products health
> 			#
> 			$queries{"CDS peer product status $communityString"} = {
> 
> 				'info' => 1,
> 				'skip' => $skip,
> 				'warn' => "!defined(answer) || answer !~ /OK/",
> 				'error' => $error,
> 				'note' => $error,
> 				'uiHint' => $uiHint,
> 				'perl' => sub { return $peerProductStatus},
> 			};
> 
> 			#
> 			# working cds integrated realms
> 			#
> 			$queries{"CDS integrated realms with working peer connection $communityString"} = {
> 
> 				'info' => 1,
> 				'skip' => $skip,
> 				'uiHint' => $uiHint,
> 				'error' => $error,
> 				'note' => $error,
> 				'perl' => sub { return join("\n", @$workingRealmsRef); },
> 			};
> 
> 			#
> 			# cds integrated realms that have problems
> 			#
> 			$queries{"CDS integrated realms with peer connection in error $communityString"} = {
> 
> 				'info' => 1,
> 				'warn' => "numrows > 1",
> 				'crit' => "numrows > 5 and previousAnswer > 5",
> 				'skip' => $skip,
> 				'uiHint' => $uiHint,
> 				'note' => $error,
> 				'perl' => sub { return join("\n", @$errorRealmsRef); },
> 			};
> 			#
> 			# tasks that had errors
> 			$queries{"CDS tasks with errors $communityString"} = {
> 				'info' => 1,
> 				'warn' => "numrows > 0",
> 				#'ticketOnWarnOpenAfterMinutes' => 10,
> 				'error' => $error,
> 				'note' => $error,
> 				'uiHint' => $uiHint,
> 				'skip' => $skip,
> 				'perl' => sub { return join("\n", @$taskErrorsRef); },
> 			};
> 
> 	
> 			#
> 			#ForMasterDataPullErrors
> 			#
> 			#skipping if DA is parsed already .For first time $incremental_pull_status is set as zero.Next it is set as 1
> 			unless( $incremental_pull_status ) {
> 				my $pull_url = $instance->incrementalPullStatusURL();
> 				next unless $pull_url;
> 				print "url = $pull_url\n" if ($debug);
> 	
> 				my $incrementalPullStatus = ariba::monitor::Url->new($pull_url);
> 				my $xml_results = $incrementalPullStatus->request(45);
> 				print "\n---\n", join("", $xml_results), "\n---\n" if ($debug > 4);
> 				my ($xml_ref) = parseIncrementalPullStatusDetails($xml_results);
> 	
> 				if($xml_ref) {	
> 					
> 					print Dumper($xml_ref) if( $debug > 1);
> 					my $pull_status;
> 					foreach my $realm_id( keys( %{$xml_ref->{realm}} ) ) {
> 					
> 						my $failure_count = $xml_ref->{realm}->{$realm_id}->{'failure_count'};
> 						my $pull_error = Dumper($xml_ref->{realm}->{$realm_id}->{'message'});
> 						print "realm_id:$realm_id,failure_count:$failure_count,errors:$pull_error\n" if($debug >1);
> 					
> 						my ($pull_note,$pull_severity);
> 						if($failure_count > 20 ) {
> 							$pull_severity = 1;
> 							$pull_note = "Notify Dinesh Kumar";
> 							$pull_status .= "CRITICAL realm $realm_id: $failure_count\n";
> 						}elsif($failure_count > 10 ) {
> 							$pull_note = "Notify Dinesh Kumar, Raghavendra Rao, Namrata Sarada";#This will be replaced with team-specific DL
> 							$pull_status .= "Warning  realm $realm_id: $failure_count\n";
> 						}
> 				
> 						$queries{"Master Data Pull Error Failure Count "} = {
> 							'warn' => "answer =~/Warning/si",
> 							'crit' => "answer =~/Critical/si",
> 							'url'  => $pull_url,
> 							'correctiveActions' => "$pull_note",
> 							'severity' => $pull_severity,
> 							'perl' => sub { return "$pull_status"; },
> 						};
> 					}
> 				}
> 				$incremental_pull_status = 1;
> 			}
> 		}
> 
> 
> 		my $q = ariba::monitor::QueryManager->newWithDetails(
> 				"cds-health", $product->name(), $service, $product->customer(), \%queries
> 				);
> 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
> 	}
369,384c324,387
<     my $results = shift;
<     my @output;
<     my $peerProductStatus = "OK";
<     my @workingRealms = ();
<     my @errorRealms = ();
<     my @taskErrors = ();
<     my %taskErrorsForRealm = ();
< 
<     my $error = undef;
< 
<     if (!@$results || $results->[0] !~ m!^<\?xml version="[^"]+"\?>!i) {
<         $error = "Error: cds direct action failed\n" . join("", @$results) . "\n";
<         $peerProductStatus = "Uknown";
<     }
<     
<     while (my $line = shift(@$results) ) {
---
> 	my $results = shift;
> 	my @output;
> 	my $peerProductStatus = "OK";
> 	my @workingRealms = ();
> 	my @errorRealms = ();
> 	my @taskErrors = ();
> 	my %taskErrorsForRealm = ();
> 
> 	my $error = undef;
> 
> 	if (!@$results || $results->[0] !~ m!^<\?xml version="[^"]+"\?>!i) {
> 		$error = "Error: cds direct action failed\n" . join("", @$results) . "\n";
> 		$peerProductStatus = "Uknown";
> 	}
> 	
> 	while (my $line = shift(@$results) ) {
> 
> 		my $realmName = "";
> 
> 		if ($line =~ m|^<Realms>(.*)</Realms>|i) {
> 			$peerProductStatus = "Error: $1";
> 			next;
> 		}
> 		if ($line =~ m!(Cannot connect to Peer Service)\s*<\s*/Realms\s*>!) {
> 			$peerProductStatus = "Error: $1";
> 			next;
> 		}
> 		if ($line =~ m!<Realm\s+name="\s*([^"]*)\s*"\s*Status="\s*([^"]*)\s*"\s*/?>!i) {
> 			$realmName = $1;
> 			my $status = $2;
> 
> 			#
> 			# peer connected realms are code, all others are in
> 			# error
> 			#
> 			if ($status =~ m!peer connected!i) {
> 				push(@workingRealms, $realmName);
> 			} else {
> 				push(@errorRealms, "$realmName: $status");
> 			}
> 			next;
> 		}
> 
> 		if ($line =~ m!<Task\s+name="([^"]*)"\s*>!i) {
> 			my $taskName = $1;
> 			my $taskError = "$realmName $taskName ";
> 			while ($line = shift (@$results)) {
> 
> 			if ($line =~ m!</(\S+)\s*>!) {
> 					if ($1 =~ /Task/) {
> 						push(@taskErrors, $taskError);
> 						last;
> 					} else {
> 						next;
> 					}
> 				}
> 
> 				my ($name, $param, $value) = $line =~ m!<(\S+)\s+(\S+)\s*=\s*"([^"]+)"\s*/?>!i;
> 				next unless ($name and $param);
> 				$taskError .= " $name=$value";
> 				$taskErrorsForRealm{$realmName} = $taskError;
> 			}
> 		}
> 	}
386,434c389
<         my $realmName = "";
< 
<         if ($line =~ m|^<Realms>(.*)</Realms>|i) {
<             $peerProductStatus = "Error: $1";
<             next;
<         }
<         if ($line =~ m!(Cannot connect to Peer Service)\s*<\s*/Realms\s*>!) {
<             $peerProductStatus = "Error: $1";
<             next;
<         }
<         if ($line =~ m!<Realm\s+name="\s*([^"]*)\s*"\s*Status="\s*([^"]*)\s*"\s*/?>!i) {
<             $realmName = $1;
<             my $status = $2;
< 
<             #
<             # peer connected realms are code, all others are in
<             # error
<             #
<             if ($status =~ m!peer connected!i) {
<                 push(@workingRealms, $realmName);
<             } else {
<                 push(@errorRealms, "$realmName: $status");
<             }
<             next;
<         }
< 
<         if ($line =~ m!<Task\s+name="([^"]*)"\s*>!i) {
<             my $taskName = $1;
<             my $taskError = "$realmName $taskName ";
<             while ($line = shift (@$results)) {
< 
<             if ($line =~ m!</(\S+)\s*>!) {
<                     if ($1 =~ /Task/) {
<                         push(@taskErrors, $taskError);
<                         last;
<                     } else {
<                         next;
<                     }
<                 }
< 
<                 my ($name, $param, $value) = $line =~ m!<(\S+)\s+(\S+)\s*=\s*"([^"]+)"\s*/?>!i;
<                 next unless ($name and $param);
<                 $taskError .= " $name=$value";
<                 $taskErrorsForRealm{$realmName} = $taskError;
<             }
<         }
<     }
< 
<     return ($peerProductStatus, \@workingRealms, \@errorRealms, \@taskErrors, $error);
---
> 	return ($peerProductStatus, \@workingRealms, \@errorRealms, \@taskErrors, $error);
456d410
< 
141,144d140
< 				'inf_field' => "peer_prod_status",
< 				'inf_default' => "none",
< 				'inf_tags' =>  "community=\"$community\"",
< 				'group_by' =>  "$community"
158,161d153
< 				'inf_field' => "integrated_realms_with_working_peer",
< 				'inf_default' => "none",
< 				'inf_tags' =>  "community=\"$community\"",
< 				'group_by' =>  "$community"
176,179d167
< 				'inf_field' => "integrated_realms_with_peer_error",
< 				'inf_default' => "none",
< 				'inf_tags' =>  "community=\"$community\"",
< 				'group_by' =>  "$community"
192,195d179
< 				'inf_field' => "tasks_with_errors",
< 				'inf_default' => "none",
< 				'inf_tags' =>  "community=\"$community\"",
< 				'group_by' =>  "$community"
247c231
< 	        $queries{"influx_details"} = { 'measurement' => "cds_health"  };
---
> 
filename:./bin/common/client-cert-expire
3c3
< # $Id: //ariba/services/monitor/bin/common/client-cert-expire#33 $
---
> # $Id: //ariba/services/monitor/bin/common/client-cert-expire#35 $
18c18
< 	my $sendEmail = 0;
---
>         my $sendEmail = 0;
21,60c21,60
< 	while (my $arg = shift(@ARGV)) {
< 		if( $arg =~ /^-e/o ){ $sendEmail = 1; };
< 		if( $arg =~ /^-p/o ){ $sendPage = 1; };
< 		if( $arg =~ /^-d/o ){ $debug = 1; };
< 	}
< 
< 	my $cert	  = ariba::Crypto::Certificate->new();
< 
< 	my $me		  = ariba::rc::InstalledProduct->new();
< 	my @products	  = ariba::rc::InstalledProduct->installedProductsList( $me->service() );
< 	my $cluster	  = $me->currentCluster();
< 	my $email     = $me->default('notify.email');
< 
< 	my $hostname	  = ariba::Ops::NetworkUtils::hostname();
< 	my $shortHostname = ariba::Ops::NetworkUtils::fqdnToShortHostname( $hostname );
< 
< 	my $path = "//ariba/services/operations/documentation/prodops/common/certificate_management.shtml";
< 
< 	# Find out what we run
< 	for my $product (@products) {
< 
< 		my $name     = $product->name();
< 		my $service  = $product->service();
< 		my $customer = $product->customer();
< 		my $install  = $product->installDir();
< 		my %queries  = ();
< 
< 		#
< 		# products can have 0, 1, or 2 identity certs
< 		# 
< 
< 		for my $keyPathFile ( 
< 			'outboundhttps.identitykeystore.file',	#AN uses a different path than the rest of the products.
< 			'outboundhttps.ediidentitykeystore.file',	#EDI in AN
< 			'cert.clientcert.path',	# the standard location
< 			'edi.communication.cert.path', #EDI also has this
< 			'esigclient.identitykeystore.file',
< 			'System.Authentication.Keystores.AribaPrivateKeystore.File',
< 			'System.Authentication.Keystores.AppleProductionKeystore.File',
< 		) {
---
>         while (my $arg = shift(@ARGV)) {
>                 if( $arg =~ /^-e/o ){ $sendEmail = 1; };
>                 if( $arg =~ /^-p/o ){ $sendPage = 1; };
>                 if( $arg =~ /^-d/o ){ $debug = 1; };
>         }
> 
>         my $cert          = ariba::Crypto::Certificate->new();
> 
>         my $me            = ariba::rc::InstalledProduct->new();
>         my @products      = ariba::rc::InstalledProduct->installedProductsList( $me->service() );
>         my $cluster       = $me->currentCluster();
>         my $email     = $me->default('notify.email');
> 
>         my $hostname      = ariba::Ops::NetworkUtils::hostname();
>         my $shortHostname = ariba::Ops::NetworkUtils::fqdnToShortHostname( $hostname );
> 
>         my $path = "//ariba/services/operations/documentation/prodops/common/certificate_management.shtml";
> 
>         # Find out what we run
>         for my $product (@products) {
> 
>                 my $name     = $product->name();
>                 my $service  = $product->service();
>                 my $customer = $product->customer();
>                 my $install  = $product->installDir();
>                 my %queries  = ();
> 
>                 #
>                 # products can have 0, 1, or 2 identity certs
>                 # 
> 
>                 for my $keyPathFile ( 
>                         'outboundhttps.identitykeystore.file',  #AN uses a different path than the rest of the products.
>                         'outboundhttps.ediidentitykeystore.file',       #EDI in AN
>                         'cert.clientcert.path', # the standard location
>                         'edi.communication.cert.path', #EDI also has this
>                         'esigclient.identitykeystore.file',
>                         'System.Authentication.Keystores.AribaPrivateKeystore.File',
>                         'System.Authentication.Keystores.AppleProductionKeystore.File',
>                 ) {
62,63c62,63
< 			my $password = '';
< 			my $pkcs12   = '';
---
>                         my $password = '';
>                         my $pkcs12   = '';
68,69c68,69
< 			if ($product->default($keyPathFile)) {
< 				print "Processing client certs $keyPathFile for ", $product->name(), "\n" if $debug;
---
>                         if ($product->default($keyPathFile)) {
>                                 print "Processing client certs $keyPathFile for ", $product->name(), "\n" if $debug;
71,72c71,72
< 				my $keyPathPassword = $keyPathFile;
< 				$keyPathPassword =~ s/\.[^.]+$//;
---
>                                 my $keyPathPassword = $keyPathFile;
>                                 $keyPathPassword =~ s/\.[^.]+$//;
74,122c74,118
< 				if ($keyPathFile =~ /System.Authentication.Keystores/ ) {
< 					$keyPathPassword .= '.StorePassword';
< 				} else {
< 					$keyPathPassword .= '.password';
< 				}
< 
< 				$password = $product->default($keyPathPassword);
< 
< 				my @pathToClientCert = ($install);
< 				push (@pathToClientCert, 'base') if $product->customer();
< 				push (@pathToClientCert, $product->default($keyPathFile));
< 				$pkcs12 = join('/', @pathToClientCert);
< 
< 			} else {
< 				next;
< 			}
< 
< 			next unless -f $pkcs12;
< 
< 			my $displayName = $pkcs12;
< 			   $displayName =~ s/$install\///;
< 
< 			my $days = $cert->daysToCertExpireTimeForPKCS12($pkcs12, $password);
< 
< 			$queries{"Days to Expire for pkcs12 $displayName"} = {
< 				noRowCount => 1,
< 				format => "%d days\n",
< 				info => "answer >= 20",
< 				warn => "answer < 90",
< 				crit => "answer < 60",
< 				perl => "return $days",
< 				ticketOnWarnOpenAfterMinutes => 30,
< 				openTicketInServices => "prod,sales",
< 				description   => "For initial debugging refer to $path",
<                 'inf_field'   => "days_to_expire",
<                 'inf_tags'    =>  "cert=\"$displayName\"",
<                 'inf_default' => 0,
<                 'group_by'    => $displayName
< 			};
< 
< 		}
< 
< 		# skip, if there are not client certs for this product.
< 		next unless(scalar(keys(%queries)));
< 
<         $queries{"influx_details"} = { 'measurement' => "client_cert_expire" };
< 		my $q = ariba::monitor::QueryManager->newWithDetails("client-cert-expire", $name, $service, $customer, \%queries);
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
< 	}
---
>                                 if ($keyPathFile =~ /System.Authentication.Keystores/ ) {
>                                         $keyPathPassword .= '.StorePassword';
>                                 } else {
>                                         $keyPathPassword .= '.password';
>                                 }
> 
>                                 $password = $product->default($keyPathPassword);
> 
>                                 my @pathToClientCert = ($install);
>                                 push (@pathToClientCert, 'base') if $product->customer();
>                                 push (@pathToClientCert, $product->default($keyPathFile));
>                                 $pkcs12 = join('/', @pathToClientCert);
> 
>                         } else {
>                                 next;
>                         }
> 
>                         next unless -f $pkcs12;
> 
>                         my $displayName = $pkcs12;
>                            $displayName =~ s/$install\///;
> 
>                         my $days = $cert->daysToCertExpireTimeForPKCS12($pkcs12, $password);
> 
>                         $queries{"Days to Expire for pkcs12 $displayName"} = {
>                                 noRowCount => 1,
>                                 format => "%d days\n",
>                                 info => "answer >= 20",
>                                 warn => "answer < 90",
>                                 crit => "answer < 60",
>                                 perl => "return $days",
>                                 ticketOnWarnOpenAfterMinutes => 30,
>                                 openTicketInServices => "prod,sales",
>                                 description => "For initial debugging refer to $path",
> 
>                         };
> 
>                 }
> 
>                 # skip, if there are not client certs for this product.
>                 next unless(scalar(keys(%queries)));
> 
>                 my $q = ariba::monitor::QueryManager->newWithDetails("client-cert-expire", $name, $service, $customer, \%queries);
>                 $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
>         }
107,111c107,108
< 				description   => "For initial debugging refer to $path",
<                 'inf_field'   => "days_to_expire",
<                 'inf_tags'    =>  "cert=\"$displayName\"",
<                 'inf_default' => 0,
<                 'group_by'    => $displayName
---
> 				description => "For initial debugging refer to $path",
> 
119d115
<         $queries{"influx_details"} = { 'measurement' => "client_cert_expire" };
121c117
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/current-activity
46c46
<         my $lockfile = "/tmp/stratus-current-activity";
---
>         my $lockfile = "/tmp/current-activity";
63d62
<         my %totqueries  = ();
85,87d83
<             my $community = $instance->community();
< 	    $community = ( $community ) ? "community $community" : "default community";
< 
186,189d181
< 		    'inf_field' => "internode_communication_size_metric",
< 		    'inf_default' => 0,
< 		    'inf_tags' =>  "community=\"$community\",node=\"$instanceName\"",
< 		    'group_by' =>  "$instanceName"
202,205d193
< 		    'inf_field' => "internode_communication_size_queue",
< 		    'inf_default' => 0,
< 		    'inf_tags' =>  "community=\"$community\",node=\"$instanceName\"",
< 		    'group_by' =>  "$instanceName"
240,243d227
< 		'inf_field' => "number_of_threads",
< 		'inf_default' => 0,
< 		'inf_tags' =>  "community=\"$community\",node=\"$instanceName\"",
< 		'group_by' =>  "$instanceName"
284,287d267
< 		    'inf_field' => "number_of_active_sessions",
< 		    'inf_default' => 0,
< 		    'inf_tags' =>  "community=\"$thisCommunity\",node=\"$instanceName\"",
< 		    'group_by' =>  "$instanceName"
331c311
<         $totqueries{"Total number of active sessions"} = {
---
>         $queries{"Total number of active sessions"} = {
342,343d321
< 	    'inf_field' => "total_active_sessions",
< 	    'inf_default' => 0,
346c324
<         $totqueries{"Total number of realms (prod) with active sessions"} = {
---
>         $queries{"Total number of realms (prod) with active sessions"} = {
354,355d331
< 	    'inf_field' => "prod_realms_with_active_sessions",
< 	    'inf_default' => 0,
358c334
<         $totqueries{"Total number of realms (test) with active sessions"} = {
---
>         $queries{"Total number of realms (test) with active sessions"} = {
366,368d341
< 	    'inf_field' => "test_realms_with_active_sessions",
< 	    'inf_default' => 0,
< 
371c344
<         $totqueries{"Total workspace email count"} = {
---
>         $queries{"Total workspace email count"} = {
379,380d351
< 	    'inf_field' => "total_workspace_email_count",
< 	    'inf_default' => 0,
383c354
<         $totqueries{"Total workspace email size"} = {
---
>         $queries{"Total workspace email size"} = {
392,393d362
< 	    'inf_field' => "total_workspace_email_size",
< 	    'inf_default' => 0,
410,413d378
< 	        'inf_field' => "active_sessions",
< 	    	'inf_default' => 0,
< 	        'inf_tags' =>  "community=\"$key\"",
< 	        'group_by' =>  "$key"
417,418d381
<        $queries{"influx_details"} = { 'measurement' => "current_activity"};
< 
423,435c386
<        $q->processQueries($debug, $email, $sendEmail, $sendPage);
<        $totqueries{"influx_details"} = { 'measurement' => "current_activity_total" };
< 
<        my $totq = ariba::monitor::QueryManager->newWithDetails(
<                 "current-activity", $product->name(), $service, $product->customer(), \%totqueries
<                 );
<        $totq->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<        $sessionsPerCommunityQueries{"influx_details"} = { 'measurement' => "session_per_community" };
<         my $scq = ariba::monitor::QueryManager->newWithDetails(
<                 "current-activity", $product->name(), $service, $product->customer(), \%sessionsPerCommunityQueries
<                 );
<         $scq->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/dr-product-status
94d93
<         $queries{influx_details} = { measurement => "dr_deployment_status" };
100,101d98
<             inf_field   => "state",
< 	    inf_default => "none",
filename:./bin/common/encryption-length-hwm-stats
67c67
<         'sql'           => "select realm as realm_name,clusterroot as cluster_root,fieldname as field_name,sum(overflowcount) as overflow_count
---
>         'sql'           => "select realm,clusterroot,fieldname,sum(overflowcount)
69d68
<         inf_field       => "hash"
73d71
<     $queries{influx_details} = { measurement => 'encr_len_stats' };
87c85
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/http-watcher
1c1
< #!/usr/local/tools/perl-5.22.1/bin/perl
---
> #!/usr/local/tools/perl-5.22.1/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/common/http-watcher#93 $
---
> # $Id: //ariba/services/monitor/bin/common/http-watcher#95 $
32d31
< use Data::Dumper;
42,43c41,42
< my $TRACEFILE_BASE = "/tmp/stratus-current-http-watcher-url";
< my $traceFile      = $TRACEFILE_BASE;
---
> my $TRACEFILE_BASE = "/tmp/current-http-watcher-url";
> my $traceFile = $TRACEFILE_BASE;
48c47
< my $programStartTime = scalar (localtime (time ()));
---
> my $programStartTime = scalar(localtime(time()));
50,51c49
< sub usage
< {
---
> sub usage {
53c51
<     print "usage: $0 [-d|-h] -t <critical|normal> -prodName <productName> -c <clusterName> [<url files>...]\n";
---
>     print "usage: $0 [-d|-h] -t <critical|normal> -c <clusterName> [<url files>...]\n";
64c62
<     exit (1);
---
>     exit(1);
67,68c65
< sub trace
< {
---
> sub trace {
73c70
<     open (TRACE, ">> $traceFile") || die "can't open $traceFile: $!";
---
>     open (TRACE, "> $traceFile") || die "can't open $traceFile: $!";
75,76c72,73
<     print TRACE "since ", scalar (localtime (time)), " (pid = $$)\n";
<     close (TRACE);
---
>     print TRACE "since ", scalar(localtime(time))," (pid = $$)\n";
>     close(TRACE);
79,82c76,77
< sub removeTrace
< {
<     unlink ($traceFile) || warn "can't remove $traceFile: $!"  if ( -e $traceFile );
< 
---
> sub removeTrace {
>     unlink($traceFile) || warn "can't remove $traceFile: $!";
85,89c80,83
< sub currentTrace
< {
<     open (TRACE, $traceFile) || warn "can't read traceFile $traceFile: $!";
<     my $text = join ("", <TRACE>);
<     close (TRACE);
---
> sub currentTrace {
>     open(TRACE, $traceFile) || warn "can't read traceFile $traceFile: $!";
>     my $text = join("", <TRACE>);
>     close(TRACE);
94,95c88
< sub main
< {
---
> sub main {
98,99c91,92
<     my @urlFiles                = ();
<     my %queriesForProducts      = ();
---
>     my @urlFiles = ();
>     my %queriesForProducts = ();
103d95
<     my $product_name;
106,113c98,103
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-h/o) {usage();}
<         if ($arg =~ /^-d/o) {$debug = 1; next;}
<         if ($arg =~ /^-t/o) {$type = shift (@ARGV); next;}
<         if ($arg =~ /^-c/o) {$cluster = shift (@ARGV); next;}
<         if ($arg !~ /^-/o) {push (@urlFiles, $arg); next;}
<         if ($arg =~ /^-p/o) {$product_name = shift (@ARGV); next;}
---
>     while (my $arg = shift(@ARGV)) {
>         if ($arg =~ /^-h/o) { usage();}
>         if ($arg =~ /^-d/o) { $debug = 1; next;}
>         if ($arg =~ /^-t/o) { $type = shift(@ARGV); next; }
>         if ($arg =~ /^-c/o) { $cluster = shift(@ARGV); next; }
>         if ($arg !~ /^-/o) { push(@urlFiles, $arg); next;}
116,120c106,107
<     exit (1) unless ($product_name);
< 
<     unless (@urlFiles)
<     {
<         push (@urlFiles, $defaultUrlFile);
---
>     unless(@urlFiles) {
>         push(@urlFiles, $defaultUrlFile);
130,131c117
<     for my $URLFILE (@urlFiles)
<     {
---
>     for my $URLFILE (@urlFiles) {
137c123
<     my $urlsRef = evalURLsAndLoadIncludes($me, \%includes, $type, $cluster, $product_name);
---
>     my $urlsRef = evalURLsAndLoadIncludes($me, \%includes, $type, $cluster);
141c127
<     my $LOCKFILE_BASE = "/tmp/http-watcher-stratus";
---
>     my $LOCKFILE_BASE  = "/tmp/http-watcher";
144,145c130,137
<     for my $productName (sort keys %$urlsRef)
<     {
---
>     for my $productName (sort keys %$urlsRef) {
> 
>         $processCount++;
>         sleep(1) if ($processCount % 5 == 0); # Slow down forking to 5 processes per second
> 
>         my $pid = fork();
>         next if ($pid); # If successful fork, parent goes to next product, child checks urls.
> 
148,149c140,141
<         my $lockFile = $LOCKFILE_BASE . "-$productName";
<         $lockFile .= "-$type" if ($type);
---
>         my $lockFile  = $LOCKFILE_BASE  . "-$productName";
>         $lockFile .= "-$type" if($type);
152c144
<         $traceFile .= "-$type" if ($type);
---
>         $traceFile .= "-$type" if($type);
154,156c146,148
<         if (-f $traceFile)
<         {
<             print STDERR "Another http-watcher running?  It looks like it is doing: " . currentTrace() . "\n";
---
>         if ( -f $traceFile ) {
>             print STDERR "Another http-watcher running?  It looks like it is doing: " .
>                 currentTrace() . "\n";
159,160c151
<         if (!dmail::LockLib::requestlock($lockFile, 5))
<         {
---
>         if (!dmail::LockLib::requestlock($lockFile,5)) {
165,166c156
<         for my $url (@{$urlsRef->{$productName}})
<         {
---
>         for my $url (@{$urlsRef->{$productName}}) {
171,174c161,163
<             my $urlName = $url->instance();
<             if (   $urlName =~ /phttpconnect\.quadrem\.net:4443\/invoke\/quadrem\/cxml_srm/
<                 || $urlName =~ /externalSite=true/)
<             {
---
>             my $urlName     = $url->instance();
>             if ($urlName =~ /phttpconnect\.quadrem\.net:4443\/invoke\/quadrem\/cxml_srm/ ||
>                 $urlName =~ /externalSite=true/) {
180,181c169,170
<             my $appName     = $url->applicationName() || "none";
<             my $displayName = $url->displayName() || $url->instanceName();
---
>             my $appName     = $url->applicationName();
>             my $displayName = $url->displayName();
205,208c194,195
<             for my $prod (@fakeANProductName)
<             {
<                 if ($productName && $productName eq $prod)
<                 {
---
>             for my $prod ( @fakeANProductName ) {
>                 if ($productName && $productName eq $prod ) {
212a200
> 
214,215c202
<             unless (defined $url->recordStatus())
<             {
---
>             unless (defined $url->recordStatus()) {
220,222d206
<             my $adminurl  = $url->adminURL() || 'none';
<             my $inspector = $url->inspectorURL() || 'none';
<             my $logurl    = $url->logURL() || 'none';
224,225c208,210
<             if ($appName)
<             {
---
>             if ($appName) {
> 
>                 if ($community) {
227,228d211
<                 if ($community)
<                 {
230,232c213,215
<                 }
<                 elsif (!$customer)
<                 {
---
> 
>                 } elsif (!$customer) {
> 
239,245c222,225
<                 if ($customer)
<                 {
<                     $format = "<html></td><td>%s since statusChangeTime queryError</html>\n",;
<                 }
<                 else
<                 {
<                     $format = "%s since statusChangeTime queryError\n";
---
>                 if ($customer) {
>                     $format = "<html></td><td>%s since statusChangeTime queryError</html>\n",
>                 } else {
>                     $format  = "%s since statusChangeTime queryError\n";
248,252c228,231
<             }
<             else
<             {
<                 if ($community)
<                 {
---
>             } else {
> 
>                 if ($community) {
> 
255,257c234,235
<                 }
<                 elsif (!$customer)
<                 {
---
>                 } elsif (!$customer) {
> 
261c239
<                 $format = "<html></td><td>%s since statusChangeTime queryError</html>\n",;
---
>                 $format = "<html></td><td>%s since statusChangeTime queryError</html>\n",
266,269c244
<             $urlName =~ s/(=)/\$1/g;
< 
<             unless ($url->checkSSLCertOnly())
<             {
---
>             unless ($url->checkSSLCertOnly()) {
272,278c247,249
<                 if (
<                        $community
<                     && $queryName !~ /,/
<                     && ($productName eq "an"
<                         || (grep /^$productName$/, (ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts())))
<                    )
<                 {
---
>                 if ($community && $queryName !~ /,/ && ($productName eq "an" ||
>                     (grep /^$productName$/, (ariba::rc::Globals::sharedServiceSourcingProducts(),
>                                  ariba::rc::Globals::sharedServiceBuyerProducts())))) {
282,298c253,264
<                 my $sdbCrit;
<                 if ($productName eq 'sdb')
<                 {
<                     #HOA-59527,Connection to Soap Query: should not go to crit when sdb load is running
<                     my $q      = ariba::monitor::Query->new('sdb/D_B_Load_Status');
<                     my $D_B_st = $q->results();
<                     if ($D_B_st ne 'Running')
<                     {
<                         $sdbCrit = "answer eq 'down' && previousAnswer eq 'down'";
<                     }
<                 }
<                 else
<                 {
<                     $sdbCrit = "answer eq 'down'";
<                 }
<                 $community = "Default Community" if (!$community);
<                 $displayName =~ s/,\s*/-/g;
---
>         my $sdbCrit;
>         if ( $productName eq 'sdb'){
>                         #HOA-59527,Connection to Soap Query: should not go to crit when sdb load is running
>                         my $q = ariba::monitor::Query->new('sdb/D_B_Load_Status');
>                         my $D_B_st = $q->results();
>                         if($D_B_st ne 'Running') {
>                       $sdbCrit = "answer eq 'down' && previousAnswer eq 'down'";
>                         }
>         }else {
>             $sdbCrit = "answer eq 'down'";
>         }
> 
300,321c266,283
<                                 noRowCount       => 1,
<                                 format           => $format,
<                                 useFormatOnError => 1,
<                                 info             => "answer eq 'up'",
<                                 warn             => "answer eq 'sick'",
<                                 crit             => $sdbCrit,
<                                 severity         => $severity,
<                                 staleInterval    => 600,    # don't go stale for 10 minutes
<                                 perl             => sub {main::checkURL($url)},
<                                 url              => $urlName,
<                                 logURL           => $url->logURL() || "",
<                                 adminURL         => $url->adminURL() || "",
<                                 timeout          => -1,
<                                 uiHint           => $uiHint,
<                                 inspectorURL     => $url->inspectorURL() || "",
<                                 processAnswer    => sub {main::processURLAnswer()},
<                                 note             => "For initial debugging refer to $path",
<                                 inf_field        => "status",
<                                 inf_default      => 0,
<                                 inf_tags         => qq(urlname="$urlName",appname="$appName",community="$community",node="$displayName",adminurl="$adminurl",inspector="$inspector",logurl="$logurl"),
<                                 group_by         => "$displayName,$appName"
<                };
---
>                     noRowCount => 1,
>                     format     => $format,
>                     useFormatOnError => 1,
>                     info       => "answer eq 'up'",
>                     warn       => "answer eq 'sick'",
>                     crit       => $sdbCrit,
>                     severity   => $severity,
>                     staleInterval => 600,   # don't go stale for 10 minutes
>                     perl       => sub { main::checkURL($url) },
>                     url        => $urlName,
>                     logURL     => $url->logURL()  || "",
>                     adminURL   => $url->adminURL()  || "",
>                     timeout    => -1,
>                     uiHint     => $uiHint,
>                     inspectorURL  => $url->inspectorURL() || "",
>                     processAnswer => sub { main::processURLAnswer() },
>                     note       => "For initial debugging refer to $path",
>                 };
326,329c288,289
<                 if ($url->suiteIntegrated())
<                 {
<                     for my $suiteProductName ($url->suiteProductNames())
<                     {
---
>                 if ($url->suiteIntegrated()) {
>                     for my $suiteProductName ($url->suiteProductNames()) {
331,349c291,305
<                                      noRowCount       => 1,
<                                      format           => $format,
<                                      useFormatOnError => 1,
<                                      info             => "answer eq 'up'",
<                                      warn             => "answer eq 'sick'",
<                                      crit             => "answer eq 'down'",
<                                      severity         => $severity,
<                                      staleInterval    => 600,                                                                      # don't go stale for 10 minutes
<                                      perl             => sub {main::checkSuiteComponent($productName, $customer, $displayName)},
<                                      url              => $urlName,
<                                      timeout          => -1,
<                                      uiHint           => $uiHint,
<                                      note             => "For initial debugging refer to $path",
<                                      inf_field        => "status",
<                                      inf_default      => 0,
<                                      inf_tags         => qq(urlname="$urlName",appname="$appName",node="$displayName"),
<                                      group_by         => "$displayName,$appName",
<                          };
< 
---
>                             noRowCount => 1,
>                             format     => $format,
>                             useFormatOnError => 1,
>                             info       => "answer eq 'up'",
>                             warn       => "answer eq 'sick'",
>                             crit       => "answer eq 'down'",
>                             severity   => $severity,
>                             staleInterval => 600,   # don't go stale for 10 minutes
>                             perl       => sub { main::checkSuiteComponent($productName, $customer, $displayName) },
>                             url        => $urlName,
>                             timeout    => -1,
>                             uiHint     => $uiHint,
>                             note       => "For initial debugging refer to $path",
>                         };
>                     }
354,355c310,335
<             next if (!$url->isHTTPS() || (defined $url->skipSSLCheck() && $url->skipSSLCheck() == 1));
<         }
---
>             next if ( !$url->isHTTPS() || ( defined $url->skipSSLCheck() && $url->skipSSLCheck() == 1 ) );
> 
>             my $openTicket;
> 
>             # The (?:...) regex does NOT capture the subpattern within the parentheses.
>             if ($displayName =~ /^(?:3rdParty|Inovis VAN)/) {
>                 $openTicket = 1;
>             }
>         if($displayName !~ /TRE service post_url/si) {
>                 $queriesForProducts{$productName}->{$customer}->{"$displayName SSL certificate"} = {
>                     noRowCount => 1,
>                     format     => "<html></td><td>expires in %d days queryError</html>\n",
>                     useFormatOnError => 1,
>                     info       => "answer >= 20",
>                     warn       => "answer < 20 || answer == -2",
>                     crit       => "answer < 10 && answer != -2",
>                     ticketOnWarnOpenAfterMinutes => $openTicket,
>                     severity   => $severity,
>                     staleInterval => 600,   # don't go stale for 10 minutes
>                     perl       => sub { main::checkSSLCert($url) },
>                     url        => $urlName,
>                     uiHint     => $uiHint,
>                     timeout    => -1,
>                     processAnswer => sub { main::processSSLCertAnswer($url) },
>                 };
>             }
358,359c338,339
<         for my $customer (sort keys %{$queriesForProducts{$productName}})
<         {
---
>         for my $customer (sort keys %{$queriesForProducts{$productName}}) {
> 
365,366c345,346
<             for my $suiteProductName (keys %{$suiteQueriesForProducts{$productName}->{$customer}})
<             {
---
>             for my $suiteProductName (keys %{$suiteQueriesForProducts{$productName}->{$customer}}) {
> 
369d348
< 
372a352,362
> 
>         # Create notificationRequests from the ariba::monitor::Url cache
>         notifyPeopleFromURLStatuses($me, $urlsRef->{$productName});
> 
>         # write out status to ops db
>         unless (ariba::Ops::Utils::runWithTimeout(60,
>                     sub { writeStatusChangesToDB($urlsRef->{$productName}); }
>                 )) {
>             die "timeout doing writeStatusChangesToDB()\n";
>         }
> 
375a366,367
> 
>         exit if defined($pid); # Exit out if it is a successfully forked child, otherwise run serially
376a369,370
> 
>     1 while (waitpid(-1, 0) > 0); # Wait for children to exit
380,383c374,376
< sub runQueries
< {
<     my $monserver   = shift;
<     my $qmname      = shift;
---
> sub runQueries {
>     my $monserver = shift;
>     my $qmname = shift;
385,389c378,382
<     my $customer    = shift;
<     my $service     = shift;
<     my $cluster     = shift;
<     my $queries     = shift;
<     my $uiManager   = shift;
---
>     my $customer = shift;
>     my $service = shift;
>     my $cluster = shift;
>     my $queries = shift;
>     my $uiManager = shift;
395,396c388
<     my $realCustomer = ($customer eq '') ? undef : $customer;
<     $queries->{"influx_details"} = {'measurement' => 'front_door'};
---
>     my $realCustomer = ( $customer eq '' ) ? undef : $customer;
398c390
<     my $qm = ariba::monitor::QueryManager->newWithDetails($qmname, $productName, $service, $realCustomer, $cluster, $queries);
---
>     my $qm = ariba::monitor::QueryManager->newWithDetails( $qmname, $productName, $service, $realCustomer, $cluster, $queries);
402c394,423
<     $qm->processQueries();
---
>     $qm->run();
> 
>     if ($debug) {
> 
>         $qm->displayToStdout();
> 
>     } else {
> 
>         $qm->checkStatus();
> 
>         if ((my $ret = $qm->appendToServer($monserver)) != 0) {
> 
>             if ($ret == EX_UNAVAILABLE()) {
>                 trace("writeQueriesForDisplay($productName) encountered EX_UNAVAILABLE from server");
>             } else {
>                 trace("writeQueriesForDisplay($productName) encountered [$ret] from server");
>                 warn $ret;
>             }
>         }
> 
>         $qm->archiveResultsOnServer();
>         $qm->displayToLog() unless ( $monserver eq ariba::Ops::NetworkUtils::hostname() );
> 
>         # do a disconnect here so the queryd children don't hang around until
>         # the GC collects this qm
>         if ($qm->server()) {
>             $qm->server()->disconnect();
>             $qm->setServer(undef);
>         }
>     }
405,406c426
< sub checkSuiteComponent
< {
---
> sub checkSuiteComponent {
416,418c436,437
< sub evalURLsAndLoadIncludes
< {
<     my $me       = shift;
---
> sub evalURLsAndLoadIncludes {
>     my $me = shift;
420,422c439,440
<     my $type     = shift;
<     my $cluster  = shift;
<     my $pname    = shift;
---
>     my $type = shift;
>     my $cluster = shift;
429,430c447
<     for my $include (keys %{$includes})
<     {
---
>     for my $include ( keys %{$includes} ) {
438c455
<         my @initparams = split (/\s+/o, $parms);
---
>         my @initparams = split(/\s+/o, $parms);
440,441c457,458
<         unshift (@initparams, $cluster);
<         unshift (@initparams, $service);
---
>         unshift(@initparams, $cluster);
>         unshift(@initparams, $service);
444c461
<         print "   initparms = ", join (" ", @initparams), "\n" if $debug;
---
>         print "   initparms = ", join(" ", @initparams),"\n" if $debug;
446c463
<         eval ("require $package");
---
>         eval("require $package");
450c467
<         die "${package}::init(", join (", ", @initparams), ") failed ($@)" if $@;
---
>         die "${package}::init(", join(", ",@initparams), ") failed ($@)" if $@;
454,456c471,472
<         for my $product (@monitoredProducts)
<         {
<             next unless defined ($product);
---
>         for my $product (@monitoredProducts) {
>             next unless defined($product);
459,461c475
<             next if ($productName ne $pname);
< 
<             push (@{$urls{$productName}}, eval "${package}::urls(\$product)");
---
>             push(@{$urls{$productName}}, eval "${package}::urls(\$product)");
463,472c477,481
<             if ($type && $type eq 'critical')
<             {
<                 @{$urls{$productName}} = grep {$_->recordStatus() && $_->recordStatus() eq 'yes'} @{$urls{$productName}};
<             }
<             elsif ($type && $type eq 'normal')
<             {
<                 @{$urls{$productName}} = grep {!($_->recordStatus()) || $_->recordStatus() ne 'yes'} @{$urls{$productName}};
<             }
<             else
<             {
---
>             if($type && $type eq 'critical') {
>                 @{$urls{$productName}} = grep { $_->recordStatus() && $_->recordStatus() eq 'yes' } @{$urls{$productName}};
>             } elsif($type && $type eq 'normal') {
>                 @{$urls{$productName}} = grep { !($_->recordStatus()) || $_->recordStatus() ne 'yes' } @{$urls{$productName}};
>             } else {
481,482c490
< sub readConfigFile
< {
---
> sub readConfigFile {
488c496
<     open (CONFIG, $file) || return;
---
>     open(CONFIG, $file) || return;
490,491c498
<     while (my $line = <CONFIG>)
<     {
---
>     while (my $line = <CONFIG>) {
495c502
<         chomp ($line);
---
>         chomp($line);
498,499c505
<         if ($line =~ /^include\s+/o)
<         {
---
>         if ($line =~ /^include\s+/o) {
503c509
<             print "will include ", $includes->{$line}, "\n" if $debug;
---
>             print "will include ", $includes->{$line},"\n" if $debug;
507c513
<     close (CONFIG);
---
>     close(CONFIG);
510,511c516,607
< sub checkSSLCert
< {
---
> sub writeStatusChangesToDB {
>     my $urlsRef = shift;
> 
>     trace("writeStatusChangesToDB()");
> 
>     my $me = ariba::rc::InstalledProduct->new();
> 
>     my @willSubmit = ();
> 
>     for my $url ( @$urlsRef ) {
>         #
>         # this is in case we shifted URL in checkURL due to lastFailedURL
>         #
>         $url = ariba::monitor::Url->new( $url->query()->url() )
>             if ( $url->query() && $url->query()->url() );
> 
>         next unless defined($url);
> 
>         next unless $url->transitionType();
> 
>         next unless $url->recordStatus() && $url->recordStatus() eq "yes";
> 
>         print "looking at ",$url->displayName()," transitionType = ",$url->transitionType(),"\n" if $debug;
> 
>         my $submit;
> 
>         # skip submits for sick->up, up->sick
>         if ( $url->transitionType() eq "down->up" ) {
>             $submit = 1;
>         } elsif ( $url->transitionType() eq "up->down" || $url->transitionType() eq "sick->down") {
>             $submit = 1;
>         }
> 
>         push(@willSubmit, $url) if $submit;
>     }
> 
>     if (scalar @willSubmit > 0) {
>         ariba::monitor::DowntimeEntry->connectToDatabase($me);
>     }
> 
>     for my $url ( @willSubmit ) {
>         my $transitionType = 0;
> 
>         if ( $url->transitionType() eq "down->up" ) {
>             $transitionType = 1;
>         } elsif ( $url->transitionType() eq "up->down" || $url->transitionType() eq "sick->down") {
>             $transitionType = 0;
>         } else {
>             warn "Unexpected transistion type ", $url->transitionType(), "for url ", $url->instance(),"\n";
>             next;
>         }
> 
>         my $note;
> 
>         my $productStatus = ariba::monitor::ProductStatus->newWithDetails(
>             $url->productName(), $me->service(), $url->customerName()
>         );
> 
>         if ($productStatus->inPlannedDownTime()) {
>             $note = sprintf('%s; MCL = %s; TMID:%d', $productStatus->comment(), $productStatus->mcl(), $productStatus->tmid());
>         } else {
>             $note = $url->error() || "";
>         }
> 
>         $note = substr($note, 0, 750); # col is 1024
> 
>         if ( $debug ) {
>             print "Will write DB change for ", $url->instance(), "\n";
>             print "   productname: ", $url->productName(),"\n";
>             print "   appname: ", $url->displayName(),"\n";
>             print "   customer: ", $url->customerName(),"\n" if $url->customerName();
>             print "   planned: ", $productStatus->inPlannedDownTime(),"\n";
>             print "   transitiontime: ", $url->transitionTime(),"\n";
>             print "   transistiontype: ", $transitionType, "\n";
>             print "   note: ", $note, "\n";
>         }
> 
>         my $entry = ariba::monitor::DowntimeEntry->newWithDetails({
>             'productname' => $url->productName(),
>             'appname' => $url->displayName(),
>             'transitiontype' => $transitionType,
>             'planned' => $productStatus->inPlannedDownTime() ? 1 : 0,
>             'timestamp' => $url->transitionTime(),
>             'note' => $note,
>         });
> 
>         $entry->setCustomer( $url->customerName() ) if $url->customerName();
>         $entry->save();
>     }
> }
> 
> sub checkSSLCert {
517c613
<     my $cert = $url->sslCertificate();
---
>     my $cert  = $url->sslCertificate();
520,521c616
<     if ($cert)
<     {
---
>     if ($cert) {
523,525c618
<     }
<     else
<     {
---
>     } else {
530,531c623
<     if ($valid == -1 && checkForScheduledOutage($url, \$error))
<     {
---
>     if ($valid == -1 && checkForScheduledOutage($url, \$error)) {
535c627
<     return join ("\n", ($valid, $error));
---
>     return join("\n", ($valid, $error));
538,540c630,631
< sub processSSLCertAnswer
< {
<     my $url = shift;
---
> sub processSSLCertAnswer {
>     my $url   = shift;
547,548c638
<     if ($valid =~ /timed out/)
<     {
---
>     if ($valid =~ /timed out/) {
558,559c648
<     if ($error)
<     {
---
>     if ($error) {
567,568c656,657
< sub checkURL
< {
---
> 
> sub checkURL {
571c660
<     my $query = $ariba::monitor::Query::_ourGlobalQuerySelf;
---
>     my $query  = $ariba::monitor::Query::_ourGlobalQuerySelf;
573c662
<     $originalUrl->setQuery($query);
---
>     $originalUrl->setQuery( $query );
582,586c671,673
<     if ($query->lastFailedUrl())
<     {
<         if (ariba::monitor::Url->_objectWithNameExistsInCache($query->lastFailedUrl()))
<         {
<             print "checkURLs() USING ", $query->lastFailedUrl(), "because it IS in PO URL cache." if ($debug);
---
>     if ( $query->lastFailedUrl() ) {
>         if( ariba::monitor::Url->_objectWithNameExistsInCache( $query->lastFailedUrl() ) ) {
>             print "checkURLs() USING " , $query->lastFailedUrl() , "because it IS in PO URL cache." if($debug);
595,598c682,683
<         }
<         else
<         {
<             print "checkURLs() skipping ", $query->lastFailedUrl(), "because it's not in PO URL cache." if ($debug);
---
>         } else {
>             print "checkURLs() skipping " , $query->lastFailedUrl() , "because it's not in PO URL cache." if($debug);
604,607c689,691
<     my @urls = ($originalUrl);
<     if ($originalUrl->secondaryURLs())
<     {
<         push (@urls, $originalUrl->secondaryURLs());
---
>     my @urls = ( $originalUrl );
>     if ($originalUrl->secondaryURLs()) {
>         push( @urls, $originalUrl->secondaryURLs() );
624,625c708
<     for my $url (@urls)
<     {
---
>     for my $url (@urls) {
642,643c725
<         if ($error || $connectionError)
<         {
---
>         if ($error || $connectionError ) {
645,646c727
<             if ($url->storeOutput())
<             {
---
>             if ($url->storeOutput()) {
649,658c730,736
<                 my $details = ariba::monitor::Query->newFromHash(
<                                                                  $url->instance() . " output",
<                                                                  $query->productName(),
<                                                                  $query->service(),
<                                                                  $query->customer(),
<                                                                  $query->cluster(),
<                                                                  {
<                                                                   perl => sub {return join ("\n", @output[0 .. $sliceEnd]);},
<                                                                  },
<                                                                 );
---
>                 my $details = ariba::monitor::Query->newFromHash($url->instance() . " output", $query->productName(),
>                    $query->service(),
>                    $query->customer(),
>                    $query->cluster(),
>                    {
>                   perl => sub { return join("\n", @output[0 .. $sliceEnd]); },
>                    },);
661,662c739
<             if ($url->stopOnError())
<             {
---
>             if ($url->stopOnError()) {
674,676c751
<         }
<         else
<         {
---
>         } else {
700c775
<     return (1);
---
>     return(1);
703,706c778,780
< sub processUrl
< {
<     my $query  = shift;
<     my $url    = shift;
---
> sub processUrl {
>     my $query = shift;
>     my $url = shift;
709c783
<     my $error           = '';
---
>     my $error  = '';
711c785
<     my $errorString     = $url->errorString() || "HTTP-WATCHER UNDEFINED ERROR STRING";
---
>     my $errorString = $url->errorString() || "HTTP-WATCHER UNDEFINED ERROR STRING";
714,715c788
<     if ($url->printURL())
<     {
---
>     if($url->printURL()) {
720,721c793
<     for my $line (@output)
<     {
---
>     for my $line (@output) {
730,732c802,803
<         if (   $line =~ m/(\berror\b|die:|refused|refusing|timed out|exception|not found|did not|can\s?not|invalid|unavailable|maintenance)/io
<             || $line =~ m/(SAFEGUARD|$errorString|No route to host|maintenance)/o)
<         {
---
>         if ($line =~ m/(\berror\b|die:|refused|refusing|timed out|exception|not found|did not|can\s?not|invalid|unavailable|maintenance)/io ||
>             $line =~ m/(SAFEGUARD|$errorString|No route to host|maintenance)/o) {
763c834
<             next if $line =~ m/\.message-error\s+{/o || $line =~ m/\.logAndExceptionTable\s+{/o;    # }}
---
>             next if $line =~ m/\.message-error\s+{/o || $line =~ m/\.logAndExceptionTable\s+{/o; # }}
797,799c868,869
<             if ($line =~ /$errorString/o)
<             {
<                 $error           = "Found error string [$errorString] in page [$line]";
---
>             if ($line =~ /$errorString/o) {
>                 $error = "Found error string [$errorString] in page [$line]";
801,803c871
<             }
<             elsif ($line =~ /is temporarily unavailable/o)
<             {
---
>             } elsif ($line =~ /is temporarily unavailable/o) {
807,809c875
<             }
<             elsif ($line =~ /status\s+code="560"/io)
<             {
---
>             } elsif ($line =~ /status\s+code="560"/io) {
813,815c879
<             }
<             else
<             {
---
>             } else {
817,819c881,882
<                 if ($line =~ /SAFEGUARD /o)
<                 {
<                     $error  = "access blocked by Safeguard";
---
>                 if ($line =~ /SAFEGUARD /o) {
>                     $error = "access blocked by Safeguard";
821,823c884
<                 }
<                 else
<                 {
---
>                 } else {
838,839c899
<     if (!$url->stopFollowingOnPatternFound())
<     {
---
>     if (!$url->stopFollowingOnPatternFound()) {
841c901
<         my $output = join ("", @output);
---
>         my $output = join("", @output);
851,852c911
<         if ($output =~ /$samlSSORedirectPageRegex/)
<         {
---
>         if ($output =~ /$samlSSORedirectPageRegex/) {
858,860c917
<         }
<         elsif ($watchString)
<         {
---
>         } elsif ($watchString) {
862,863c919
<             if ($output =~ /$watchString/)
<             {
---
>             if ($output =~ /$watchString/) {
865c921
<                 $error           = "";
---
>                 $error = "";
867,869c923
<             }
<             else
<             {
---
>             } else {
871c925
<                 $fullError .= " ($error)"             if $error;
---
>                 $fullError .= " ($error)" if $error;
876d929
< 
879,880c932
<         if ($output =~ /$discoverCanadaSSORedirectPageRegex/)
<         {
---
>         if ($output =~ /$discoverCanadaSSORedirectPageRegex/) {
884a937
> 
889a943
> 
903,908c957,961
< sub processURLAnswer
< {
<     my $query           = $ariba::monitor::Query::_ourGlobalQuerySelf;
<     my $origUrl         = ariba::monitor::Url->new($query->url());
<     my $url             = $origUrl->processAnswerLastUrl();
<     my $error           = $origUrl->processAnswerError();
---
> sub processURLAnswer {
>     my $query  = $ariba::monitor::Query::_ourGlobalQuerySelf;
>     my $origUrl = ariba::monitor::Url->new( $query->url() );
>     my $url = $origUrl->processAnswerLastUrl();
>     my $error = $origUrl->processAnswerError();
914c967
<     my $oldStatus = $query->previousResults() || 'up';
---
>     my $oldStatus = $query->previousResults()  || 'up';
925,927c978,979
<     if ($query->isDowngraded())
<     {
<         $origUrl->setIsDowngraded("yes");
---
>     if( $query->isDowngraded() ) {
>             $origUrl->setIsDowngraded( "yes" );
929c981
<     $origUrl->setQueryCheckTime(scalar (localtime ($query->checkTime())));
---
>     $origUrl->setQueryCheckTime( scalar(localtime($query->checkTime())) );
935a988
> 
953,954c1006
<     if (defined $url && $url->knownOutage())
<     {
---
>     if ($url->knownOutage()) {
956c1008
<         $error = $url->outageCause() if ($error && $url->outageCause());
---
>         $error = $url->outageCause() if($error && $url->outageCause());
958c1010
<     $query->setForceInfoOnWarn($url->forceInfoOnWarn())  if (defined $url && $url->forceInfoOnWarn());
---
>     $query->setForceInfoOnWarn($url->forceInfoOnWarn()) if (defined($url->forceInfoOnWarn()));
960,961c1012
<     if ($error)
<     {
---
>     if ($error) {
965,966c1016
<         if ($oldStatus eq "up" || $oldStatus eq "")
<         {
---
>         if ($oldStatus eq "up" || $oldStatus eq "") {
968,969c1018
<             if ($hysteresis || $shouldForceSick)
<             {
---
>             if ($hysteresis || $shouldForceSick) {
971,973c1020
<             }
<             else
<             {
---
>             } else {
978,979c1025
<         if ($oldStatus eq "sick")
<         {
---
>         if ($oldStatus eq "sick") {
981,982c1027
<             if ($previousStatusChangeTime + $hysteresis < $checkTime && !$shouldForceSick)
<             {
---
>             if ($previousStatusChangeTime + $hysteresis < $checkTime && !$shouldForceSick) {
991,993c1036
<             }
<             else
<             {
---
>             } else {
1003,1004c1046
<         if ($newStatus ne $oldStatus)
<         {
---
>         if ($newStatus ne $oldStatus) {
1016,1018c1058
<     }
<     else
<     {
---
>     } else {
1023,1024c1063
<         if ($newStatus ne $oldStatus)
<         {
---
>         if ($newStatus ne $oldStatus) {
1032,1035c1071,1072
<     $query->setNote($url->error() . "\n" . $query->note()) if (defined $url && $url->error());
< 
<     my $status_map = { up => 0, down => 1, sick => 2};
<     return ($status_map->{$newStatus});
---
>     $query->setNote($url->error()."\n".$query->note()) if ( $url->error() );
>     return $newStatus;
1038,1039c1075
< sub checkForScheduledOutage
< {
---
> sub checkForScheduledOutage {
1048,1049c1084
<     if (ariba::monitor::AppRecycleOutage->objectWithNameExists($outageName))
<     {
---
>     if(ariba::monitor::AppRecycleOutage->objectWithNameExists($outageName)) {
1051c1086
<         $currOutage = "app recycle" if (defined ($outage));
---
>         $currOutage = "app recycle" if(defined($outage));
1055c1090
<     $currOutage = $url->outageSchedule()->isInScheduledOutage() if (defined ($url->outageSchedule()) and !defined ($currOutage));
---
>     $currOutage = $url->outageSchedule()->isInScheduledOutage() if (defined($url->outageSchedule()) and !defined($currOutage));
1057,1058c1092
<     if (defined ($currOutage))
<     {
---
>     if (defined($currOutage)) {
1060c1094
<         printf ("   %s is in scheduleOutage $currOutage !!!\n", $url->instance()) if $debug;
---
>         printf("   %s is in scheduleOutage $currOutage !!!\n", $url->instance()) if $debug;
1065,1066c1099
<         if (ref ($newStatus))
<         {
---
>         if (ref($newStatus)) {
1070,1071c1103
<             if ($oldStatus ne "sick")
<             {
---
>             if ($oldStatus ne "sick") {
1082,1083c1114,1304
< sub cleanLine
< {
---
> sub notifyPeopleFromURLStatuses {
>     my $me   = shift;
>     my $urls = shift;
> 
>     my $skip = 0;
>     my %seen = ();
> 
> 
>     trace("notifyPeople()");
> 
>     openlog("http-watcher", "ndelay,nofatal", "local1");
> 
>     # TMID: 8435 - this sorts so we get the recordStatus eq yes first, as
>     # that's the more relevant instance/url
>     foreach my $url ( sort { $b->recordStatus() cmp $a->recordStatus() } grep {defined($_)} @$urls ) {
> 
>         #
>         # this is in case we shifted URL in checkURL due to lastFailedURL
>         #
>         $url = ariba::monitor::Url->new( $url->query()->url() )
>             if ( $url->query() && $url->query()->url() );
> 
>         my $to        = $url->notify() || $me->default('notify.email');
>         my $status    = $url->status() || 'up';
>         my $urlName   = $url->instance();
>         my $oldStatus = $url->oldStatus() || '';
> 
>         my $q = $url->query();
> 
>         # build up a unique skipName to cache on.
>         my $skipName = '';
> 
>         if ($url->customerName()) {
>             $skipName = sprintf("%s-%s", $url->productName(), $url->customerName());
>         } else {
>             $skipName = sprintf("%s-%s", $url->productName(), ($url->applicationName() || $url->displayName()));
>         }
> 
>         # skip or add to our cache
>         if (exists $seen{$skipName}) {
>             next;
>         }
> 
>         my $notifyType;
>         if ($status =~ /\bdown\b/o && $oldStatus ne 'down') {
>             $notifyType = 'crit';
>         } elsif ($status =~ /\bup\b/o && $oldStatus eq 'down') {
>             $notifyType = 'crit';
>         } elsif ($status =~ /\bsick\b/o && $oldStatus ne 'sick' && $url->notifyWhenSick()) {
>             $notifyType = 'warn';
>         }
> 
>         # Some URLs should not page, despite going crit, so set notify to warn
>         # But if they have been down for too long, notify should still be crit
>         if($url->noPage() && $url->noPage() eq "true") {
>             my $lastPageTime = $q->lastPageTime() || 0;
>             if($status =~ /\bdown\b/o and $url->pageAfterDownInMinutes() and ($q->checkTime() - $q->lastInfoResultTime() > ($url->pageAfterDownInMinutes() * 60)) and $lastPageTime < $q->lastInfoResultTime()) {
>                 $notifyType = "crit";
>                 $q->setLastPageTime($q->checkTime());
>                 $q->recursiveSave();
>             } elsif($notifyType and $notifyType eq "crit") {
>                 $notifyType = "warn";
>             }
>         }
> 
>         next unless defined($notifyType);
> 
>         my $level;
>         if($notifyType eq "warn") {
>             $level = "warning";
>         } else {
>             $level = "err";
>         }
> 
>         my $product = $url->productName();
>         my $service = $me->service();
>         my $uiHint = $q->uiHint();
>         syslog($level, "HTTP $product:$service:$uiHint:$status:$oldStatus $urlName");
> 
>         #
>         # only mark this as seen if we send a page for it
>         #
>         if ($url->recordStatus() && $url->recordStatus() eq 'yes') {
>             $seen{$skipName}++;
>         }
> 
>         #
>         # don't notify if the related query is downgraded in mon
>         #
>         if( $url->isDowngraded() ) {
>             next;
>         }
> 
>         if ($debug) {
>             print $url->instance(),"\n";
>             print "   notify: ", $to, "\n";
>             print "   status: ", $status, "\n";
>             print "   oldStatus: ", $oldStatus, "\n";
>             print "   productName: ", $url->productName(), "\n";
>             print "   customerName: ", $url->customerName(), "\n" if $url->customerName();
>             print "   recordStatus: ", $url->recordStatus(), "\n";
>             print "   queryCheckTime: ", $url->queryCheckTime(), "\n";
>             print "   program started at: $programStartTime\n";
>             print "\n";
>         }
> 
>         my $severity = '';
>         $severity = ' s' . $url->severity() if (defined($url->severity()));
>         my $community = $url->community();
>         if ($community) {
>             $community = "Community: $community";
>         } else {
>             $community = "Community: default";
>         }
>         my $body = "";
>         my $subject = sprintf("%s%s: %s %s %s ", $notifyType, $severity, $url->displayName(),$community, $status);
> 
>         if ( $url->error() ) {
>             if ( length($url->error()) < 20 ) {
>                 $subject .= $url->error();
>             } else {
>                 $body    .= "Error: " . $url->error() . "\n";
>             }
>         }
> 
>         # This can be a separate error, and we don't want to overwrite
>         # the original $url->error()
>         if ( $url->sslCertError() ) {
>             $body .= "SSL Error: " . $url->sslCertError() . "\n";
>         }
> 
>         $body .= "URL: $urlName\n";
>         if ( $url->finalURL() ) {
>             $body .= "\nFinal URL: " . $url->finalURL() . "\n";
>         }
> 
>         $body .= join("\n",
>             "   notify: [$to]",
>             "   status: [$status]",
>             "   oldStatus: [$oldStatus]",
>             "   queryCheckTime: [" . $url->queryCheckTime() . "]",
>             "   program started at: [$programStartTime]",
>         );
> 
>         if ( $url->saveRequest() && $url->requestString() ) {
>             $body .= "\n\nRequest string:\n" . $url->requestString() . "\n";
>         }
> 
>         $body .= $url->query()->displayDetailsToString() if $url->query()->details();
> 
>         $body =~ s/[^a-zA-Z0-9:\.'"\{\}\[\]\s\?\/!@#\$%\^&\*\(\)-=\+_]/_/g;
> 
>         my $notificationRequest = ariba::Ops::NotificationRequest->newMessage(
>             $notifyType,
>             "http-watcher",
>             $url->productName(),
>             $me->service(),
>             $url->customerName(),
>             $url->clusterName(),
>             $subject,
>             $body,
>             $to
>         );
> 
>         $notificationRequest->setDebug($debug);
>         $notificationRequest->send();
> 
>         #
>         # XXX -- send pages for recordStatus URLs in sales to monprod via email
>         #
>         if($me->service() eq 'sales' && !$debug) {
>             if($url->recordStatus() && $url->recordStatus() eq 'yes') {
>                 my $msg = Mail::Send->new();
>                 $msg->set( 'From', "monsales\@ariba.com");
>                 my $pagers = ariba::Ops::Constants::operationsPagerAddress();
>                 my $recipient = ( $notifyType eq 'crit' ) ?  $pagers : $to;
>                 $msg->to( $recipient );
>                 $msg->subject( "SALES: " . $url->productName() . " - $subject" );
>                 my $fh = $msg->open();
>                 print $fh $body;
>                 $fh->close();
>             }
>         }
>     }
> 
>     closelog();
> 
>     trace("finished notifyPeople()");
> }
> 
> sub cleanLine {
1086c1307
<     return $line unless ($line);
---
>     return $line unless($line);
1092,1093c1313
<     if ($line =~ /^<\?xml/i)
<     {
---
>     if ( $line =~ /^<\?xml/i ) {
1095,1097c1315
<     }
<     else
<     {
---
>     } else {
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/tools/perl-5.22.1/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/common/http-watcher#93 $
---
> # $Id: //ariba/services/monitor/bin/common/http-watcher#94 $
170c170
<             my $displayName = $url->instanceName() || $url->displayName();
---
>             my $displayName = $url->displayName();
207,209d206
<             my $adminurl  = $url->adminURL() || 'none'; 
<             my $inspector = $url->inspectorURL() || 'none'; 
<             my $logurl    = $url->logURL() || 'none'; 
267c264
<                 $community = "none" if(! $community);  
---
>  
286,288d282
<                     inf_field => "status",
<                     inf_tags =>  "community=\"$community\",node=\"$displayName\",adminurl=\"$adminurl\",inspector=\"$inspector\",logurl=\"$logurl\"",
<                     group_by =>  "$displayName"
395d388
<     $queries->{"influx_details"} = { 'measurement' => 'front_door' };
filename:./bin/common/logsize-watcher
13,14c13
< sub usage
< {
---
> sub usage {
36,46c35,44
< sub main
< {
<     my %opts;    # setting defaults here
<     my $debug     = 0;
<     my $sendEmail = 0;
<     my $sendPage  = 0;
<     my $port      = ariba::Ops::Constants->logViewerPort();
<     my $warn      = 1.5;                                      # 1.5GB
<     my $crit      = 10;                                       # 10GB
<     my $help      = 0;
<     my $timeout   = 30;                                       # 30 second timeout for LWP::Simple
---
> sub main {
>     my %opts; # setting defaults here
>     my $debug               = 0;
>     my $sendEmail           = 0;
>     my $sendPage            = 0;
>     my $port                = ariba::Ops::Constants->logViewerPort();
>     my $warn                = 1.5;      # 1.5GB
>     my $crit                = 10;       # 10GB
>     my $help                = 0;
>     my $timeout             = 30; # 30 second timeout for LWP::Simple
50,70c48,68
<                "h"         => \$help,
<                "debug|d"   => sub {$debug++;},
<                "e"         => \$sendEmail,
<                "p"         => \$sendPage,
<                "port=i"    => \$port,
<                "warn=i"    => \$warn,
<                "crit=i"    => \$crit,
<                "timeout=i" => \$timeout,
<                "cluster=s" => \$cluster,
<               );
< 
<     exit (usage()) if ($help);
< 
<     my $me       = ariba::rc::InstalledProduct->new();
<     my $service  = $me->service();
<     my @products = ariba::rc::InstalledProduct::installedProductsList($service);
< 
<     my $crit_condition = "answer =~ /crit/";    # purposely set here so that we can "undef" this to prevent pages when hitting log-viewer fails
< 
<     $ua->timeout($timeout);                     # setting LWP::Simple timeout
< 
---
>         "h"         => \$help,
>         "debug|d"   => sub { $debug++; },
>         "e"         => \$sendEmail,
>         "p"         => \$sendPage,
>         "port=i"    => \$port,
>         "warn=i"    => \$warn,
>         "crit=i"    => \$crit,
>         "timeout=i" => \$timeout,
>         "cluster=s" => \$cluster,
>     );
> 
>     exit( usage() ) if ( $help );
> 
>     my $me = ariba::rc::InstalledProduct->new();
>     my $service = $me->service();
>     my @products = ariba::rc::InstalledProduct::installedProductsList( $service );
>     
>     my $crit_condition = "answer =~ /crit/"; # purposely set here so that we can "undef" this to prevent pages when hitting log-viewer fails
>     
>     $ua->timeout($timeout); # setting LWP::Simple timeout
>     
73c71
<     $cluster = $me->currentCluster() unless ($cluster);
---
>     $cluster = $me->currentCluster() unless ( $cluster );
75,76c73
<     foreach my $product (@products)
<     {
---
>     foreach my $product ( @products ) {
80,82c77,79
<         next unless ($product->currentCluster() eq $cluster);
< 
<         my @hosts = $product->allHostsInCluster($product->currentCluster());
---
>         next unless ( $product->currentCluster() eq $cluster );
>         
>         my @hosts = $product->allHostsInCluster( $product->currentCluster() );
84d80
<         my $productName = $product->name();
88,89c84
<         foreach my $host (@hosts)
<         {
---
>         foreach my $host ( @hosts ) {
91,93c86,88
< 
<             next if ($host =~ /^(nfs|storadmin|backup)/);    # OK list of hostname patterns to skip
< 
---
>             
>             next if ( $host =~ /^(nfs|storadmin|backup)/ ); # OK list of hostname patterns to skip
>             
95,98c90,93
<             $url .= "/$customer" if defined ($customer);     # appending customer to the URL if defined
< 
<             my $content     = LWP::Simple::get($url);
<             my $queryString = 0;
---
>             $url .= "/$customer" if defined ( $customer ); # appending customer to the URL if defined
>             
>             my $content = LWP::Simple::get( $url );
>             my $queryString;
100,107d94
<             my $roundedGB;
<             my $logName;
<             my $size;
<             my $sizeGB;
< 
<             if ($content)
<             {
<                 my @lines = split (/\n/, $content);
109,110c96,99
<                 foreach my $line (@lines)
<                 {
---
>             if ( $content ) {
>                 my @lines = split( /\n/, $content );
>                 
>                 foreach my $line ( @lines ) {
112,113c101,102
<                     my @elements = split (/\s+/, $line);
<                     $size = $elements[0];
---
>                     my @elements = split( /\s+/, $line );
>                     my $size = $elements[0];
115,120c104,105
<                     if (defined $size && $size =~ /^\d+$/)
<                     {
<                         ($logName) = $elements[-1] =~ />(.*)</;
< 
<                         if (defined $logName)
<                         {
---
>                     if ( defined $size && $size =~ /^\d+$/ ) {
>                         my ($logName) = $elements[-1] =~ />(.*)</;
121a107,108
>                         if ( defined $logName ) {
>                             
123,175c110,121
<                             next if ($logName =~ /^tls-security/);
< 
<                             $sizeGB = $size / 1024 / 1024 / 1024;     # converting to Gigabytes
<                             $roundedGB = sprintf ("%.2f", $sizeGB);
< 
<                             #if ( $sizeGB > $crit ) {
<                             #    print "$host crit: $logName size ${roundedGB}GB > ${crit}GB\n" if $debug;
<                             #    $queryString .= "crit: $logName size ${roundedGB}GB > ${crit}GB\n";
<                             #}
<                             if ($sizeGB > $warn)
<                             {
<                                 print "$host warn: logname:$logName size ${roundedGB}GB > ${warn}GB\n" if $debug;
<                                 $queryString = 1;
<                                 $queries{qq|KR log size for $host host|} = {
<                                                                        warn          => "answer =~ /warn/",
<                                                                        crit          => $crit_condition,
<                                                                        error         => $errorString,
<                                                                        perl          => "return $queryString",
<                                                                        'inf_field'   => "krlog_size_status",
<                                                                        'inf_default' => "none",
<                                                                        'inf_tags'    => qq(host="$host"),
<                                                                        'group_by'    => qq($host),
<                                                                       };
<                                 $queries{qq|KR log size for $host size|} = {
<                                                                             warn          => "answer =~ /warn/",
<                                                                             crit          => $crit_condition,
<                                                                             error         => $errorString,
<                                                                             perl          => "return $roundedGB",
<                                                                             'inf_field'   => "size",
<                                                                             'inf_default' => 0,
<                                                                             'inf_tags'    => qq(host="$host"),
<                                                                             'group_by'    => qq($host),
<                                                                            };
<                                 $queries{qq|KR log size for $host error|} = {
<                                                                              warn          => "answer =~ /warn/",
<                                                                              crit          => $crit_condition,
<                                                                              error         => $errorString,
<                                                                              perl          => "return q($errorString)",
<                                                                              'inf_field'   => "error",
<                                                                              'inf_default' => "none",
<                                                                              'inf_tags'    => qq(host="$host"),
<                                                                              'group_by'    => qq($host),
<                                                                             };
<                                 $queries{qq|KR log size for $host logname|} = {
<                                                                                warn          => "answer =~ /warn/",
<                                                                                crit          => $crit_condition,
<                                                                                error         => $errorString,
<                                                                                perl          => "return q($logName)",
<                                                                                'inf_field'   => "logname",
<                                                                                'inf_default' => "none",
<                                                                                'inf_tags'    => qq(host="$host"),
<                                                                                'group_by'    => qq($host),
<                                                                               };
---
>                             next if ( $logName =~ /^tls-security/ );
>                             
>                             my $sizeGB = $size / 1024 / 1024 / 1024; # converting to Gigabytes
>                             my $roundedGB = sprintf( "%.2f", $sizeGB );
> 
>                             if ( $sizeGB > $crit ) {
>                                 print "$host crit: $logName size ${roundedGB}GB > ${crit}GB\n" if $debug;
>                                 $queryString .= "crit: $logName size ${roundedGB}GB > ${crit}GB\n";
>                             }
>                             elsif ( $sizeGB > $warn ) {
>                                 print "$host warn: $logName size ${roundedGB}GB > ${warn}GB\n" if $debug;
>                                 $queryString .= "warn: $logName size ${roundedGB}GB > ${warn}GB\n";
181,184c127,129
<             else
<             {
<                 $errorString    = "Could not hit log-viewer";
<                 $queryString    = 1;
---
>             else {
>                 $errorString = "error: Could not hit log-viewer on $host";
>                 $queryString = $errorString;
186,205d130
<                 $queries{qq|KR log size for $host host|} = {
<                                                        warn          => "answer =~ /warn/",
<                                                        crit          => $crit_condition,
<                                                        error         => $errorString,
<                                                        perl          => "return $queryString",
<                                                        'inf_field'   => "krlog_size_status",
<                                                        'inf_default' => 1,
<                                                        'inf_tags'    => qq(host="$host"),
<                                                        'group_by'    => qq($host),
<                                                       };
<                 $queries{qq|KR log size for $host error|} = {
<                                                              warn          => "answer =~ /warn/",
<                                                              crit          => $crit_condition,
<                                                              error         => $errorString,
<                                                              perl          => "return q($errorString)",
<                                                              'inf_field'   => "error",
<                                                              'inf_default' => "none",
<                                                              'inf_tags'    => qq(host="$host"),
<                                                              'group_by'    => qq($host),
<                                                             };
208c133
<         $queries{"influx_details"} = {'measurement' => "logsize_watcher"};
---
>         
218,219d142
< 
< 
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
81d80
< 	my $productName = $product->name();
94c93
<             my $queryString = 0;
---
>             my $queryString;
96,99d94
< 	    my $roundedGB;
< 	    my $logName;
< 	    my $size;
<     	    my $sizeGB;
107c102
<                     $size = $elements[0];
---
>                     my $size = $elements[0];
110c105
<                         ($logName) = $elements[-1] =~ />(.*)</;
---
>                         my ($logName) = $elements[-1] =~ />(.*)</;
117,118c112,113
<                             $sizeGB = $size / 1024 / 1024 / 1024; # converting to Gigabytes
<                             $roundedGB = sprintf( "%.2f", $sizeGB );
---
>                             my $sizeGB = $size / 1024 / 1024 / 1024; # converting to Gigabytes
>                             my $roundedGB = sprintf( "%.2f", $sizeGB );
120,124c115,119
<                             #if ( $sizeGB > $crit ) {
<                             #    print "$host crit: $logName size ${roundedGB}GB > ${crit}GB\n" if $debug;
<                             #    $queryString .= "crit: $logName size ${roundedGB}GB > ${crit}GB\n";
<                             #}
<                             if ( $sizeGB > $warn ) {
---
>                             if ( $sizeGB > $crit ) {
>                                 print "$host crit: $logName size ${roundedGB}GB > ${crit}GB\n" if $debug;
>                                 $queryString .= "crit: $logName size ${roundedGB}GB > ${crit}GB\n";
>                             }
>                             elsif ( $sizeGB > $warn ) {
126,136c121
<                                 $queryString = 1;
<             			$queries{ qq|KR log size for $host| } = {
< 	                		warn => "answer =~ /warn/",
< 	                		crit => $crit_condition,
< 	                		error => $errorString,
< 					'inf_field' => "krlog_size_status",
< 		        		'inf_default' => "none",
< 		        		'inf_tags' =>  "host=\"$host\",logname=\"$logName\",size=$roundedGB,error=\"$errorString\"",
< 					'group_by' => $host,
< 	                		perl => sub { return $queryString; },
<         			    };
---
>                                 $queryString .= "warn: $logName size ${roundedGB}GB > ${warn}GB\n";
143,144c128,129
<                 $errorString = "Could not hit log-viewer";
<                 $queryString = 1;
---
>                 $errorString = "error: Could not hit log-viewer on $host";
>                 $queryString = $errorString;
146,155d130
<             			$queries{ qq|KR log size for $host| } = {
< 	                		warn => "answer =~ /warn/",
< 	                		crit => $crit_condition,
< 	                		error => $errorString,
< 					'inf_field' => "krlog_size_status",
< 		        		'inf_default' => 1,
< 		        		'inf_tags' =>  "host=\"$host\",error=\"$errorString\"",
< 					'group_by' => $host,
< 					 perl => sub { return $queryString; },
< 				};
156a132,143
>            
>             $queries{ qq|KR log size for $host| } = {
>                 warn => "answer =~ /warn/",
>                 crit => $crit_condition,
>                 error => $errorString,
>                 description     => "A value of 'none' means that the log size is ok. If the result is an integer value,
>                                    then the KR log size is large and requires attention.",
>                 correctiveActions => [
>                     Ops => 'Please take a look at the log and take appropriate action',
>                 ],
>                 perl => sub { return $queryString; },
>             };
158,163c145
<         my $inf_measurement =  "logsize_watcher";
<         my $inf_tags = "product=$productName,service=$service";
<         $queries{"influx_details"} = {
<                                        'measurement' => $inf_measurement,
<                                        'tags' => $inf_tags
<                                  }; 
---
>         
166c148
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/node-status
18,254c18
< use ariba::Ops::ProductAPIExtensions;
< use dmail::LockLib;
< use Data::Dumper;
< 
< my $log        = 1;
< my $maxResults = 17520;    # one year at twice an hour
< 
< sub main
< {
<     my $debug     = 0;
<     my $quiet     = 0;
<     my $sendEmail = 0;
<     my $sendPage  = 0;
<     my $productName;
< 
<     while (my $arg = shift (@ARGV))
<     {
<         print STDERR "parsing arg $arg\n" if $debug > 1 and !$quiet;
<         if ($arg =~ /^-d/o)    {$debug++;}
<         if ($arg =~ /^-e/o)    {$sendEmail = 1;}
<         if ($arg =~ /^-p$/o)   {$sendPage = 1;}
<         if ($arg =~ /^-prod/o) {$productName = shift (@ARGV);}
<     }
< 
<     my $me      = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
<     my $email   = $me->default('notify.email');
< 
<     unless ($productName)
<     {
<         print "Must specify a product.\n" if (-t STDOUT);
<         exit (0);
<     }
< 
<     unless (grep {$_ eq $productName} (ariba::rc::Globals::sharedServicePlatformProducts(), "an"))
<     {
<         print "node-status only works for AN and platform shared service products.\n" if (-t STDOUT);
<         exit (0);
<     }
< 
<     my @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
<     unless (@products)
<     {
<         exit (0);
<     }
< 
<     for my $product (@products)
<     {
<         my $productIdentifier = $product->name();
<         $productIdentifier .= $product->customer() if $product->customer();
< 
<         my $lockFile = "/tmp/stratus-$productIdentifier-node-status";
<         if (!dmail::LockLib::requestlock($lockFile, 5))
<         {
<             die "node-status: Can't grab lock";
<         }
< 
<         my $tmpFile = "/var/tmp/$productIdentifier-internodeResponse.log";
<         my $time    = localtime (time ());
< 
<         if ($log)
<         {
<             open (LOG, ">> $tmpFile") || die "ERROR: unable to open $tmpFile, $!\n";
< 
<             print LOG '-' x 72, "\n";
<             print LOG "Time = $time\n";
<             print LOG '-' x 72, "\n";
<         }
< 
<         my $skip = 0;
< 
<         my %queries = ();
<         my %realmsServed;
<         my %nodeServesRealms;
<         my %nodeCount;
<         my $nodesUsingBuildRef;
<         my %realmBelongsToCommunity;
< 
<         my @instances;
<         if ($productName eq 'an')
<         {
<             @instances = grep {$_->isTomcatApp() or $_->isWOFApp() or $_->isSpringbootApp()} $product->appInstancesInCluster($cluster);
<         }
<         else
<         {
<             @instances = grep {$_->isTomcatApp() or $_->isWOFApp()} $product->appInstancesInCluster($cluster);
<         }
< 
<         my $numInstances  = scalar (@instances);
<         my $downInstances = 0;
<         my %internodeCommunications;
<         my %communityInternodeCommunications;
<         my %communitySSOClientState;
<         my %shutdownTimePerCommunity;
<         my %communityToNodesHash;
<         my %communities;
<         my @comhash;
<         my @bhash;
< 
<         for my $instance (@instances)
<         {
< 
<             my $instanceName = $instance->workerName();
<             $nodeCount{'Total'}++;
<             my $type = $instance->appName();
<             $nodeCount{"$type"}++;
<             my $community = $instance->community() || "Default";
<             push @comhash, {'community' => $community, 'node' => $instance->workerName()};
<             push (@{$communityToNodesHash{$community}}, "<html><a href=\"" . $instance->logURL() . "\">" . $instance->workerName() . "</a></html>");
< 
<             my $monitorStats = ariba::monitor::AppInstanceStats->newFromAppInstance($instance);
<             $monitorStats->fetch();
< 
<             #
<             # ignore, if the node is down or cannot respond right now
<             #
<             if ($monitorStats->error())
<             {
<                 print "**** $instanceName error: ", $monitorStats->error(), "\n" if ($debug > 1);
<                 $downInstances++;
<                 next;
<             }
< 
<             $communities{$community} = 1;
< 
<             # The way to tell if an instance is a task node or a UI node is by checking if this instance needs to be nightly recycled.
<             # A task node doesn't need to be nighly recycled
<             $shutdownTimePerCommunity{$community}{$instance->instanceName()} = $monitorStats->shutdownTime() unless ($instance->needsNightlyRecycle());
< 
<             realmsServedByNode($monitorStats, $instanceName, $type, \%realmsServed, \%nodeServesRealms, \%realmBelongsToCommunity,);
<             my $buildName = $monitorStats->applicationBuildName();
<             my $expectedBuildName = ($product->isASPProduct() ? $product->baseBuildName() : $product->buildName());
<             push (@bhash, {'buildname' => $buildName, 'node' => $instanceName, 'community' => $community}) if ($buildName);
<         }
<         my %squeries;
<         foreach my $k (keys %nodeCount)
<         {
<             $squeries{"Total number of nodes $k"} = {
<                                                      info             => 1,
<                                                      perl             => sub {return $nodeCount{$k};},
<                                                      recordMaxResults => $maxResults,
<                                                      recordDataType   => 'gauge',
<                                                      recordItem       => 'answer',
<                                                      'inf_field'      => "node_count",
<                                                      'inf_default'    => 0,
<                                                      'inf_tags'       => "node_type=\"$k\"",
<                                                      'group_by'       => $k
<                                                     };
<         }
< 
<         $squeries{"influx_details"} = {'measurement' => "node_status_summary"};
<         my $q = ariba::monitor::QueryManager->newWithDetails("node-status", $product->name(), $service, $product->customer(), \%squeries);
< 
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         unless ($productName =~ /^(an|arches)$/)
<         {
<             $queries{"Realm serving errors"} = {
<                                                 'rowCountLimit' => 4000,
<                                                 'noRowCount'    => 1,
<                                                 'format'        => "%5s: %15s: %15s: %15s",
<                                                 'info'          => "numrows > -1",
<                                                 'skip'          => $skip,
<                                                 'crit'          => "answer =~ /^Error/ && previousAnswer =~ /^Error/",
<                                                 'warn'          => "answer =~ /^Warn/",
<                                                 'severity'      => 0,
<                                                 'perl'          => sub {main::realmServedStatus($product, \%realmsServed, \%nodeServesRealms, \%realmBelongsToCommunity);},
<                                                };
<         }
< 
<         $queries{"Communities to nodes"} = {
<             'noRowCount' => 1,
<             'format'     => "<html><td>%s</td><td>%s</td></html>",
<             'info'       => 1,
<             'multiRow'   => 1,
<             'perl'       => sub {
<                 join (
<                       "\n", map {"$_:" . "\t" . join (", ", @{$communityToNodesHash{$_}})}
<                         sort (keys %communityToNodesHash)
<                      );
<             },
<         };
< 
<         my %bqueries;
<         my $expectedBuildName = ($product->isASPProduct() ? $product->baseBuildName() : $product->buildName());
< 
<         foreach my $arr (@bhash)
<         {
<             $bqueries{"Build being used by nodes" . $arr->{buildname} . $arr->{node} . $arr->{community}} = {
<                                                                                                              'noRowCount' => 1,
<                                                                                                              'info'       => "numrows > -1",
<                                                                                                              'skip'       => $skip,
<                                                                                                              'crit'       => "numrows > 1 || answer !~ /$expectedBuildName/",
<                                                                                                              'perl'       => sub {return $arr->{buildname}},
<                                                                                                              inf_field    => 'build_name',
<                                                                                                              inf_tags     => qq(node=$arr->{node},community=$arr->{community}),
<                                                                                                              group_by     => qq($arr->{buildname},$arr->{node},$arr->{community}),
<                                                                                                             };
<         }
<         $bqueries{"influx_details"} = {'measurement' => "node_status_build"};
<         my $q = ariba::monitor::QueryManager->newWithDetails("node-status", $product->name(), $service, $product->customer(), \%bqueries);
< 
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         unless ($productName eq 'an')
<         {
<             #
<             # shuffle array elements, and pick the first one for monitoring
<             # split cluster health
<             #
<             ariba::Ops::Utils::fisherYatesShuffle(\@instances);
<             my $checkedInternodeResponseTime = 0;
<             my %checkedCommunityInternodeResponseTime;
< 
<             for my $instance (@instances)
<             {
< 
<                 my $instanceName = $instance->workerName();
< 
<                 # check atleast three nodes for global communication health
<                 if ($checkedInternodeResponseTime < 3)
<                 {
<                     my $responseTimeUrl = $instance->internodesResponseTimeMonitorURL();
<                     my $responseTimes   = ariba::monitor::Url->new($responseTimeUrl);
< 
<                     print "$instanceName responseTimeUrl = $responseTimeUrl\n" if ($debug > 1);
< 
<                     $responseTimes->setTimeout(180);
<                     my @responseTimeStats = $responseTimes->request();
<                     my $nodeResponses = nodeResponseTimes(\@responseTimeStats, $instanceName);
< 
<                     if ($log)
<                     {
<                         print LOG "$instanceName responseTimeUrl = $responseTimeUrl\n";
<                         print LOG "  ", join ("  ", @responseTimeStats), "\n";
<                     }
---
> use ariba::Ops::ProductAPIExtensions; 
256,273c20,21
<                     $internodeCommunications{$instanceName} = $nodeResponses;
<                     $checkedInternodeResponseTime++;
<                 }
< 
<                 next unless ($product->numCommunities());
< 
<                 my $community = $instance->community() || 0;
< 
<                 next unless ($community);
< 
<                 # check at least two nodes for community level internode
<                 # communication
<                 next if ($checkedCommunityInternodeResponseTime{$community} >= 2);
<                 unless (defined ($checkedCommunityInternodeResponseTime{$community}))
<                 {
<                     $checkedCommunityInternodeResponseTime{$community} = 0;
<                 }
<                 $checkedCommunityInternodeResponseTime{$community}++;
---
> my $log = 1;
> my $maxResults = 17520; # one year at twice an hour
275,286c23,91
<                 my $communityResponseTimeUrl = $instance->internodesResponseTimeMonitorURL(1);
<                 my $communityResponseTimes   = ariba::monitor::Url->new($communityResponseTimeUrl);
<                 print "$instanceName community ($community) responseTimeUrl = $communityResponseTimeUrl\n" if ($debug > 1);
< 
<                 $communityResponseTimes->setTimeout(60);
<                 my @communityResponseTimeStats = $communityResponseTimes->request();
<                 my $communityNodeResponses = nodeResponseTimes(\@communityResponseTimeStats, $instanceName);
< 
<                 if ($log)
<                 {
<                     print LOG "$instanceName community ($community) responseTimeUrl = $communityResponseTimeUrl\n";
<                     print LOG "  ", join ("  ", @communityResponseTimeStats), "\n";
---
> sub main {
> 	my $debug = 0;
> 	my $quiet = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while(my $arg=shift(@ARGV)){
> 			print STDERR "parsing arg $arg\n" if $debug > 1 and !$quiet;
> 			if($arg =~ /^-d/o){ $debug++; }
> 			if($arg =~ /^-e/o){ $sendEmail=1; };
> 			if($arg =~ /^-p$/o){ $sendPage=1; };
> 			if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 	my $email = $me->default('notify.email');
> 
> 	unless($productName) {
> 		print "Must specify a product.\n" if( -t STDOUT );
> 		exit(0);
> 	}
> 
> 	unless( grep { $_ eq $productName } (ariba::rc::Globals::sharedServicePlatformProducts(), "an") ) {
> 		print "node-status only works for AN and platform shared service products.\n" if( -t STDOUT );
> 		exit(0);
> 	}
> 
> 	my @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
> 	unless (@products) {
> 		exit(0);
> 	}
> 
> 	for my $product (@products) {
> 		my $productIdentifier = $product->name();
> 		$productIdentifier .= $product->customer() if $product->customer();
> 
> 		my $lockFile = "/tmp/$productIdentifier-node-status";
> 		if (!dmail::LockLib::requestlock($lockFile,5)) {
> 			die "node-status: Can't grab lock";
> 		}
> 
> 		my $tmpFile = "/var/tmp/$productIdentifier-internodeResponse.log";
> 		my $time = localtime(time());
> 
> 		if ($log) {
> 			open(LOG, ">> $tmpFile") || die "ERROR: unable to open $tmpFile, $!\n";
> 
> 			print LOG '-' x 72, "\n";
> 			print LOG "Time = $time\n";
> 			print LOG '-' x 72, "\n";
> 		}
> 
> 		my $skip = 0;
> 
> 		my %queries  = ();
> 		my %realmsServed;
> 		my %nodeServesRealms;
> 		my %nodeCount;
> 		my $nodesUsingBuildRef;
> 		my %realmBelongsToCommunity;
> 
> 	        my @instances;
>                 if ($productName eq 'an') {
>                    @instances = grep { $_->isTomcatApp() or $_->isWOFApp() or $_->isSpringbootApp() } $product->appInstancesInCluster($cluster);
>                 } else {
>                    @instances = grep { $_->isTomcatApp() or $_->isWOFApp() } $product->appInstancesInCluster($cluster);
289,351c94,337
<                 $communityInternodeCommunications{$community}->{$instanceName} = $communityNodeResponses;
<             }
< 
<             if ($log)
<             {
<                 print LOG '=' x 72, "\n";
<                 close (LOG);
<             }
< 
<             my $expectedResponses = $numInstances - $downInstances;
<             $queries{"Internode communication health"} = {
<                                                           'noRowCount'                   => 1,
<                                                           'skip'                         => $skip,
<                                                           'crit'                         => "answer !~ /^Info:/ && answer =~ /split cluster/ && previousAnswer !~ /^Info:/ && previousAnswer =~ /split cluster/",
<                                                           'info'                         => 1,
<                                                           'warn'                         => "answer =~ /^Warn/ || answer =~ /^Error/",
<                                                           'ticketOnWarnOpenAfterMinutes' => 180,
<                                                           'perl'                         => sub {main::consolidatedNodeResponseHealth(\%internodeCommunications, $expectedResponses);},
<                                                          };
< 
<             for my $community (keys (%communityInternodeCommunications))
<             {
< 
<                 my $thisCommunityInternodeCommunication = $communityInternodeCommunications{$community};
<                 my $thisCommunitySSOClientState         = $communitySSOClientState{$community};
< 
<                 my $numInstancesInCommunity = scalar (keys (%$thisCommunityInternodeCommunication));
<                 if ($community)
<                 {
<                     $community = "community $community";
<                 }
<                 else
<                 {
<                     $community = "default community";
<                 }
< 
<                 my $uiHint = "$community";
< 
<                 $queries{"Internode communication health for $community"} = {
<                                                                              'noRowCount'                   => 1,
<                                                                              'skip'                         => $skip,
<                                                                              'info'                         => 1,
<                                                                              'uiHint'                       => $uiHint,
<                                                                              'warn'                         => "answer =~ /^Warn/ || answer =~ /^Error/",
<                                                                              'ticketOnWarnOpenAfterMinutes' => 180,
<                                                                              'perl'                         => sub {main::consolidatedNodeResponseHealth($thisCommunityInternodeCommunication, $numInstancesInCommunity);},
<                                                                             };
< 
<                 if (defined ($thisCommunitySSOClientState))
<                 {
<                     for my $instanceName (keys %$thisCommunitySSOClientState)
<                     {
<                         $queries{"$instanceName SSO status"} = {
<                                                                 'skip'   => $skip,
<                                                                 'uiHint' => $uiHint,
<                                                                 'crit'   => "!defined(answer) || answer =~ /^Server has LogoutProblem/i",
<                                                                 'info'   => 1,
<                                                                 'perl'   => sub {return $thisCommunitySSOClientState->{$instanceName};},
<                                                                };
<                     }
<                 }
<             }
<         }
---
> 		my $numInstances = scalar(@instances);
> 		my $downInstances = 0;
> 		my %internodeCommunications;
> 		my %communityInternodeCommunications;
> 		my %communitySSOClientState;
> 		my %shutdownTimePerCommunity;
> 		my %communityToNodesHash;
> 		my %communities;
> 
> 		for my $instance (@instances) {
> 
> 			my $instanceName = $instance->workerName();
> 			$nodeCount{''}++;
> 			my $type = $instance->appName();
> 			$nodeCount{" of type $type"}++;
> 
> 			my $community = $instance->community() || "Default";
> 			push (@{$communityToNodesHash{$community}}, "<html><a href=\"".$instance->logURL()."\">".$instance->workerName()."</a></html>" );
> 
> 			my $monitorStats = ariba::monitor::AppInstanceStats->newFromAppInstance($instance);
> 			$monitorStats->fetch();
> 
> 			#
> 			# ignore, if the node is down or cannot respond right now
> 			#
> 			if ($monitorStats->error()) {
> 				print "**** $instanceName error: ", $monitorStats->error(), "\n" if ($debug > 1);
> 				$downInstances++;
> 				next;
> 			}
> 
> 			$communities{$community} = 1;
> 
> 			# The way to tell if an instance is a task node or a UI node is by checking if this instance needs to be nightly recycled.
> 			# A task node doesn't need to be nighly recycled
> 			$shutdownTimePerCommunity{$community}{$instance->instanceName()} =  $monitorStats->shutdownTime() unless ($instance->needsNightlyRecycle());
> 
> 			realmsServedByNode($monitorStats, $instanceName, $type,
> 					\%realmsServed,
> 					\%nodeServesRealms,
> 					\%realmBelongsToCommunity,
> 					);
> 			my $buildName = $monitorStats->applicationBuildName();
> 			push(@{$nodesUsingBuildRef->{$buildName}}, $instanceName) if ($buildName);
> 		}
> 
> 		foreach my $k (keys %nodeCount) {
> 			$queries{"Total number of nodes$k"} = {
> 				info => 1,
> 				perl => $nodeCount{$k},
> 				recordMaxResults => $maxResults,
> 				recordDataType => 'gauge',
> 				recordItem => 'answer',
> 			};
> 		}
> 
> 		unless ($productName =~ /^(an|arches)$/) {
> 			$queries{"Realm serving errors"} = {
> 				'rowCountLimit' => 4000,
> 				'noRowCount' => 1,
> 				'format' => "%5s: %15s: %15s: %15s",
> 				'info' => "numrows > -1",
> 				'skip' => $skip,
> 				'crit' => "answer =~ /^Error/ && previousAnswer =~ /^Error/",
> 				'warn' => "answer =~ /^Warn/",
>                                 'severity' => 0,
> 				'perl' => sub { main::realmServedStatus($product, \%realmsServed, \%nodeServesRealms, \%realmBelongsToCommunity); },
> 			};
> 		}
> 
> 		$queries{"Communities to nodes"} = {
> 			'noRowCount' => 1,
> 			'format' => "<html><td>%s</td><td>%s</td></html>",
> 			'info' => 1,
> 			'multiRow' => 1,
> 			'perl' => sub { 
> 				join("\n", 
> 						map { "$_:" . "\t" . join(", ", @{$communityToNodesHash{$_}}) } 
> 						sort(keys %communityToNodesHash)
> 					) 
> 			},
> 		};
> 
> 		my $expectedBuildName = ($product->isASPProduct() ? $product->baseBuildName() : $product->buildName());
> 		$queries{"Build being used by nodes"} = {
> 			'noRowCount' => 1,
> 			'info' => "numrows > -1",
> 			'skip' => $skip,
> 			'crit' => "numrows > 1 || answer !~ /$expectedBuildName/",
> 			'perl' => sub { main::buildNamesOnNodes($nodesUsingBuildRef); },
> 		};
> 
> 		unless ($productName eq 'an') {
> 			#
> 			# shuffle array elements, and pick the first one for monitoring
> 			# split cluster health
> 			#
> 			ariba::Ops::Utils::fisherYatesShuffle(\@instances);
> 			my $checkedInternodeResponseTime = 0;
> 			my %checkedCommunityInternodeResponseTime;
> 
> 			for my $instance (@instances) {
> 
> 				my $instanceName = $instance->workerName();
> 
> 				# check atleast three nodes for global communication health
> 				if ($checkedInternodeResponseTime < 3) {
> 					my $responseTimeUrl = $instance->internodesResponseTimeMonitorURL();
> 					my $responseTimes = ariba::monitor::Url->new($responseTimeUrl);
> 
> 					print "$instanceName responseTimeUrl = $responseTimeUrl\n" if ($debug > 1);
> 
> 					$responseTimes->setTimeout(180);
> 					my @responseTimeStats = $responseTimes->request();
> 					my $nodeResponses = nodeResponseTimes(\@responseTimeStats, $instanceName);
> 
> 					if ($log) {
> 						print LOG "$instanceName responseTimeUrl = $responseTimeUrl\n";
> 						print LOG "  ", join("  ", @responseTimeStats), "\n";
> 					}
> 
> 					$internodeCommunications{$instanceName} = $nodeResponses;
> 					$checkedInternodeResponseTime++;
> 				}
> 
> 				next unless ($product->numCommunities());
> 
> 				my $community = $instance->community() || 0;
> 
> 				next unless($community);
> 
> 				# check at least two nodes for community level internode
> 				# communication
> 				next if ($checkedCommunityInternodeResponseTime{$community} >= 2);
> 				unless (defined($checkedCommunityInternodeResponseTime{$community})) {
> 					$checkedCommunityInternodeResponseTime{$community} = 0;
> 				}
> 				$checkedCommunityInternodeResponseTime{$community}++;
> 
> 
> 				my $communityResponseTimeUrl = $instance->internodesResponseTimeMonitorURL(1);
> 				my $communityResponseTimes = ariba::monitor::Url->new($communityResponseTimeUrl);
> 				print "$instanceName community ($community) responseTimeUrl = $communityResponseTimeUrl\n" if ($debug > 1);
> 
> 				$communityResponseTimes->setTimeout(60);
> 				my @communityResponseTimeStats = $communityResponseTimes->request();
> 				my $communityNodeResponses = nodeResponseTimes(\@communityResponseTimeStats, $instanceName);
> 
> 				if ($log) {
> 					print LOG "$instanceName community ($community) responseTimeUrl = $communityResponseTimeUrl\n";
> 					print LOG "  ", join("  ", @communityResponseTimeStats), "\n";
> 				}
> 
> 				$communityInternodeCommunications{$community}->{$instanceName} = $communityNodeResponses;
> 			}
> 
> 			if ($log) {
> 				print LOG '=' x 72, "\n";
> 				close(LOG);
> 			}
> 
> 			my $expectedResponses = $numInstances - $downInstances;
> 			$queries{"Internode communication health"} = {
> 				'noRowCount' => 1,
> 				'skip' => $skip,
>                 'crit' => "answer !~ /^Info:/ && answer =~ /split cluster/ && previousAnswer !~ /^Info:/ && previousAnswer =~ /split cluster/",
> 				'info' => 1,
> 				'warn' => "answer =~ /^Warn/ || answer =~ /^Error/",
> 				'ticketOnWarnOpenAfterMinutes' => 180,
> 				'perl' => sub { main::consolidatedNodeResponseHealth(\%internodeCommunications, $expectedResponses); },
> 			};
> 
> 			for my $community (keys(%communityInternodeCommunications)) {
> 
> 				my $thisCommunityInternodeCommunication = $communityInternodeCommunications{$community};
> 				my $thisCommunitySSOClientState = $communitySSOClientState{$community};
> 
> 				my $numInstancesInCommunity = scalar(keys(%$thisCommunityInternodeCommunication));
> 				if ($community) {
> 					$community = "community $community";
> 				} else {
> 					$community = "default community";
> 				}
> 
> 				my $uiHint = "$community";
> 
> 				$queries{"Internode communication health for $community"} = {
> 					'noRowCount' => 1,
> 					'skip' => $skip,
> 					'info' => 1,
> 					'uiHint' => $uiHint,
> 					'warn' => "answer =~ /^Warn/ || answer =~ /^Error/",
> 					'ticketOnWarnOpenAfterMinutes' => 180,
> 					'perl' => sub { main::consolidatedNodeResponseHealth($thisCommunityInternodeCommunication, $numInstancesInCommunity); },
> 				};
> 
> 				if (defined($thisCommunitySSOClientState)) {
> 					for my $instanceName (keys %$thisCommunitySSOClientState) {
> 						$queries{"$instanceName SSO status"} = {
> 							'skip' => $skip,
> 							'uiHint' => $uiHint,
> 							'crit' => "!defined(answer) || answer =~ /^Server has LogoutProblem/i",
> 							'info' => 1,
> 							'perl' => sub {return $thisCommunitySSOClientState->{$instanceName}; },
> 						};
> 					}
> 				}
> 			}
> 		}
> 
> 
> 		for my $community (keys (%communities)) {
> 
> 			if ($shutdownTimePerCommunity{$community}) {
> 
> 				my $uiHint = "community $community";
> 
> 				unless ($productName eq 'an') {
> 					my %shutdownTime = %{$shutdownTimePerCommunity{$community}};
> 					foreach my $instanceName (keys(%shutdownTime)) {
> 
> 						$queries{"$instanceName, $uiHint, has been in a shutdown state"} = {
> 							'recordMaxResults' => 60000,
> 							'recordDataType' => "counter",
> 
> 							'info' => "!defined(answer) || answer eq '' || answer >= 0",
> 							# XXX CR 1-AHI1QJ, tmid: 60469 Making this ticketOnWarn until devs find a solution.  old values: warn=4*60, crit=6*60
> 							'warn' => "defined(answer) && answer >= 6*60",
> 							'crit' => "defined(answer) && answer >= 13*60",
> 							'ticketOnWarnOpenAfterMinutes' => 1,
> 							'uiHint' => $uiHint,
> 							'format' => "%d min\n",
> 
> 							'perl' => sub { return $shutdownTime{$instanceName}},
> 						};
> 					}
> 				}
> 
> 			}
> 		}
> 
> 		my $q = ariba::monitor::QueryManager->newWithDetails(
> 				"node-status", $product->name(), $service, $product->customer(), \%queries
> 				);
353,354c339
<         for my $community (keys (%communities))
<         {
---
> 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
356,394c341,342
<             if ($shutdownTimePerCommunity{$community})
<             {
< 
<                 my $uiHint = "community $community";
< 
<                 unless ($productName eq 'an')
<                 {
<                     my %shutdownTime = %{$shutdownTimePerCommunity{$community}};
<                     foreach my $instanceName (keys (%shutdownTime))
<                     {
< 
<                         $queries{"$instanceName, $uiHint, has been in a shutdown state"} = {
<                             'recordMaxResults' => 60000,
<                             'recordDataType'   => "counter",
< 
<                             'info' => "!defined(answer) || answer eq '' || answer >= 0",
< 
<                             # XXX CR 1-AHI1QJ, tmid: 60469 Making this ticketOnWarn until devs find a solution.  old values: warn=4*60, crit=6*60
<                             'warn'                         => "defined(answer) && answer >= 6*60",
<                             'crit'                         => "defined(answer) && answer >= 13*60",
<                             'ticketOnWarnOpenAfterMinutes' => 1,
<                             'uiHint'                       => $uiHint,
<                             'format'                       => "%d min\n",
< 
<                             'perl' => sub {return $shutdownTime{$instanceName}},
<                                                                                            };
<                     }
<                 }
< 
<             }
<         }
< 
<         my $q = ariba::monitor::QueryManager->newWithDetails("node-status", $product->name(), $service, $product->customer(), \%queries);
< 
<         ### Prints html output and hence not calling it
<         ###$q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         dmail::LockLib::releaselock($lockFile);
<     }
---
> 		dmail::LockLib::releaselock($lockFile);
> 	}
400c348
< # <monitorStatus>
---
> # <monitorStatus>    
437,471c385,416
< sub realmsServedByNode
< {
<     my $monitorStats                   = shift;
<     my $instanceName                   = shift;
<     my $appName                        = shift;
<     my $realmsServedHashRef            = shift;
<     my $nodeServesRealmsHashRef        = shift;
<     my $realmBelongsToCommunityHashRef = shift;
< 
<     my $realmsOnNode = $monitorStats->localRealms();
<     my $community = $monitorStats->community() || 0;
< 
<     #
<     # Go over list of realms assigned to this node and save the
<     # results in a global list
<     #
<     #site1 (14 - assigned); realm_aqs_1 (5 - enabled); realm_pd_1 (11 - enabled); realm_gpd_fr (10 - enabled); realm_platform_2 (8 - enabled); realm_pd_2 (12 - enabled); realm_aqs_2 (6 - enabled); realm_aqs_4 (2 - enabled)
< 
<     for my $realmDetail (split (/;/, $realmsOnNode))
<     {
<         #site1 (14 - assigned)
<         if ($realmDetail =~ m|\s*(\w+)\s*\((\d+).*(\w+)\)|)
<         {
<             my $realmName   = $1;
<             my $realmId     = $2;
<             my $realmStatus = $3;
< 
<             #
<             # add this node to the list of nodes serving this realm
<             #
<             push (@{$realmsServedHashRef->{$realmId}}, [$instanceName, $appName]);
<             push (@{$nodeServesRealmsHashRef->{$community}->{$instanceName}}, $realmId);
<             $realmBelongsToCommunityHashRef->{$realmId}->{$community} = 1;
<         }
<     }
---
> sub realmsServedByNode {
> 	my $monitorStats = shift;
> 	my $instanceName = shift;
>     my $appName = shift;
> 	my $realmsServedHashRef = shift;
> 	my $nodeServesRealmsHashRef = shift;
> 	my $realmBelongsToCommunityHashRef = shift;
> 
> 	my $realmsOnNode = $monitorStats->localRealms();
> 	my $community = $monitorStats->community() || 0;
> 
> 	#
> 	# Go over list of realms assigned to this node and save the 
> 	# results in a global list
> 	#
> 	#site1 (14 - assigned); realm_aqs_1 (5 - enabled); realm_pd_1 (11 - enabled); realm_gpd_fr (10 - enabled); realm_platform_2 (8 - enabled); realm_pd_2 (12 - enabled); realm_aqs_2 (6 - enabled); realm_aqs_4 (2 - enabled)
> 
> 	for my $realmDetail (split(/;/, $realmsOnNode)) {
> 		#site1 (14 - assigned)
> 		if ($realmDetail =~ m|\s*(\w+)\s*\((\d+).*(\w+)\)|) {
> 			my $realmName = $1;
> 			my $realmId = $2;
> 			my $realmStatus = $3;
> 
> 			#
> 			# add this node to the list of nodes serving this realm
> 			#
> 			push(@{$realmsServedHashRef->{$realmId}}, [$instanceName, $appName]);
> 			push(@{$nodeServesRealmsHashRef->{$community}->{$instanceName}}, $realmId);
> 			$realmBelongsToCommunityHashRef->{$realmId}->{$community} = 1;
> 		}
> 	}
474,551c419,487
< sub realmServedStatus
< {
<     my $product                        = shift;
<     my $realmsServedHashRef            = shift;
<     my $nodeServesRealmsHashRef        = shift;
<     my $realmBelongsToCommunityHashRef = shift;
<     my ($realmIdsRef, $ocError) = realmIdsForProduct($product);
< 
<     my %results;
< 
<     my @errors;
<     my @warns;
<     my $sep = "\t";
< 
<     return "Error $sep oracle $sep $ocError" if ($ocError);
< 
<     for my $id (sort {$a <=> $b} keys (%$realmIdsRef))
<     {
<         my $nodesArrayRef = $realmsServedHashRef->{$id};
<         my @nodeList      = map {$_->[0]} @$nodesArrayRef;
<         my @appTypeList   = map {$_->[1]} @$nodesArrayRef;
<         my $realmId       = $id;
<         my $realmState    = $realmIdsRef->{$id};
<         #
<         # count how many communities this realm belongs to
<         #
<         my @communities = keys (%{$realmBelongsToCommunityHashRef->{$realmId}});
<         if (@communities > 1)
<         {
<             my $communitiesString = join (", ", @communities);
<             push (@errors, "Error $sep realm $realmId $sep belongs to multiple communities $communitiesString");
<         }
<         #
<         # A realm in hardPurgeComplete state is not supposed
<         # to have any nodes serving it, so skip the next two tests
<         #
<         next if ($realmState eq "hardPurgeComplete");
<         #
<         # If there is no task node serving a realm,
<         # its in warn state
<         #
<         if (!grep /TaskCXML/, @appTypeList)
<         {
<             push (@warns, "Warn $sep realm $realmId $sep state $realmState $sep No Task node");
<         }
<         #
<         # If there is no UI node serving a realm,
<         # its in crit state
<         #
<         if (!grep /UI/, @appTypeList)
<         {
<             push (@errors, "Error $sep realm $realmId $sep state $realmState $sep No UI node");
<         }
< 
<     }
< 
<     my @communities = keys (%$nodeServesRealmsHashRef);
<     for my $community (@communities)
<     {
<         my @instances      = keys (%{$nodeServesRealmsHashRef->{$community}});
<         my $realmsArrayRef = undef;
<         for my $instanceName (@instances)
<         {
<             my $thisNodesRealmsArrayRef = $nodeServesRealmsHashRef->{$community}->{$instanceName};
<             unless ($realmsArrayRef)
<             {
<                 $realmsArrayRef = $nodeServesRealmsHashRef->{$community}->{$instanceName};
<             }
< 
<             # see if the contents of two arrays match
<             my $diffsRef = ariba::Ops::Utils::computeDifference($thisNodesRealmsArrayRef, $realmsArrayRef);
<             if (@$diffsRef > 0)
<             {
<                 my $errorString = "$instanceName: " . join (", ", @$diffsRef);
<                 push (@errors, "Error $sep community $community $sep Not all nodes in community $community serve same set of realms [$errorString]");
<             }
<         }
<     }
---
> sub realmServedStatus {
> 	my $product = shift; 
> 	my $realmsServedHashRef = shift;
> 	my $nodeServesRealmsHashRef = shift;
> 	my $realmBelongsToCommunityHashRef = shift;
> 	my ($realmIdsRef, $ocError) = realmIdsForProduct($product); 
> 
> 	my %results;
> 
> 	my @errors;
> 	my @warns;
> 	my $sep = "\t";
> 
> 	return "Error $sep oracle $sep $ocError" if ($ocError); 
> 
> 	for my $id ( sort { $a <=> $b } keys(%$realmIdsRef) ) {
> 		my $nodesArrayRef = $realmsServedHashRef->{$id};
>         my @nodeList = map { $_->[0] } @$nodesArrayRef;
>         my @appTypeList = map { $_->[1] } @$nodesArrayRef;
> 		my $realmId = $id;
> 		my $realmState = $realmIdsRef->{$id};
> 		#
> 		# count how many communities this realm belongs to
> 		#
> 		my @communities = keys(%{$realmBelongsToCommunityHashRef->{$realmId}});
> 		if (@communities > 1) {
> 			my $communitiesString = join(", ", @communities);
> 			push(@errors, "Error $sep realm $realmId $sep belongs to multiple communities $communitiesString");
> 		}
> 		#
> 		# A realm in hardPurgeComplete state is not supposed
> 		# to have any nodes serving it, so skip the next two tests
> 		#
> 		next if ($realmState eq "hardPurgeComplete");
> 		#
> 		# If there is no task node serving a realm,
> 		# its in warn state
> 		#
> 		if (!grep /TaskCXML/, @appTypeList) {
> 			push(@warns, "Warn $sep realm $realmId $sep state $realmState $sep No Task node");
> 		}
> 		#
> 		# If there is no UI node serving a realm,
> 		# its in crit state
> 		#
> 		if (!grep /UI/, @appTypeList) {
> 			push(@errors, "Error $sep realm $realmId $sep state $realmState $sep No UI node");
> 		}
> 
> 	}
> 
> 	my @communities = keys(%$nodeServesRealmsHashRef);
> 	for my $community ( @communities ) {
> 		my @instances = keys(%{$nodeServesRealmsHashRef->{$community}});
> 		my $realmsArrayRef = undef;
> 		for my $instanceName (@instances) {
> 			my $thisNodesRealmsArrayRef = $nodeServesRealmsHashRef->{$community}->{$instanceName};
> 			unless($realmsArrayRef) {
> 				$realmsArrayRef = $nodeServesRealmsHashRef->{$community}->{$instanceName};
> 			}
> 
> 			# see if the contents of two arrays match
> 			my $diffsRef = ariba::Ops::Utils::computeDifference($thisNodesRealmsArrayRef, $realmsArrayRef);
> 			if (@$diffsRef > 0) {
> 				my $errorString = "$instanceName: " . join(", ", @$diffsRef);
> 				push(@errors, "Error $sep community $community $sep Not all nodes in community $community serve same set of realms [$errorString]");
> 			}
> 		}
> 	}
553c489
<     return (join ("\n", @errors, @warns));
---
> 	return (join("\n", @errors, @warns));
574,597c510,529
< #
< sub nodeResponseTimes
< {
<     my $results      = shift;
<     my $instanceName = shift;
< 
<     my %nodeResponses;
< 
<     for my $line (@$results)
<     {
<         if ($line =~ m|<Node name="([^"]*)" time="([^"]*)"/>|)
<         {
<             my $nodeName = $1;
<             my $time     = $2;
< 
<             if ($nodeName eq "Local")
<             {
<                 $nodeName = $instanceName;
<                 next;
<             }
< 
<             $nodeResponses{$nodeName} = $time;
<         }
<     }
---
> # 
> sub nodeResponseTimes {
> 	my $results = shift;
> 	my $instanceName = shift;
> 
> 	my %nodeResponses;
> 
> 	for my $line (@$results) {
> 		if ($line =~ m|<Node name="([^"]*)" time="([^"]*)"/>|) {
> 			my $nodeName = $1;
> 			my $time = $2;
> 
> 			if ($nodeName eq "Local") {
> 				$nodeName = $instanceName;
> 				next;
> 			}
> 
> 			$nodeResponses{$nodeName} = $time;
> 		}
> 	}
599c531
<     return \%nodeResponses;
---
> 	return \%nodeResponses;
602,654c534,577
< sub consolidatedNodeResponseHealth
< {
<     my $globalNodeResponseHashRef = shift;
<     my $totalNumNodes             = shift;
<     my $timeout                   = shift;
< 
<     my @errors = ();
<     my @warns  = ();
<     my @infos  = ();
< 
<     # Build list of common timed out nodes
<     my %commonTimedoutNodes;
<     my $numNodes = scalar (keys (%$globalNodeResponseHashRef));
<     for my $instanceName (keys (%$globalNodeResponseHashRef))
<     {
<         my $nodeResponseRef = $globalNodeResponseHashRef->{$instanceName};
<         foreach my $nodeName (keys (%$nodeResponseRef))
<         {
<             my $responseTime = $nodeResponseRef->{$nodeName};
<             if ($responseTime == -1 || defined ($timeout) && $responseTime > $timeout)
<             {
<                 $commonTimedoutNodes{$nodeName}++;
<             }
<         }
<     }
<     foreach my $nodeName (keys (%commonTimedoutNodes))
<     {
<         my $numTimedoutNodes = $commonTimedoutNodes{$nodeName};
<         delete ($commonTimedoutNodes{$nodeName}) unless ($numTimedoutNodes == $numNodes);
<     }
< 
<     for my $instanceName (sort (keys (%$globalNodeResponseHashRef)))
<     {
<         my ($errorArrayRef, $warnArrayRef, $infoArrayRef) = checkNodeResponseTimes($globalNodeResponseHashRef->{$instanceName}, $totalNumNodes, $timeout, \%commonTimedoutNodes);
<         if (scalar (@$errorArrayRef))
<         {
<             my $resultString = "Error: Ping request from $instanceName " . join (", ", @$errorArrayRef, @$warnArrayRef, @$infoArrayRef);
<             push (@errors, $resultString);
<             next;
<         }
<         if (scalar (@$warnArrayRef))
<         {
<             my $resultString = "Warn: Ping request from $instanceName " . join (", ", @$warnArrayRef, @$infoArrayRef);
<             push (@warns, $resultString);
<             next;
<         }
<         if (scalar (@$infoArrayRef))
<         {
<             my $resultString = "Info: Ping request from $instanceName " . join (", ", @$infoArrayRef);
<             push (@infos, $resultString);
<             next;
<         }
<     }
---
> sub consolidatedNodeResponseHealth {
> 	my $globalNodeResponseHashRef = shift;
> 	my $totalNumNodes = shift;
> 	my $timeout = shift;
> 
> 	my @errors = ();
> 	my @warns = ();
> 	my @infos = ();
> 
> 	# Build list of common timed out nodes
> 	my %commonTimedoutNodes;
> 	my $numNodes = scalar(keys(%$globalNodeResponseHashRef));
> 	for my $instanceName (keys(%$globalNodeResponseHashRef)) {
> 		my $nodeResponseRef = $globalNodeResponseHashRef->{$instanceName};
> 		foreach my $nodeName (keys(%$nodeResponseRef)) {
> 			my $responseTime = $nodeResponseRef->{$nodeName};
> 			if ($responseTime == -1 || defined($timeout) && $responseTime > $timeout) {
> 				$commonTimedoutNodes{$nodeName}++ 
> 			}
> 		}
> 	}
> 	foreach my $nodeName (keys(%commonTimedoutNodes)) {
> 		my $numTimedoutNodes = $commonTimedoutNodes{$nodeName};
> 		delete($commonTimedoutNodes{$nodeName}) unless ($numTimedoutNodes == $numNodes);
> 	}
> 
> 	for my $instanceName (sort(keys(%$globalNodeResponseHashRef))) {
> 		my ($errorArrayRef, $warnArrayRef, $infoArrayRef) = checkNodeResponseTimes($globalNodeResponseHashRef->{$instanceName}, $totalNumNodes, $timeout, \%commonTimedoutNodes);
> 		if (scalar(@$errorArrayRef)) {
> 			my $resultString = "Error: Ping request from $instanceName " .  join(", ", @$errorArrayRef, @$warnArrayRef, @$infoArrayRef);
> 			push(@errors, $resultString);
> 			next;
> 		}
> 		if (scalar(@$warnArrayRef)) {
> 			my $resultString = "Warn: Ping request from $instanceName " .  join(", ", @$warnArrayRef, @$infoArrayRef);
> 			push(@warns, $resultString);
> 			next;
> 		}
> 		if (scalar(@$infoArrayRef)) {
> 			my $resultString = "Info: Ping request from $instanceName " .  join(", ", @$infoArrayRef);
> 			push(@infos, $resultString);
> 			next;
> 		}
> 	}
656c579
<     return (join ("\n", @errors, @warns, @infos));
---
> 	return (join("\n", @errors, @warns, @infos));
659,754c582,662
< sub checkNodeResponseTimes
< {
<     my $nodeResponseTimeHashRef = shift;
<     my $totalNumNodes           = shift;
<     my $timeout                 = shift;
<     my $commonTimedoutNodesRef  = shift;
< 
<     my @results;
< 
<     my @keys         = sort (keys (%$nodeResponseTimeHashRef));
<     my $numResponses = scalar (@keys);
< 
<     my @errors = ();
<     my @warns  = ();
<     my @infos  = ();
< 
<     my $warn = 5;
<     my $crit = 10;
< 
<     my $differenceInExpectedResponses = $totalNumNodes - $numResponses;
< 
<     #
<     # in case one of the nodes is going down, some nodes get more
<     # responses than we expect
<     #
<     if ($differenceInExpectedResponses < 0)
<     {
<         $differenceInExpectedResponses = 0;
<     }
< 
<     my $message;
< 
<     $message = "missing $differenceInExpectedResponses responses (split cluster?)";
<     if ($differenceInExpectedResponses > $crit)
<     {
<         push (@errors, $message);
<     }
<     elsif ($differenceInExpectedResponses > $warn)
<     {
<         push (@warns, $message);
<     }
<     elsif ($differenceInExpectedResponses && $differenceInExpectedResponses <= $warn)
<     {
<         push (@infos, $message);
<     }
< 
<     my @timeOuts;
<     my $treatTimeoutAsCrit = 0;
<     for my $instanceName (@keys)
<     {
<         my $responseTime = $nodeResponseTimeHashRef->{$instanceName};
<         if (exists $commonTimedoutNodesRef->{$instanceName})
<         {
<             $treatTimeoutAsCrit = 1;
<             $instanceName       = "*$instanceName";
<         }
<         if (defined ($timeout) && $responseTime > $timeout)
<         {
<             push (@timeOuts, "$instanceName $responseTime");
<         }
<         if ($responseTime == -1)
<         {
<             push (@timeOuts, "$instanceName");
<         }
<     }
< 
<     my $numTimeOuts = scalar (@timeOuts);
<     my $timedOutNodes = join (", ", @timeOuts);
<     $message = "timedout for: $timedOutNodes";
<     if ($treatTimeoutAsCrit && $numTimeOuts > $crit)
<     {
<         push (@errors, $message);
<     }
<     elsif ($numTimeOuts > $warn)
<     {
<         push (@warns, $message);
<     }
<     elsif ($numTimeOuts && $numTimeOuts <= $warn)
<     {
<         push (@infos, $message);
<     }
<     my $allResponses = join (", ", @keys);
< 
<     if ($differenceInExpectedResponses)
<     {
<         push (@infos, "responses from: $allResponses");
<     }
<     else
<     {
<         push (@infos, "responses from: all nodes");
<     }
< 
<     if (!$numTimeOuts && !$differenceInExpectedResponses)
<     {
<         #push(@infos, "is healthy");
<     }
---
> sub checkNodeResponseTimes {
> 	my $nodeResponseTimeHashRef = shift;
> 	my $totalNumNodes = shift;
> 	my $timeout = shift;
> 	my $commonTimedoutNodesRef = shift;;
> 
> 	my @results;
> 
> 	my @keys = sort(keys(%$nodeResponseTimeHashRef));
> 	my $numResponses = scalar(@keys);
> 
> 	my @errors = ();
> 	my @warns = ();
> 	my @infos = ();
> 
> 	my $warn = 5;
> 	my $crit = 10;
> 
> 	my $differenceInExpectedResponses = $totalNumNodes - $numResponses;
> 
> 	#
> 	# in case one of the nodes is going down, some nodes get more
> 	# responses than we expect
> 	#
> 	if ($differenceInExpectedResponses < 0) {
> 		$differenceInExpectedResponses = 0;
> 	}
> 
> 	my $message;
> 
> 	$message = "missing $differenceInExpectedResponses responses (split cluster?)";
> 	if ($differenceInExpectedResponses > $crit) {
> 		push(@errors, $message);
> 	} elsif ($differenceInExpectedResponses  > $warn) {
> 		push(@warns, $message);
> 	} elsif ($differenceInExpectedResponses && $differenceInExpectedResponses  <= $warn) {
> 		push(@infos, $message);
> 	}
> 
> 	my @timeOuts;
> 	my $treatTimeoutAsCrit = 0;
> 	for my $instanceName (@keys) {
> 		my $responseTime = $nodeResponseTimeHashRef->{$instanceName};
> 		if (exists $commonTimedoutNodesRef->{$instanceName}) {
> 			$treatTimeoutAsCrit = 1;
> 			$instanceName = "*$instanceName"; 
> 		}
> 		if (defined($timeout) && $responseTime > $timeout) {
> 			push(@timeOuts, "$instanceName $responseTime");
> 		}
> 		if ($responseTime == -1) {
> 			push(@timeOuts, "$instanceName");
> 		}
> 	}
> 
> 	my $numTimeOuts = scalar(@timeOuts);
> 	my $timedOutNodes = join(", ", @timeOuts);
> 	$message = "timedout for: $timedOutNodes";
> 	if ($treatTimeoutAsCrit && $numTimeOuts > $crit) {
> 		push(@errors, $message);
> 	} elsif ($numTimeOuts > $warn) {
> 		push(@warns, $message);
> 	} elsif ($numTimeOuts && $numTimeOuts <= $warn) {
> 		push(@infos, $message);
> 	}
> 	my $allResponses = join(", ", @keys);
> 
> 	if ($differenceInExpectedResponses) {
> 		push(@infos, "responses from: $allResponses");
> 	} else {
> 		push(@infos, "responses from: all nodes");
> 	}
> 
> 	if(!$numTimeOuts && !$differenceInExpectedResponses) {
> 		#push(@infos, "is healthy");
> 	}
> 
> 	my @empty = ();
> 	#return(\@errors, \@warns, \@empty);
> 	return(\@errors, \@warns, \@infos);
> }
756c664,665
<     my @empty = ();
---
> sub buildNamesOnNodes {
> 	my $nodesUsingBuildRef = shift;
758,760c667
<     #return(\@errors, \@warns, \@empty);
<     return (\@errors, \@warns, \@infos);
< }
---
> 	my @results;
762,781c669,671
< sub realmIdsForProduct
< {
<     my $product = shift;
<     my %realmStatus;
< 
<     my $oc = ariba::Ops::OracleClient->new($product->connectInfoForOracleClient());
<     if ($oc->connect())
<     {
<         my @results;
<         $oc->executeSqlWithTimeout("select id, state from realmtab", 30, \@results);
<         unless ($oc->error())
<         {
<             my $colsep = ariba::Ops::OracleClient->colsep();
<             foreach my $result (@results)
<             {
<                 my ($id, $status) = split (/$colsep/, $result);
<                 $realmStatus{$id} = $status;
<             }
<         }
<     }
---
> 	for my $buildName (reverse(sort(keys%$nodesUsingBuildRef))) {
> 		push (@results, "$buildName: ". join(", ", @{$nodesUsingBuildRef->{$buildName}}));
> 	}
783c673
<     return (\%realmStatus, $oc->error());
---
> 	return (join("\n", @results));
785a676,695
> sub realmIdsForProduct { 
> 	my $product = shift; 
> 	my %realmStatus;
> 
> 	my $oc = ariba::Ops::OracleClient->new($product->connectInfoForOracleClient()); 
> 	if ($oc->connect()) { 
> 		my @results; 
> 		$oc->executeSqlWithTimeout("select id, state from realmtab", 30, \@results); 
> 		unless($oc->error()) {
> 			my $colsep = ariba::Ops::OracleClient->colsep();
> 			foreach my $result (@results) {
> 				my ($id, $status) = split(/$colsep/, $result);
> 				$realmStatus{$id} = $status;
> 			}
> 		}
> 	} 
> 
> 	return (\%realmStatus, $oc->error()); 
> } 
> 
87,88c87,88
<    		my @instances;
<                 if ($productName eq 'an') { 
---
> 	        my @instances;
>                 if ($productName eq 'an') {
102,103c102
< 		my @comhash;
< 		my @bhash;
---
> 
107c106
< 			$nodeCount{'Total'}++;
---
> 			$nodeCount{''}++;
109c108,109
< 			$nodeCount{"$type"}++;
---
> 			$nodeCount{" of type $type"}++;
> 
111d110
< 			push @comhash, {'community' => $community, 'node' => $instance->workerName()};
138,141c137
< 			my $expectedBuildName = ($product->isASPProduct() ? $product->baseBuildName() : $product->buildName());
< 			my $bustat = 0;
< 			if( $buildName ne $expectedBuildName) { $bustat = 1;}
< 			push(@bhash, {'buildname' => $buildName,'build_status' => $bustat, 'node' => $instanceName, 'community' => $community}) if ($buildName);
---
> 			push(@{$nodesUsingBuildRef->{$buildName}}, $instanceName) if ($buildName);
143c139
< 		my %squeries;
---
> 
145c141
< 			$squeries{"Total number of nodes $k"} = {
---
> 			$queries{"Total number of nodes$k"} = {
147,154c143,146
< 				perl => sub { return $nodeCount{$k};},
<                             	recordMaxResults => $maxResults,
<     				recordDataType => 'gauge',
<     				recordItem => 'answer',
< 				'inf_field' => "node_count",
< 				'inf_default' => 0,
< 			        'inf_tags' =>  "node_type=\"$k\"",
< 				'group_by' => $k
---
> 				perl => $nodeCount{$k},
> 				recordMaxResults => $maxResults,
> 				recordDataType => 'gauge',
> 				recordItem => 'answer',
158,164d149
< 		$squeries{"influx_details"} = { 'measurement' => "node_status_summary" };
< 		my $q = ariba::monitor::QueryManager->newWithDetails(
< 				"node-status", $product->name(), $service, $product->customer(), \%squeries
< 				);
< 
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
179,189c164,174
< 			$queries{"Communities to nodes"} = {
<     				'noRowCount' => 1,
<     				'format' => "<html><td>%s</td><td>%s</td></html>",
<     				'info' => 1,
<     				'multiRow' => 1,
<     				'perl' => sub {
<     						join("\n",
<   						map { "$_:" . "\t" . join(", ", @{$communityToNodesHash{$_}}) }
<     						sort(keys %communityToNodesHash)
<     						)
<     			},
---
> 		$queries{"Communities to nodes"} = {
> 			'noRowCount' => 1,
> 			'format' => "<html><td>%s</td><td>%s</td></html>",
> 			'info' => 1,
> 			'multiRow' => 1,
> 			'perl' => sub { 
> 				join("\n", 
> 						map { "$_:" . "\t" . join(", ", @{$communityToNodesHash{$_}}) } 
> 						sort(keys %communityToNodesHash)
> 					) 
> 			},
192,193d176
< 
< 		my %bqueries;
195c178
< 		$bqueries{"Build being used by nodes"} = {
---
> 		$queries{"Build being used by nodes"} = {
200,202c183
< 			'inf_field' => 'hash',
< 			'inf_sort' => 2,
< 			'perl' => sub { return \@bhash; },
---
> 			'perl' => sub { main::buildNamesOnNodes($nodesUsingBuildRef); },
204,209d184
< 		$bqueries{"influx_details"} = { 'measurement' => "node_status_build" };
<  		my $q = ariba::monitor::QueryManager->newWithDetails(
<  	                "node-status", $product->name(), $service, $product->customer(), \%bqueries
<  	                );
< 
<  		$q->processQueries($debug, $email, $sendEmail, $sendPage);
688a664,675
> sub buildNamesOnNodes {
> 	my $nodesUsingBuildRef = shift;
> 
> 	my @results;
> 
> 	for my $buildName (reverse(sort(keys%$nodesUsingBuildRef))) {
> 		push (@results, "$buildName: ". join(", ", @{$nodesUsingBuildRef->{$buildName}}));
> 	}
> 
> 	return (join("\n", @results));
> }
> 
filename:./bin/common/product-filesystem-check
54,60c54,56
< 					'info'		    => "answer eq '$YES'",
< 					'crit'		    => "answer ne '$YES'",
< 					'perl'		    => sub { return main::checkDirForContents($realmRoot); },
<                     'inf_field' 	=> "content_exists",
<                     'inf_tags'  	=> "realm_root=\"$realmRoot\"",
<                     'inf_default' 	=> 'none',
< 					'group_by'   	=> $realmRoot,
---
> 					'info'		=> "answer eq '$YES'",
> 					'crit'		=> "answer ne '$YES'",
> 					'perl'		=> sub { return main::checkDirForContents($realmRoot); },
65,71c61,63
< 				'info'		    => "answer eq '$YES'",
< 				'crit'		    => "answer ne '$YES'",
< 				'perl'		    => sub { return main::checkDirForContents($filesystemRoot); },
<                 'inf_field' 	=> "content_exists",
<                 'inf_tags'  	=> "filesystem_root=\"$filesystemRoot\"",
<                 'inf_default' 	=> 'none',
< 			    'group_by'   	=> $filesystemRoot,
---
> 				'info'		=> "answer eq '$YES'",
> 				'crit'		=> "answer ne '$YES'",
> 				'perl'		=> sub { return main::checkDirForContents($filesystemRoot); },
50,51c50
< 			for my $realmId_hash (@$realmIdsRef) { 
< 				my $realmId = $realmId_hash->{'ID'};
---
> 			for my $realmId (@$realmIdsRef) { 
75d65
<         	$queries{influx_details} = { measurement => 'file_system' };
filename:./bin/common/realm-community-mapping
107,112c107,112
<     #$queries{"Realms affected by communities down (Community ID, Realm ID, Name, Label, State)"} = {
<     #    'rowCountLimit' => 8000,
<     #    'info'          => "numrows > -1",
<     #    'warn'          => "numrows > 1",
<     #    'sql'           => $sql,
<     #};
---
>     $queries{"Realms affected by communities down (Community ID, Realm ID, Name, Label, State)"} = {
>         'rowCountLimit' => 8000,
>         'info'          => "numrows > -1",
>         'warn'          => "numrows > 1",
>         'sql'           => $sql,
>     };
134c134
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
143c143
<     return "select c.CommunityId community , r.Id realm_id, r.Name realm_name, r.Label label,r.State state from CommunityTab c, RealmTab r where r.Id = c.RealmId$versionClause$extraClause order by c.CommunityId, r.Label";
---
>     return "select c.CommunityId, r.Id, r.Name, r.Label,r.State from CommunityTab c, RealmTab r where r.Id = c.RealmId$versionClause$extraClause order by c.CommunityId, r.Label";
118,120d117
< 	'inf_field' => "hash",
< 	'inf_default' => 'none',
< 	'inf_sort' => 0,
123,124d119
<     $queries{"influx_details"} = { 'measurement' => "realm_community_mapping" };
< 
filename:./bin/common/realm-delete-status
77d76
< 			'inf_field' => "delete_check_time",
79c78
< 			'processAnswer' => sub { return (main::statusOfRealmDeletion("CheckTime", \@response)); },
---
> 			'processAnswer' => sub { return ariba::Ops::DateTime::scaleTime(main::statusOfRealmDeletion("CheckTime", \@response)); },
85,86d83
< 			'inf_field' => "purge_status",
< 			'inf_default' => "none",
92,93d88
< 			'inf_field' => "hard_delete_status",
< 			'inf_default' => "none",
100,101d94
< 			'inf_field' => "wrong_delete_status",
< 			'inf_default' => "none",
108a102
> 
111d104
< 	$queries{"influx_details"} = { 'measurement' => "realm_delete_status" };
127c120
< 			push(@results, '"'.$1.'"');
---
> 			push(@results, $1);
135c135
< 		return "OK";
---
> 		return undef;
140,141c140
<         my $time = ariba::Ops::DateTime::scaleTime(time() - $results[0]);
< 		return $time;
---
> 		return (time() - $results[0]);
filename:./bin/common/realm-schema-mapping
74,75d73
<         inf_field => "status",
<         inf_default => "none",
79d77
< 	$queries{"influx_details"} = { 'measurement' => "realm_schema_mapping"};
172c170,176
< 		return \@results;
---
> 		my $colsep = $dbc->colsep();
> 		foreach my $result (@results) {
> 			my ($a_realmid, $b_realmname, $a_schematype, $a_databaseschema, $a_isprimary) = split(/$colsep/,$result);
> 			my ($dbtype, $schema) = split(/\.Schema/, $a_databaseschema);
> 			my $sid = $schemaSid{int($schema)};
> 			$realmResults .= "$a_realmid\t$b_realmname\t$a_databaseschema\t$sid\n";
> 		}
filename:./bin/common/ws-cert-expire
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
71,72d70
< 
<                 $queries{"influx_details"} = { 'measurement' => "ws_cert_expire"};
109,112d106
<         inf_field => "days_to_expire",
<         inf_tags => "cert=\"$file\"",
<         group_by => "$file",
<         inf_default => 0
filename:./bin/control-deployment
filename:./bin/everywhere/httpd-process-watcher
13c13
< use lib "$FindBin::Bin/../../lib";
---
> use lib "$FindBin::Bin/../lib";
138,141d137
<             'inf_field' => "connections",
<             'inf_default' => 0,
<             'inf_tags'   => "hostname=\"$hostname\"",
<             'group_by'  => $hostname,
151,154d146
<             'inf_field' => "total_private_memory_size",
<             'inf_default' => 0,
<             'inf_tags'   => "hostname=\"$hostname\"",
<             'group_by'  => $hostname,
167,170d158
<             'inf_field' => "avg_private_memory_size",
<             'inf_default' => 0,
<             'inf_tags'   => "hostname=\"$hostname\"",
<             'group_by'  => $hostname,
178,181d165
<             'inf_field' => "avg_shared_memory_size",
<             'inf_default' => 0,
<             'inf_tags'   => "hostname=\"$hostname\"",
<             'group_by'  => $hostname,
189,192d172
<             'inf_field' => "avg_rss_memory_size",
<             'inf_default' => 0,
<             'inf_tags'   => "hostname=\"$hostname\"",
<             'group_by'  => $hostname,
204,207d183
<             'inf_field' => "total_cpu_usage_percent",
<             'inf_default' => 0,
<             'inf_tags'   => "hostname=\"$hostname\"",
<             'group_by'  => $hostname,
214d189
<     $queries{influx_details} = { measurement => 'httpd_process_watcher' }; 
216c191
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->run();
222c197
< 		my $monserver = ($me->hostsForRoleInCluster('monitor', $me->currentCluster()))[0] || ($me->hostsForRoleInCluster('monserver', $me->currentCluster()))[0];
---
> 		my $monserver = ($me->hostsForRoleInCluster('monitor', $me->currentCluster()))[0];
filename:./bin/geturl
filename:./bin/hadoop/checkpoint-health
131d130
<     $queries{"influx_details"} = {measurement => "hadoop_checkpoint"};
100,103c100
<             ],
<             inf_field => "checkpoint_fsimage_last_mod",
<             inf_default => "none",
<             inf_tags => "host=\"$host\"",
---
>             ]
123,126c120
<         ],
<         inf_field => "checkpoint_fsimage_validation",
<         inf_default => "none",
<         inf_tags => "host=\"$host\"",
---
>         ]
131,132d124
<     my $inf_measurement = "hadoop_checkpoint";
<     $queries{"influx_details"} = {measurement => $inf_measurement,};
134c126
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/cleanup-hbase-snapshots
122,123d121
<         inf_field => "oldest_snapshot_date",
<         inf_default => "none",
127d124
<     $queries{influx_details} = {measurement => "cleanup_habse_snapshot",};
130c127
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/hbase-status
140,144c140
<                 ],
<                 inf_field => "number_of_regions",
<                 inf_tags => qq|table="$table"|,
<                 inf_default => "none",
<                 group_by => $table,
---
>                 ]
168d163
<     $queries{influx_details} = {measurement => "hbase_status"};
120,122c120
<             ],
<             inf_field => "Hbase_database_check",
<             inf_default => "none",
---
>             ]
140,144c138
<                 ],
<                 inf_fields => "number_of_regions",
<                 inf_tags => qq|table="$table"|,
<                 inf_default => "none",
<                 group_by => $table,
---
>                 ]
161,163c155
<             ],
<             inf_field => "Hbase_master_status",
<             inf_default => "none",
---
>             ]
168,170d159
<     my $inf_measurement = "hbase_status",
<     my $inf_tags = "product=hadoop,service=".$me->service();
<     $queries{influx_details} = {measurement => $inf_measurement};
173c162
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/hdfs-export
58,59c58,59
<     exit unless (ariba::rc::InstalledProduct->isInstalled('hadoop', 'dev'));
<     my $hadoop = ariba::rc::InstalledProduct->new('hadoop', 'dev');
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled('hadoop', $me->service()));
>     my $hadoop = ariba::rc::InstalledProduct->new('hadoop', $me->service());
147,149d146
<             inf_field => "snapshot",
<             inf_tags => qq|table="$table"|,
<             inf_default => "none",
154d150
<     $queries{influx_details} = {measurement => "hdfs_export"};
157c153
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/hdfs-health
464,466d461
<         (my $inf_field = "$queryNamePrefix $queryName") =~ s/^\s*(.*?)$/$1/;
<         $inf_field =~ s/\s+/_/g;
< 
475,477d469
<             inf_field => $inf_field,
<             inf_default => "none",
<             group_by => "1", 
107,109c107
<             ],
<             inf_field => "file_system_check",
<             inf_default => "none",
---
>             ]
124,127c122
<             ],
<             inf_field => "file_system_check",
<             inf_default => "none",
<             inf_tags => qq|host="$host"|,
---
>             ]
138,139d132
<             inf_field => "missing_replicas",
<             inf_default => "none",
147,148d146
<     $queries{"influx_details"} = {measurement => "hdfs_health"};
< 
147,150d139
<     my $inf_measurement = "hdfs_health";
<     my $inf_tags = qq|product=hadoop,service=|.$me->service();
<     $queries{"influx_details"} = {measurement => $inf_measurement};
< 
153c142
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
474,476d462
<             inf_field => "${queryNamePrefix}_$queryName",
<             inf_default => "none",
<             group_by => "$name", 
filename:./bin/hadoop/hdfs-replication
125d124
<         $queriesHealth{"influx_details"} = {measurement => "hdfs_replication"};
119,121d118
<                     inf_field => "${rhost}_$metric",
<                     inf_default => "none",
<                     inf_tags => "host=$rhost",
125,126d121
<         my $inf_measurement = "hdfs_replication";
<         $queriesHealth{"influx_details"} = {measurement => $inf_measurement};
128c123
<         $qmHealth->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qmHealth->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/heap-usage
102,105d101
<                 inf_field => "vm_heap_usage_in_KB",
<                 inf_default => "none",
<                 inf_tags => qq|intanceName="$instanceName"|,
<                 group_by => $instanceName,
110,111d105
<         my $inf_measurement = "heap_usage";
<         $queries{"influx_details"} = {measurement => $inf_measurement,};
110d109
<         $queries{"influx_details"} = {measurement => "heap_usage"};
filename:./bin/hadoop/job-status
55,58c55,56
<     #exit unless (ariba::rc::InstalledProduct->isInstalled('hadoop', $me->service()));
<     exit unless (ariba::rc::InstalledProduct->isInstalled('hadoop', 'dev'));
<     #my $hadoop = ariba::rc::InstalledProduct->new('hadoop', $me->service());
<     my $hadoop = ariba::rc::InstalledProduct->new('hadoop', 'dev');
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled('hadoop', $me->service()));
>     my $hadoop = ariba::rc::InstalledProduct->new('hadoop', $me->service());
78,79d75
<         inf_field => "failed_jobs_in_last_hour",
<         inf_default => 0, 
82,83d77
< 
< 
83d82
<     $queries{"influx_details"} = {measurement => "MapReduce_Status"};
89c81
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/mr-health
78,79d77
<         inf_field => "\"Number of Running Jobs\"",
<         inf_default => "none",
83d82
<     $queries{influx_details} = {measurement => "mr_health"};
87c83
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
230,232d225
<                     inf_field => qq|"$queryNamePrefix $queryName"|,
<                     inf_default => "none",
<                     group_by => $uiHint,
filename:./bin/hadoop/name-node-consistency
20,23c20,23
<      'DeadNodes'  => 1,
<      'DecomNodes' => 1,
<  );
<  
---
>     'DeadNodes'  => 1,
>     'DecomNodes' => 1,
> );
> 
25,27c25,27
<      my $error = shift; 
<  
<      print <<USAGE;
---
>     my $error = shift; 
> 
>     print <<USAGE;
29c29
< Sends Hadoop nameNode Consistency check information to monitoring.    
---
> Sends Hadoop nameNode Consistency check information to monitoring.
81,83d80
<             inf_field => "name_node_consistency",
<             inf_default => "none",
<             inf_tags => qq|field="$field"|,
89,90d88
<     $queries{"influx_details"} = {measurement => "name_node_consistence"};
< 
93c87
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/node-status
101,104d100
<                     inf_field => "hbase_master_status_hash",
<                     inf_default => "none",
<                     inf_tags => qq|host="$host"|,
<                     group_by => $host,
138,141d133
<                 inf_field => "hadoop_namenode_status_hash",
<                 inf_default => "none",
<                 inf_tags => qq|host="$nnHost",namenode="$nn"|,
<                 group_by => "$nnHost-$nn",
184,187d175
<                 inf_field => "hadoop_namenode_status_hash",
<                 inf_default => "none",
<                 inf_tags => qq|host="$jtHost",namenode="$jt"|,
<                 group_by => "$jtHost-$jt",
194,195d193
<     $queries{"infux_details"} = {measurement => "hadoop_node_health"};
< 
198c183
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/veritas-cluster-status
96,100c96
<             ],
<             inf_field => "status",
<             inf_default => "none",
<             inf_tags => qq|node="$nodeName"|,
<             group_by => $nodeName,
---
>             ]
105d104
<     $queries{influx_details} = {measurement => "verritas_cluster_status" };
109c103
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/hadoop/zookeeper-status
84,87d83
<                 'inf_field' => 'ZooKeeperStatus',
<                 'inf_default'=>'none',
<                 'inf_tags'=> sprintf("instance_name=\"%s\",cluster=\"%s\"", $instance->instanceName(), $cluster),
<                 'group_by' => $instance->instanceName(),
90,91d85
<     
< 
94,97c88
<         $queries{"influx_details"} = {
<             'measurement' => "migrate_hadoop",
<             'tags'=> "product=Hadoop,service=".$me->service(),
<         };
---
> 
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
94,96c94
<         $queries{"influx_details"} = {
<             'measurement' => "zookeeper",
<         };
---
> 
filename:./bin/mobile/an-mobile-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/tools/perl-5.22.1/bin/perl
23,25d22
< # This will load the "new" Perl Jolokia/JMX support.  It *must* follow *all* the other 'use' statements so it doesn't accidentally
< # pull in any modules that should be for/from the 'old' perl.
< use lib "/usr/local/tools/lib/perl5/site_perl/5.20.1";
30,37d26
< # This (hopefully) will remmove the Tools directory before the debugger tries to run, when it's invoked.  There are 2 direcotries
< # added (per simple inspection) so if that changes, this may break everything.  Thanks to Dana D. for the suggestion.
< BEGIN
< {
<     shift @INC;
<     shift @INC;
< }
< 
55c44
< my $test = 0;
---
> my $test  = 0;
58,71c47,60
< GetOptions(
<            'debug|d'     => \$debug,
<            'sendemail|e' => \$sendEmail,
<            'sendpage|p'  => \$sendPage,
<            'test|t'      => \$test,
<            'cluster|c'   => \$cluster,
<           );
< 
< my $monProduct = ariba::rc::InstalledProduct->new();
< my $product    = ariba::rc::InstalledProduct->new('mobile', $monProduct->service());
< my $name       = $product->name();
< my $service    = $product->service();
< my $email      = $product->default('notify.email');
< my $customer   = $product->customer() || undef;
---
> GetOptions  (
>                 'debug|d'      => \$debug,
>                 'sendemail|e'  => \$sendEmail,
>                 'sendpage|p'   => \$sendPage,
>                 'test|t'       => \$test,
>                 'cluster|c'    => \$cluster,
>             );
> 
> my $monProduct = ariba::rc::InstalledProduct->new ();
> my $product = ariba::rc::InstalledProduct->new ('mobile', $monProduct->service()); 
> my $name = $product->name ();
> my $service = $product->service ();
> my $email = $product->default ('notify.email');
> my $customer = $product->customer () || undef;
74c63
< my $etc = $monProduct->installDir() . '/etc';
---
> my $etc = $monProduct->installDir () . '/etc';
78c67
<     $cluster = $product->currentCluster() || 'primary';
---
>     $cluster = $product->currentCluster () || 'primary';
81c70
< my @instances = $product->appInstancesInCluster($cluster);
---
> my @instances = $product->appInstancesInCluster ($cluster);
89c78,79
<     my $contents = read_file($config_file) or die "failed to read_file $config_file: $!";
---
>     my $contents = read_file($config_file)
>         or die "failed to read_file $config_file: $!";
94,95c84
< if ($@)
< {
---
> if($@) {
108c97
< if (%msg)    # msg was populated above.
---
> if (%msg) # msg was populated above.
110,123c99,112
<     $queries{"MOBILE 2.0 Config FAILED!"} = {
<         crit   => "answer =~ /FAILED/",
<         uiHint => "MOBILE 2.0",
<         perl   => sub {
<             return "Open/DeCode of $config_file failed:  $msg{ConfigReadERROR}";
<         },
<         ticketOwner                  => 'unassigned-sre',
<         ticketOnWarnOpenAfterMinutes => 1,
<         severity                     => 0,
<         description                  => "This errro will only appear if the script fails to load it's config file.",
<         correctiveActions            => [
<                               Ops => "Open a Sev 0 ticket with Ops.",
<                              ],
<     };
---
>     $queries {"MOBILE 2.0 Config FAILED!"} = {
>                              crit                         => "answer =~ /FAILED/",
>                              uiHint                       => "MOBILE 2.0",
>                              perl                         => sub {
>                                                                     return "Open/DeCode of $config_file failed:  $msg{ConfigReadERROR}";
>                                                                  },
>                              ticketOwner                  => 'unassigned-sre',
>                              ticketOnWarnOpenAfterMinutes => 1,
>                              severity                     => 0,
>                              description                  => "This errro will only appear if the script fails to load it's config file.",
>                              correctiveActions            => [
>                                                                  Ops => "Open a Sev 0 ticket with Ops.",
>                                                              ],
>                           };
137,138c126
<     my $hostMachine = ariba::Ops::Machine->new(ariba::Ops::NetworkUtils::hostname());
< 
---
>     my $hostMachine = ariba::Ops::Machine->new (ariba::Ops::NetworkUtils::hostname());
140c128
<     my $totalMemory = ($hostMachine->memorySize() || 8192) * 1024;
---
>     my $totalMemory = ($hostMachine->memorySize () || 8192) * 1024;
142c130
<   INSTANCE:
---
>     INSTANCE:
145,146c133
<         my $instanceName = $instance->instanceName();
< 
---
>         my $instanceName = $instance->instanceName ();
156c143
<         if ($instanceName =~ /^Redis-/)    # Uses netcat (nc) to extract
---
>         if ($instanceName =~ /^Redis-/) # Uses netcat (nc) to extract
159c146,148
<             my $attrPattern = '^(                       # check at the beginning for any of the following strings,' . "\n" . join ('|', @attributes) . "\n" . '):                      # and followed by a colon.  ';
---
>             my $attrPattern = '^(                       # check at the beginning for any of the following strings,'
>                                 . "\n" . join ('|', @attributes) . "\n" .
>                                '):                      # and followed by a colon.  ';
186c175
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
188c177
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
190c179
<         elsif ($instanceName =~ /^RedisSentinel-/)    # Uses netcat (nc) to extract
---
>         elsif ($instanceName =~ /^RedisSentinel-/) # Uses netcat (nc) to extract
193c182
<             $port       = $instance->port;
---
>             $port = $instance->port;
219c208
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
221c210
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
223c212
<         elsif ($instanceName =~ /^Nginx-/)    # HTTP request
---
>         elsif ($instanceName =~ /^Nginx-/) # HTTP request
227c216
<             $port = $product->default('Nginx.Mobile.Port');
---
>             $port = $product->default ('Nginx.Mobile.Port');
245,246c234,235
<                 my $httpObj = ariba::Ops::HTTP->new("http://$host:$port/nginx_status");
<                 $response   = $httpObj->get_data();
---
>                 my $httpObj = ariba::Ops::HTTP->new ("http://$host:$port/nginx_status");
>                 $response = $httpObj->get_data ()
270c259
<                 while (!$results[0])
---
>                 while (! $results[0])
283c272
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
285c274
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
287c276
<         elsif ($instanceName =~ /^Oauth-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Oauth-/)  # Jolokia/JVM
290,291c279,280
<             $port       = $instance->jolokiaPort;
<             %msg        = ("$instanceName", "$host $port");
---
>             $port = $instance->jolokiaPort;
>             %msg = ("$instanceName", "$host $port");
293c282
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
295c284
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
297c286
<         elsif ($instanceName =~ /^Kafka-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Kafka-/)  # Jolokia/JVM
302c291
<             $port       = $instance->jolokiaPort;
---
>             $port = $instance->jolokiaPort;
304c293
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
306c295
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
308c297
<         elsif ($instanceName =~ /^Notification-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Notification-/)  # Jolokia/JVM
313,314c302,303
<             $port       = $instance->jolokiaPort;
<             %msg        = ("$instanceName", "$host $port");
---
>             $port = $instance->jolokiaPort;
>             %msg = ("$instanceName", "$host $port");
316c305
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
318c307
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
323,326c312,315
<             $port       = $instance->port;
<             $port1      = $instance->zkleaderPort;                          # I don't know what to do with this,
<             $port2      = $instance->zkpeerPort;                            # or with this, if anything.
<             %msg        = ("$instanceName", "$host $port $port1 $port2");
---
>             $port = $instance->port;
>             $port1 = $instance->zkleaderPort; # I don't know what to do with this,
>             $port2 = $instance->zkpeerPort;   # or with this, if anything.
>             %msg = ("$instanceName", "$host $port $port1 $port2");
328c317
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
330c319
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
355c344
<                   if $debug or $test;
---
>                         if $debug or $test;
372c361
<                 if ($namePrefix eq 'Redis' && $status =~ /^used_memory/)    # Either basic used memory, or used_memory_rss (3 of them):
---
>                 if ($namePrefix eq 'Redis' && $status =~ /^used_memory/) # Either basic used memory, or used_memory_rss (3 of them):
390,416c379,393
<                     $queries{"$keyName $status"} = {
<                         crit   => $c,
<                         warn   => $w,
<                         uiHint => "$namePrefix/$host",
<                         perl   => sub { return $message; },
<                         ticketOwner                  => 'unassigned-sre',
<                         ticketOnWarnOpenAfterMinutes => 1,
<                         severity                     => 1,
<                         description                  => "$description $status",
<                         correctiveActions            => [
<                                               Ops => $action,
<                                              ],
<                         inf_field   => "count",
<                         inf_default => 0,
<                         inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                         group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $c,
<                                                          warn        => $w,
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => 0,
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $c,
>                                              warn                         => $w,
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {
>                                                                                     return $message;
>                                                                                  },
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description $status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
420,421c397
<                     my $message = 0;
< 
---
>                     my $message = 'OK';
431,457c407,421
<                     $queries{"$keyName $status"} = {
<                         crit   => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
<                         warn   => "answer eq $warn",
<                         uiHint => "$namePrefix/$host",
<                         perl   => sub { return $message; },
<                         ticketOwner                  => 'unassigned-sre',
<                         ticketOnWarnOpenAfterMinutes => 1,
<                         severity                     => 1,
<                         description                  => "$description $status",
<                         correctiveActions            => [
<                                               Ops => $action,
<                                              ],
<                         inf_field   => "count",
<                         inf_default => 0,
<                         inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                         group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
<                                                          warn        => "answer eq $warn",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status;},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
>                                              warn                         => "answer eq $warn",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {
>                                                                                     return $message;
>                                                                                  },
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description $status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
468,496c432,447
<                         $queries{"$keyName $status"} = {
<                             crit   => $critical,
<                             warn   => "answer >= $warn",
<                             info   => "$info",
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              crit        => $critical,
<                                                              warn        => "answer >= $warn",
<                                                              info        => "$info",
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
---
>                         $queries {"$keyName $status"} = {
>                                                  crit                         => $critical,
>                                                  warn                         => "answer >= $warn",
>                                                  info                         => "$info",
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
502,528c453,467
<                         $queries{"$keyName $status"} = {
<                             crit   => $critical,
<                             warn   => "answer >= $warn",
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              crit        => $critical,
<                                                              warn        => "answer >= $warn",
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
---
>                         $queries {"$keyName $status"} = {
>                                                  crit                         => $critical,
>                                                  warn                         => "answer >= $warn",
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
532,557c471,484
<                         $queries{"$keyName $status"} = {
<                             info   => $info,
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              info        => $info,
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
< 
---
>                         $queries {"$keyName $status"} = {
>                                                  info                         => $info,
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
574,579c501,506
<                     warn        => 'answer ne 0',
<                     crit        => '(previousAnswer ne 0 && answer ne 0) || answer =~ /Connection refused|none|ERROR:\s\s/',
<                     perl        => sub {return $answer},
<                     severity    => 1,
<                     uiHint      => "$namePrefix/$host",
<                     description => 'Sends a "ruok" (are you ok) message to the zookeeper node. If it is working properly,
---
>                             warn    => 'answer ne "imok"',
>                             crit    => '(previousAnswer ne "imok" && answer ne "imok") || answer =~ /Connection refused|none|ERROR:\s\s/',
>                             perl    => sub {return $answer},
>                             severity    => 1,
>                             uiHint  => "$namePrefix/$host",
>                             description => 'Sends a "ruok" (are you ok) message to the zookeeper node. If it is working properly,
581,602c508,515
<                     correctiveActions => [
<                                           Ops => 'Check the kr log for details on why the zookeeper node is not ok. In a cluster setup, '
<                                             . 'zookeeper must have majority of its nodes up and running to work. Ex. If there are 3 '
<                                             . 'nodes, then at least 2 nodes must be up. If only one node is up, it will not work. '
<                                             . 'Escalate to Tools if needed.',
<                                           Tools => 'Troubleshoot based on kr log',
<                                          ],
<                     inf_field   => "count",
<                     inf_default => 0,
<                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                     group_by    => "$keyName,$status",
<                                                };
<                 $queries{"$keyName $status type "} = {
<                                                       warn        => 'answer ne 0',
<                                                       crit        => '(previousAnswer ne 0 && answer ne 0) || answer =~ /Connection refused|none|ERROR:\s\s/',
<                                                       perl        => sub {return $status},
<                                                       uiHint      => "$namePrefix/$host",
<                                                       inf_field   => "type",
<                                                       inf_default => "none",
<                                                       inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                       group_by    => "$keyName,$status",
<                                                      };
---
>                             correctiveActions => [
>                                 Ops => 'Check the kr log for details on why the zookeeper node is not ok. In a cluster setup, ' .
>                                     'zookeeper must have majority of its nodes up and running to work. Ex. If there are 3 ' .
>                                     'nodes, then at least 2 nodes must be up. If only one node is up, it will not work. ' .
>                                     'Escalate to Tools if needed.',
>                                 Tools => 'Troubleshoot based on kr log',
>                             ],
>                     };
605c518
<         else    # All the JVM Jolokia/JMX hosts processed here.
---
>         else # All the JVM Jolokia/JMX hosts processed here.
612c525
<             eval {$jmx = JMX::Jmx4Perl->new(url => "http://$host:$port/jolokia/")};
---
>             eval {$jmx = JMX::Jmx4Perl->new (url => "http://$host:$port/jolokia/")};
626,634c539,547
<                     my $request = JMX::Jmx4Perl::Request->new(
<                                                               READ,
<                                                               {
<                                                                mbean     => $statusMap{$namePrefix}->{$status}->{request}->{mbean},
<                                                                attribute => $statusMap{$namePrefix}->{$status}->{request}->{attribute},
<                                                               }
<                                                              );
<                     $response = $jmx->request($request);
<                 };
---
>                         my $request = JMX::Jmx4Perl::Request->new (
>                                                                      READ,
>                                                                      {
>                                                                         mbean => $statusMap{$namePrefix}->{$status}->{request}->{mbean},
>                                                                         attribute => $statusMap{$namePrefix}->{$status}->{request}->{attribute},
>                                                                      }
>                                                                   );
>                         $response = $jmx->request ($request);
>                      };
646c559
<                 if (!defined $message)    # Be sure there's a message to report.
---
>                 if (! defined $message) # Be sure there's a message to report.
675,704c588,601
<                     $queries{"$keyName $status"} = {
<                                                     crit                         => $critical,
<                                                     warn                         => "answer >= $warn",
<                                                     info                         => "answer >= $info",
<                                                     uiHint                       => "$namePrefix/$host",
<                                                     perl                         => sub {return $message},
<                                                     ticketOwner                  => 'unassigned-sre',
<                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                     severity                     => 1,
<                                                     description                  => "$description$status",
<                                                     correctiveActions            => [
<                                                                           Ops => $action,
<                                                                          ],
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $critical,
<                                                          warn        => "answer >= $warn",
<                                                          info        => "answer >= $info",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "typ",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
< 
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $critical,
>                                              warn                         => "answer >= $warn",
>                                              info                         => "answer >= $info",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description$status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
708,735c605,617
<                     $queries{"$keyName $status"} = {
<                                                     crit                         => $critical,
<                                                     warn                         => "answer >= $warn",
<                                                     uiHint                       => "$namePrefix/$host",
<                                                     perl                         => sub {return $message},
<                                                     ticketOwner                  => 'unassigned-sre',
<                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                     severity                     => 1,
<                                                     description                  => "$description$status",
<                                                     correctiveActions            => [
<                                                                           Ops => $action,
<                                                                          ],
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $critical,
<                                                          warn        => "answer >= $warn",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
< 
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $critical,
>                                              warn                         => "answer >= $warn",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description$status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
739,756c621,626
<                     $queries{"$keyName $status"} = {
<                                                     info        => "answer >= $info",
<                                                     uiHint      => "$namePrefix/$host",
<                                                     perl        => sub {return $message},
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          info        => "answer >= $info",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              info                         => "answer >= $info",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              description                  => "$description$status",
>                                           };
763,764c633,635
< $queries{'influx_details'} = {measurement => 'mobile_status'};
< my $q = ariba::monitor::QueryManager->newWithDetails("mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries);
---
> my $q = ariba::monitor::QueryManager->newWithDetails(
>     "mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries
> );
766c637
< $q->processQueries($debug, $email, $sendEmail, $sendPage);    # unless $test;
---
> $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage); # unless $test;
779,788c650,659
<         if (/$attrPattern/x)
<         {
<             # Retruns two items.
<             split /:/;
<         }
<         else
<         {
<             # This is a "do nothing" branch, to ignore the unwanted fields.
<         }
<     } @_;
---
>                     if (/$attrPattern/x)
>                     {
>                         # Retruns two items.
>                         split /:/;
>                     }
>                     else
>                     {
>                         # This is a "do nothing" branch, to ignore the unwanted fields.
>                     }
>                } @_;
802,805c673,675
<             my $telnet = Net::Telnet->new(Host => $host, Port => $port,);
<             $telnet->print("ruok");
<             $output = $telnet->getline();
<             $output = 0 if ($output eq 'imok');
---
>                 my $telnet = Net::Telnet->new(Host => $host, Port => $port,);
>                 $telnet->print("ruok");
>                 $output = $telnet->getline();
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/tools/perl-5.22.1/bin/perl
23,25d22
< # This will load the "new" Perl Jolokia/JMX support.  It *must* follow *all* the other 'use' statements so it doesn't accidentally
< # pull in any modules that should be for/from the 'old' perl.
< use lib "/usr/local/tools/lib/perl5/site_perl/5.20.1";
30,37d26
< # This (hopefully) will remmove the Tools directory before the debugger tries to run, when it's invoked.  There are 2 direcotries
< # added (per simple inspection) so if that changes, this may break everything.  Thanks to Dana D. for the suggestion.
< BEGIN
< {
<     shift @INC;
<     shift @INC;
< }
< 
55c44
< my $test = 0;
---
> my $test  = 0;
58,71c47,60
< GetOptions(
<            'debug|d'     => \$debug,
<            'sendemail|e' => \$sendEmail,
<            'sendpage|p'  => \$sendPage,
<            'test|t'      => \$test,
<            'cluster|c'   => \$cluster,
<           );
< 
< my $monProduct = ariba::rc::InstalledProduct->new();
< my $product    = ariba::rc::InstalledProduct->new('mobile', $monProduct->service());
< my $name       = $product->name();
< my $service    = $product->service();
< my $email      = $product->default('notify.email');
< my $customer   = $product->customer() || undef;
---
> GetOptions  (
>                 'debug|d'      => \$debug,
>                 'sendemail|e'  => \$sendEmail,
>                 'sendpage|p'   => \$sendPage,
>                 'test|t'       => \$test,
>                 'cluster|c'    => \$cluster,
>             );
> 
> my $monProduct = ariba::rc::InstalledProduct->new ();
> my $product = ariba::rc::InstalledProduct->new ('mobile', $monProduct->service()); 
> my $name = $product->name ();
> my $service = $product->service ();
> my $email = $product->default ('notify.email');
> my $customer = $product->customer () || undef;
74c63
< my $etc = $monProduct->installDir() . '/etc';
---
> my $etc = $monProduct->installDir () . '/etc';
78c67
<     $cluster = $product->currentCluster() || 'primary';
---
>     $cluster = $product->currentCluster () || 'primary';
81c70
< my @instances = $product->appInstancesInCluster($cluster);
---
> my @instances = $product->appInstancesInCluster ($cluster);
89c78,79
<     my $contents = read_file($config_file) or die "failed to read_file $config_file: $!";
---
>     my $contents = read_file($config_file)
>         or die "failed to read_file $config_file: $!";
94,95c84
< if ($@)
< {
---
> if($@) {
108c97
< if (%msg)    # msg was populated above.
---
> if (%msg) # msg was populated above.
110,123c99,112
<     $queries{"MOBILE 2.0 Config FAILED!"} = {
<         crit   => "answer =~ /FAILED/",
<         uiHint => "MOBILE 2.0",
<         perl   => sub {
<             return "Open/DeCode of $config_file failed:  $msg{ConfigReadERROR}";
<         },
<         ticketOwner                  => 'unassigned-sre',
<         ticketOnWarnOpenAfterMinutes => 1,
<         severity                     => 0,
<         description                  => "This errro will only appear if the script fails to load it's config file.",
<         correctiveActions            => [
<                               Ops => "Open a Sev 0 ticket with Ops.",
<                              ],
<     };
---
>     $queries {"MOBILE 2.0 Config FAILED!"} = {
>                              crit                         => "answer =~ /FAILED/",
>                              uiHint                       => "MOBILE 2.0",
>                              perl                         => sub {
>                                                                     return "Open/DeCode of $config_file failed:  $msg{ConfigReadERROR}";
>                                                                  },
>                              ticketOwner                  => 'unassigned-sre',
>                              ticketOnWarnOpenAfterMinutes => 1,
>                              severity                     => 0,
>                              description                  => "This errro will only appear if the script fails to load it's config file.",
>                              correctiveActions            => [
>                                                                  Ops => "Open a Sev 0 ticket with Ops.",
>                                                              ],
>                           };
137,138c126
<     my $hostMachine = ariba::Ops::Machine->new(ariba::Ops::NetworkUtils::hostname());
< 
---
>     my $hostMachine = ariba::Ops::Machine->new (ariba::Ops::NetworkUtils::hostname());
140c128
<     my $totalMemory = ($hostMachine->memorySize() || 8192) * 1024;
---
>     my $totalMemory = ($hostMachine->memorySize () || 8192) * 1024;
142c130
<   INSTANCE:
---
>     INSTANCE:
145,146c133
<         my $instanceName = $instance->instanceName();
< 
---
>         my $instanceName = $instance->instanceName ();
156c143
<         if ($instanceName =~ /^Redis-/)    # Uses netcat (nc) to extract
---
>         if ($instanceName =~ /^Redis-/) # Uses netcat (nc) to extract
159c146,148
<             my $attrPattern = '^(                       # check at the beginning for any of the following strings,' . "\n" . join ('|', @attributes) . "\n" . '):                      # and followed by a colon.  ';
---
>             my $attrPattern = '^(                       # check at the beginning for any of the following strings,'
>                                 . "\n" . join ('|', @attributes) . "\n" .
>                                '):                      # and followed by a colon.  ';
186c175
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
188c177
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
190c179
<         elsif ($instanceName =~ /^RedisSentinel-/)    # Uses netcat (nc) to extract
---
>         elsif ($instanceName =~ /^RedisSentinel-/) # Uses netcat (nc) to extract
193c182
<             $port       = $instance->port;
---
>             $port = $instance->port;
219c208
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
221c210
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
223c212
<         elsif ($instanceName =~ /^Nginx-/)    # HTTP request
---
>         elsif ($instanceName =~ /^Nginx-/) # HTTP request
227c216
<             $port = $product->default('Nginx.Mobile.Port');
---
>             $port = $product->default ('Nginx.Mobile.Port');
245,246c234,235
<                 my $httpObj = ariba::Ops::HTTP->new("http://$host:$port/nginx_status");
<                 $response   = $httpObj->get_data();
---
>                 my $httpObj = ariba::Ops::HTTP->new ("http://$host:$port/nginx_status");
>                 $response = $httpObj->get_data ()
270c259
<                 while (!$results[0])
---
>                 while (! $results[0])
283c272
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
285c274
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
287c276
<         elsif ($instanceName =~ /^Oauth-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Oauth-/)  # Jolokia/JVM
290,291c279,280
<             $port       = $instance->jolokiaPort;
<             %msg        = ("$instanceName", "$host $port");
---
>             $port = $instance->jolokiaPort;
>             %msg = ("$instanceName", "$host $port");
293c282
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
295c284
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
297c286
<         elsif ($instanceName =~ /^Kafka-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Kafka-/)  # Jolokia/JVM
302c291
<             $port       = $instance->jolokiaPort;
---
>             $port = $instance->jolokiaPort;
304c293
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
306c295
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
308c297
<         elsif ($instanceName =~ /^Notification-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Notification-/)  # Jolokia/JVM
313,314c302,303
<             $port       = $instance->jolokiaPort;
<             %msg        = ("$instanceName", "$host $port");
---
>             $port = $instance->jolokiaPort;
>             %msg = ("$instanceName", "$host $port");
316c305
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
318c307
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
323,326c312,315
<             $port       = $instance->port;
<             $port1      = $instance->zkleaderPort;                          # I don't know what to do with this,
<             $port2      = $instance->zkpeerPort;                            # or with this, if anything.
<             %msg        = ("$instanceName", "$host $port $port1 $port2");
---
>             $port = $instance->port;
>             $port1 = $instance->zkleaderPort; # I don't know what to do with this,
>             $port2 = $instance->zkpeerPort;   # or with this, if anything.
>             %msg = ("$instanceName", "$host $port $port1 $port2");
328c317
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
330c319
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
355c344
<                   if $debug or $test;
---
>                         if $debug or $test;
372c361
<                 if ($namePrefix eq 'Redis' && $status =~ /^used_memory/)    # Either basic used memory, or used_memory_rss (3 of them):
---
>                 if ($namePrefix eq 'Redis' && $status =~ /^used_memory/) # Either basic used memory, or used_memory_rss (3 of them):
390,416c379,393
<                     $queries{"$keyName $status"} = {
<                         crit   => $c,
<                         warn   => $w,
<                         uiHint => "$namePrefix/$host",
<                         perl   => sub { return $message; },
<                         ticketOwner                  => 'unassigned-sre',
<                         ticketOnWarnOpenAfterMinutes => 1,
<                         severity                     => 1,
<                         description                  => "$description $status",
<                         correctiveActions            => [
<                                               Ops => $action,
<                                              ],
<                         inf_field   => "count",
<                         inf_default => 0,
<                         inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                         group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $c,
<                                                          warn        => $w,
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => 0,
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $c,
>                                              warn                         => $w,
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {
>                                                                                     return $message;
>                                                                                  },
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description $status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
420,421c397
<                     my $message = 0;
< 
---
>                     my $message = 'OK';
431,457c407,421
<                     $queries{"$keyName $status"} = {
<                         crit   => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
<                         warn   => "answer eq $warn",
<                         uiHint => "$namePrefix/$host",
<                         perl   => sub { return $message; },
<                         ticketOwner                  => 'unassigned-sre',
<                         ticketOnWarnOpenAfterMinutes => 1,
<                         severity                     => 1,
<                         description                  => "$description $status",
<                         correctiveActions            => [
<                                               Ops => $action,
<                                              ],
<                         inf_field   => "count",
<                         inf_default => 0,
<                         inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                         group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
<                                                          warn        => "answer eq $warn",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status;},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
>                                              warn                         => "answer eq $warn",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {
>                                                                                     return $message;
>                                                                                  },
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description $status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
468,496c432,447
<                         $queries{"$keyName $status"} = {
<                             crit   => $critical,
<                             warn   => "answer >= $warn",
<                             info   => "$info",
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              crit        => $critical,
<                                                              warn        => "answer >= $warn",
<                                                              info        => "$info",
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
---
>                         $queries {"$keyName $status"} = {
>                                                  crit                         => $critical,
>                                                  warn                         => "answer >= $warn",
>                                                  info                         => "$info",
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
502,528c453,467
<                         $queries{"$keyName $status"} = {
<                             crit   => $critical,
<                             warn   => "answer >= $warn",
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              crit        => $critical,
<                                                              warn        => "answer >= $warn",
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
---
>                         $queries {"$keyName $status"} = {
>                                                  crit                         => $critical,
>                                                  warn                         => "answer >= $warn",
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
532,557c471,484
<                         $queries{"$keyName $status"} = {
<                             info   => $info,
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              info        => $info,
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
< 
---
>                         $queries {"$keyName $status"} = {
>                                                  info                         => $info,
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
574,579c501,506
<                     warn        => 'answer ne 0',
<                     crit        => '(previousAnswer ne 0 && answer ne 0) || answer =~ /Connection refused|none|ERROR:\s\s/',
<                     perl        => sub {return $answer},
<                     severity    => 1,
<                     uiHint      => "$namePrefix/$host",
<                     description => 'Sends a "ruok" (are you ok) message to the zookeeper node. If it is working properly,
---
>                             warn    => 'answer ne "imok"',
>                             crit    => '(previousAnswer ne "imok" && answer ne "imok") || answer =~ /Connection refused|none|ERROR:\s\s/',
>                             perl    => sub {return $answer},
>                             severity    => 1,
>                             uiHint  => "$namePrefix/$host",
>                             description => 'Sends a "ruok" (are you ok) message to the zookeeper node. If it is working properly,
581,602c508,515
<                     correctiveActions => [
<                                           Ops => 'Check the kr log for details on why the zookeeper node is not ok. In a cluster setup, '
<                                             . 'zookeeper must have majority of its nodes up and running to work. Ex. If there are 3 '
<                                             . 'nodes, then at least 2 nodes must be up. If only one node is up, it will not work. '
<                                             . 'Escalate to Tools if needed.',
<                                           Tools => 'Troubleshoot based on kr log',
<                                          ],
<                     inf_field   => "count",
<                     inf_default => 0,
<                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                     group_by    => "$keyName,$status",
<                                                };
<                 $queries{"$keyName $status type "} = {
<                                                       warn        => 'answer ne 0',
<                                                       crit        => '(previousAnswer ne 0 && answer ne 0) || answer =~ /Connection refused|none|ERROR:\s\s/',
<                                                       perl        => sub {return $status},
<                                                       uiHint      => "$namePrefix/$host",
<                                                       inf_field   => "type",
<                                                       inf_default => "none",
<                                                       inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                       group_by    => "$keyName,$status",
<                                                      };
---
>                             correctiveActions => [
>                                 Ops => 'Check the kr log for details on why the zookeeper node is not ok. In a cluster setup, ' .
>                                     'zookeeper must have majority of its nodes up and running to work. Ex. If there are 3 ' .
>                                     'nodes, then at least 2 nodes must be up. If only one node is up, it will not work. ' .
>                                     'Escalate to Tools if needed.',
>                                 Tools => 'Troubleshoot based on kr log',
>                             ],
>                     };
605c518
<         else    # All the JVM Jolokia/JMX hosts processed here.
---
>         else # All the JVM Jolokia/JMX hosts processed here.
612c525
<             eval {$jmx = JMX::Jmx4Perl->new(url => "http://$host:$port/jolokia/")};
---
>             eval {$jmx = JMX::Jmx4Perl->new (url => "http://$host:$port/jolokia/")};
626,634c539,547
<                     my $request = JMX::Jmx4Perl::Request->new(
<                                                               READ,
<                                                               {
<                                                                mbean     => $statusMap{$namePrefix}->{$status}->{request}->{mbean},
<                                                                attribute => $statusMap{$namePrefix}->{$status}->{request}->{attribute},
<                                                               }
<                                                              );
<                     $response = $jmx->request($request);
<                 };
---
>                         my $request = JMX::Jmx4Perl::Request->new (
>                                                                      READ,
>                                                                      {
>                                                                         mbean => $statusMap{$namePrefix}->{$status}->{request}->{mbean},
>                                                                         attribute => $statusMap{$namePrefix}->{$status}->{request}->{attribute},
>                                                                      }
>                                                                   );
>                         $response = $jmx->request ($request);
>                      };
646c559
<                 if (!defined $message)    # Be sure there's a message to report.
---
>                 if (! defined $message) # Be sure there's a message to report.
675,704c588,601
<                     $queries{"$keyName $status"} = {
<                                                     crit                         => $critical,
<                                                     warn                         => "answer >= $warn",
<                                                     info                         => "answer >= $info",
<                                                     uiHint                       => "$namePrefix/$host",
<                                                     perl                         => sub {return $message},
<                                                     ticketOwner                  => 'unassigned-sre',
<                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                     severity                     => 1,
<                                                     description                  => "$description$status",
<                                                     correctiveActions            => [
<                                                                           Ops => $action,
<                                                                          ],
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $critical,
<                                                          warn        => "answer >= $warn",
<                                                          info        => "answer >= $info",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "typ",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
< 
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $critical,
>                                              warn                         => "answer >= $warn",
>                                              info                         => "answer >= $info",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description$status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
708,735c605,617
<                     $queries{"$keyName $status"} = {
<                                                     crit                         => $critical,
<                                                     warn                         => "answer >= $warn",
<                                                     uiHint                       => "$namePrefix/$host",
<                                                     perl                         => sub {return $message},
<                                                     ticketOwner                  => 'unassigned-sre',
<                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                     severity                     => 1,
<                                                     description                  => "$description$status",
<                                                     correctiveActions            => [
<                                                                           Ops => $action,
<                                                                          ],
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $critical,
<                                                          warn        => "answer >= $warn",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
< 
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $critical,
>                                              warn                         => "answer >= $warn",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description$status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
739,756c621,626
<                     $queries{"$keyName $status"} = {
<                                                     info        => "answer >= $info",
<                                                     uiHint      => "$namePrefix/$host",
<                                                     perl        => sub {return $message},
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          info        => "answer >= $info",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              info                         => "answer >= $info",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              description                  => "$description$status",
>                                           };
763,764c633,635
< $queries{'influx_details'} = {measurement => 'mobile_status'};
< my $q = ariba::monitor::QueryManager->newWithDetails("mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries);
---
> my $q = ariba::monitor::QueryManager->newWithDetails(
>     "mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries
> );
766c637
< $q->processQueries($debug, $email, $sendEmail, $sendPage);    # unless $test;
---
> $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage); # unless $test;
779,788c650,659
<         if (/$attrPattern/x)
<         {
<             # Retruns two items.
<             split /:/;
<         }
<         else
<         {
<             # This is a "do nothing" branch, to ignore the unwanted fields.
<         }
<     } @_;
---
>                     if (/$attrPattern/x)
>                     {
>                         # Retruns two items.
>                         split /:/;
>                     }
>                     else
>                     {
>                         # This is a "do nothing" branch, to ignore the unwanted fields.
>                     }
>                } @_;
802,805c673,675
<             my $telnet = Net::Telnet->new(Host => $host, Port => $port,);
<             $telnet->print("ruok");
<             $output = $telnet->getline();
<             $output = 0 if ($output eq 'imok');
---
>                 my $telnet = Net::Telnet->new(Host => $host, Port => $port,);
>                 $telnet->print("ruok");
>                 $output = $telnet->getline();
34a35
>     my $etc = $monProduct->installDir () . '/etc';
51,53c52,53
<                              $config_file = $ENV{MOBILE_STATUS_CONFIG_FILE} || '/var/local/collectors/mobile/an-mobile-status.conf';
<                              my $contents = read_file($config_file)
<                                  or die "failed to read_file $config_file: $!";
---
>                              $config_file = $ENV{MOBILE_STATUS_CONFIG_FILE} || "$etc/query/an-mobile-status.conf";
>                              my $contents = read_file($config_file) or die "failed to read_file $config_file: $!";
109c109
<                 $data = -1;
---
>                 $data = $statusMap{ERROR};
128c128
<                                                         crit        => "answer eq -1",
---
>                                                         crit        => "answer =~ /^ERROR:/",
133,136d132
<                                                         inf_tags    => qq(node="$host",uihint="$instance"),
<                                                         inf_field   => $httpCode,
<                                                         inf_default => 0,
<                                                         group_by    => $instance,
142c138
<                                                         crit              => "answer > $crit || answer eq -1",
---
>                                                         crit              => "answer > $crit || answer =~ /^ERROR:/,",
152,155d147
<                                                         inf_tags    => qq(node="$host",uihint="$instance"),
<                                                         inf_field   => $httpCode,
<                                                         inf_default => 0,
<                                                         group_by    => $instance,
169c161
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
9d8
< 
10a10
> 
60,61d59
<     $queries{'influx_details'} = { measurement => 'mobile_api_response' };
< 
133,136d130
<                                                         inf_tags    => "node=\"$host\"",
<                                                         inf_field   => $httpCode,
<                                                         inf_default => 0,
<                                                         group_by    => $host,
152,155d145
<                                                         inf_tags    => "node=\"$host\"",
<                                                         inf_field   => $httpCode,
<                                                         inf_default => 0,
<                                                         group_by    => $host,
filename:./bin/mon/kr-status
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
268,270d267
<             "inf_field" => "restarted_in_last_hour",
<             "inf_default" => "none",
<             "group_by" => $tab,
289,291d285
<             "inf_field" => "oom_in_last_hour",
<             "inf_default" => "none",
<             "group_by" => $tab,
302,304d295
<             "inf_field" => "dead_in_last_hour",
<             "inf_default" => "none",
<             "group_by" => $tab,
323,326c314
< 			],
<             "inf_field" => "unix_fs_stack_traces_in_last_hour",
<             "inf_default" => "none",
<             "group_by" => $tab,
---
> 			]
336,338d323
<                 "inf_field" => "socket_closed_stack_traces_in_last_hour",
<                 "inf_default" => "none",
<                 "group_by" => $tab,
359,362c344
< 			],
<             "inf_field" => "too_long_to_start_in_last_hour",
<             "inf_default" => "none",
<             "group_by" => $tab,
---
> 			]
371d346
<         $q->{influx_details} = { measurement => 'kr_status' };       
373c348
< 		$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/s4/esignature-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
120c120
<         $queryResult = qw(OK);
---
>         $queryResult = "OK";
122c122
<         $queryResult = qw("Unexpected response - " . $resp);
---
>         $queryResult = "Unexpected response - " . $resp;
126c126
<         crit => 'answer !~ /^"OK"$/',
---
>         crit => 'answer !~ /^OK$/',
134d133
<         inf_field => "docusign_rest_api",
145c144
<         $soapResult = qw(OK);
---
>         $soapResult = "OK";
147c146
<         $soapResult = qw("Unexpected Response - " . $resp);
---
>         $soapResult = "Unexpected Response - " . $resp;
151c150
<         crit => 'answer !~ /^"OK"$/',
---
>         crit => 'answer !~ /^OK$/',
159d157
<         inf_field => "docusign_soap_api",
169c167
<         $echoSoapResult = qw(OK);
---
>         $echoSoapResult = "OK";
171c169
<         $echoSoapResult = qw("Unexpected Response - " . $resp);
---
>         $echoSoapResult = "Unexpected Response - " . $resp;
175c173
<         crit => 'answer !~ /^"OK"$/',
---
>         crit => 'answer !~ /^OK$/',
183d180
<         inf_field => "echosign_soap_api",
186,187d182
<     $queries{influx_details} = { measurement => 'esignature_status' };
< 
190c185
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
3c3
< # $Id: //ariba/services/monitor/bin/s4/esignature-status#5 $
---
> # $Id: //ariba/services/monitor/bin/s4/esignature-status#6 $
115c115,116
<     my $signinHeader = "<DocuSignCredentials><Username>$user</Username><Password>$password</Password><IntegratorKey>$key</IntegratorKey></DocuSignCredentials>";
---
>     my $signinHeader = "<DocuSignCredentials><Username>$user</Username><Password>$password</Password>" .
>                        "<IntegratorKey>$key</IntegratorKey></DocuSignCredentials>";
126c127
<         $queryResult = qq(OK);
---
>         $queryResult = "OK";
128c129
<         $queryResult = qq(Unexpected response -  $resp);
---
>         $queryResult = "Unexpected response - " . $resp;
143,144c144,148
<     my $soapBody = '<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"><soap:Body><Ping xmlns="http://www.docusign.net/API/3.0" /></soap:Body></soap:Envelope>';
<     my $soapUrl = $product->default('Application.ACM.Signature.DocuSign.SOAPMonitoringURL') || "https://www.docusign.net/api/3.0/DSAPI.asmx";
---
>     my $soapBody = '<?xml version="1.0" encoding="utf-8"?>' .
>                    '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" ' .
>                    'xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"><soap:Body><Ping xmlns="http://www.docusign.net/API/3.0" /></soap:Body></soap:Envelope>';
>     my $soapUrl = $product->default('Application.ACM.Signature.DocuSign.SOAPMonitoringURL') ||
>                   "https://www.docusign.net/api/3.0/DSAPI.asmx";
151c155
<         $soapResult = qq(OK);
---
>         $soapResult = "OK";
153c157
<         $soapResult = qq(Unexpected Response $resp);
---
>         $soapResult = "Unexpected Response - " . $resp;
168c172,175
<     $soapBody = '<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap:Body><testPing xmlns="http://api.echosign"><apiKey>' . $echoSignKey . '</apiKey></testPing></soap:Body></soap:Envelope>';
---
>     $soapBody = '<?xml version="1.0" encoding="utf-8"?>' .
>                 '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" ' .
>                 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap:Body><testPing xmlns="http://api.echosign"><apiKey>' .
>                 $echoSignKey . '</apiKey></testPing></soap:Body></soap:Envelope>';
175c182
<         $echoSoapResult = qq(OK);
---
>         $echoSoapResult = "OK";
177c184
<         $echoSoapResult = qq(Unexpected Response $resp);
---
>         $echoSoapResult = "Unexpected Response - " . $resp;
filename:./bin/s4/intermedia-index-health
15d14
< use Data::Dumper;
161,164d159
<                 inf_field   => "out_of_date",
<                 inf_tags    => "index_name=\"$indexName\", schema_name=\"$schemaName\"",
<                 inf_default => 0,
<                 group_by    => $indexName,
174,177d168
<                 inf_field   => "pending_items",
<                 inf_tags    => "index_name=\"$indexName\", schema_name=\"$schemaName\"",
<                 inf_default => 0,
<                 group_by    => $indexName,
194,195d184
<         	$queries{influx_details} = { measurement => 'intermedia_index_health' };
< 
202c191
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/startup
1c1,5
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
> 
> # $Id: //ariba/services/tools/bin/startup#656 $
> #
> # Top level script to start Ariba Internet and all the related services
23c27,53
< use ariba::Ops::Startup::Monitoring;
---
> use ariba::Ops::Startup::DB;
> use ariba::Ops::Startup::Java;
> use ariba::Ops::Startup::WOF;
> use ariba::Ops::Startup::Buyer;
> use ariba::Ops::Startup::OpenOffice;
> use ariba::Ops::Startup::TestServer;
> use ariba::Ops::Startup::ANTestRunner;
> use ariba::Ops::Startup::SeleniumServer;
> use ariba::Ops::Startup::PHP;
> use ariba::Ops::Startup::Perl;
> use ariba::Ops::Startup::LilyNode;
> use ariba::Ops::Startup::Solr;
> use ariba::Ops::Startup::AUCCommunity;
> use ariba::Ops::Startup::S2;
> use ariba::Ops::Startup::Test;
> use ariba::Ops::Startup::Logi;
> use ariba::Ops::Startup::Arches;
> use ariba::Ops::Startup::Hadoop;
> use ariba::Ops::Startup::ZooKeeper;
> use ariba::Ops::Startup::Mobile;
> use ariba::Ops::Startup::Hbase;
> use ariba::Ops::Startup::Flume;
> use ariba::Ops::Startup::Springboot;
> use ariba::Ops::Startup::Enode;
> use ariba::Ops::Startup::OSGI;
> use ariba::Ops::Startup::Redis;
> use ariba::Ops::L2PMap;
79,125d108
<     print "INSTALLDIR is $INSTALLDIR for service $service and prod $prodname for customer $customer on cluster $clusterName for build $buildName\n";
< 
<     print "Hello, Stratus!\n";
<     createSymlinks({ clusterName => $clusterName });
< 
<     # Load in the roles of this host
<     my @roles = $me->rolesForHostInCluster($hostname, $clusterName);
< 
<     # launch all roles served by this host, or only the ones requested
<     my @rolesToLaunch = $startSpecificRoles ? @launchRoles : @roles;
< 
<     print "roles is @roles\n";
<     print "rolesToLaunch is  @rolesToLaunch\n";
<     ariba::Ops::Startup::Common::setAsInstalled($buildName);
< 
<     # setAsInstalled() sets default symlinks only... add etc/ for stratus
<     ariba::Ops::Startup::Common::createSymLinks($buildName, {"etc" => "etc"});
< 
<     my %rolesLaunched = ();
<     for my $role (@rolesToLaunch) {
<         next if $rolesLaunched{$role};
< 
<         if ($role eq "monserver" || $role eq "backup-monserver") {
< 
<             # force decryption of mon product passwords while blowfish is
<             # still initialized with masterpassword.  This is a
<             # work-around until ariba::util::Encryption is a full-fledged
<             # class and can handle multiple Blowfish keys.
<             my $throwawayDecryptedValue = $me->default('dbainfo.system.password');
<             my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
<             unless($cipherStoreInit) {
<                 ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
<                 $cipherStoreInit = 1;
<             }
< 
<             $rolesLaunched{"monserver"} = 1;
<             $rolesLaunched{"backup-monserver"} = 1;
<         }
<     }
< }
< 
< sub createSymlinks() {
< 
<     my $args = shift;
< 
<     my $clusterName = $args->{clusterName};
< 
175a159,1696
>     # Load in the roles of this host
>     my @roles = $me->rolesForHostInCluster($hostname, $clusterName);
> 
>     # launch all roles served by this host, or only the ones requested
>     my @rolesToLaunch = $startSpecificRoles ? @launchRoles : @roles;
> 
>     ariba::Ops::Startup::Common::setAsInstalled($buildName);
> 
>     #
>     # sort roles so we launch them in the right order.
>     #
>     my $sortRoleSub = \&ariba::Ops::Startup::Common::webLogicSortRoles; 
>     $sortRoleSub = \&ariba::Ops::Startup::Hadoop::sortRoles if (grep(/^$prodname$/, ariba::rc::Globals::hadoopProducts()));
>     @rolesToLaunch = sort $sortRoleSub @rolesToLaunch;
> 
>     unless ($quiet) {
>         print '-' x 72, "\n";;
>         print "ARIBA_DEPLOY_ROOT = $ENV{'ARIBA_DEPLOY_ROOT'}\n";
>         print "ARIBA_CONFIG_ROOT = $ENV{'ARIBA_CONFIG_ROOT'}\n";
>         print "BUILDNAME = $ENV{'BUILDNAME'}\n";
>         print "Starting $prodname $service service";
>         print " for customer $customer" if ($customer);
>         print "\n";
>         print "on $hostname in $clusterName cluster\n";
>         print '-' x 72, "\n";;
>         print "Roles in $clusterName cluster: ", join(", ", @roles), "\n";
>         print "Launching roles : ", join(", ", @rolesToLaunch), "\n";
>     }
> 
>     $masterPassword = ariba::rc::Passwords::lookupMasterPci( $me );
> 
>     my %rolesLaunched = ();
> 
>     my @appInstancesLaunched;
> 
>     my $symlinkedPersonalities = 0; 
>     my $symlinkedEstorePersonalities = 0;   
>     my $symlinkedAdmin = 0;
>     my $monDirCreated = 0;
> 
>     ariba::Ops::Startup::Common::setupKeeprunningLogDirs($service, $prodname, $customer);
> 
>     for my $role (@rolesToLaunch) {
> 
>         next if $rolesLaunched{$role};
>         next if !$me->servesRoleInCluster($hostname,$role,$clusterName);
> 
>         # Now start the right pieces of the service based on roles and product
>         if ($role eq "wofapps" ||
>             $role eq "bigwofapps" ||
>             $role eq "cxmlreceive" ||
>             $role eq "aodcxmlreceive" ||
>             $role eq "misc" ||
>             $role eq "uiapps" ||
>             $role eq "supplieruiapps" ||
>             $role eq "buyeruiapps" ||
>             $role eq "lowuiapps" ||
>             $role eq "sourcinguiapps" ||
>             $role eq "batchapps" ||
>             $role eq "dispatchers" ||
>             $role eq "aoddispatchers" ||
>             $role eq "sapconnect" ||
>             $role eq "paymentdispatcher" ||
>             $role eq "validation" ||
>             $role eq "qawofapps"   ||
>             $role eq "cacheapps"   ||
>             $role eq "ebapps"   ||
>             $role eq "adminapps" ||
>             $role eq "aodapps" ||
>             $role eq "aoduiapps" ||
>             $role eq "esigapps" ||
>             $role eq "testrunner" ||
>             $role eq "searchupdater"
>         ) {
> 
>             ariba::Ops::Startup::WOF::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::Ops::Startup::AN::genericFilesystemSetup($me);
> 
>             if ($role eq "esigapps") {
>                 my $SUDO = ariba::rc::Utils::sudoCmd();
>                 r("$SUDO /etc/init.d/pcscd stop");
>                 r("$SUDO /etc/init.d/pcscd start");
>             }
> 
>             if ($role eq "wofapps" || 
>                 $role eq "uiapps" || 
>                 $role eq "supplieruiapps" ||
>                 $role eq "buyeruiapps" ||
>                 $role eq "sourcingsupplieruiapps" ||
>                 $role eq "lowuiapps" ||
>                 $role eq "dispatchers" ||
>                 $role eq "validation" ||
>                 $role eq "cxmlreceive"||
>                 $role eq "sharedcxmlreceive"||
>                 $role eq "aodapps"||
>                 $role eq "aoduiapps"||
>                 $role eq "misc"||
>                 $role eq "searchupdater"
>             ) {
>                 
>                 if ($prodname ne 'estore') {
>                     #we dont want to do this for estore
>                     ariba::Ops::Startup::AN::makePersonalityDirs($me);
>                 }
>             }
> 
>             if ($prodname eq 'estore') {
>                 unless ($symlinkedEstorePersonalities) {
>                   ariba::Ops::Startup::EStore::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                   $symlinkedEstorePersonalities = 1;
>                   ariba::rc::Utils::mkdirRecursively( $me->default('TempFilesDir') );
>                 }
>             } else {
>                 unless ($symlinkedPersonalities) {
>                     ariba::Ops::Startup::AN::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                     $symlinkedPersonalities = 1;
>                 }
>             }
> 
>             my $additionalAppParamsHashRef;
>             # Set the test related variable if test runner defined
>             if ($me->singleHostForRoleInCluster('testrunner')) {
>                 ariba::Ops::Startup::ANTestRunner::setRuntimeEnv($me);
>                 $additionalAppParamsHashRef = ariba::Ops::Startup::ANTestRunner::composeSeleniumArgs($me);
>             }
>             
>             if ($role eq 'adminapps' && $prodname eq 'an' && !$symlinkedAdmin) {    
>                 ariba::Ops::Startup::AN::createSymLinksForAdminserver($me);
>                 $symlinkedAdmin = 1;
>             }
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             if (!$startSpecificApps && !$alreadyDoneCleanTemp ) {
> 
>                 ariba::Ops::Startup::Common::removeJunkFromTempDir($service);
>                 $alreadyDoneCleanTemp++;
> 
>             }
> 
> 
>             #start wof apps
>             push(@appInstancesLaunched, ariba::Ops::Startup::WOF::launchApps(
>                 $me,
>                 \@launchApps,
>                 \@appArgs,
>                 $role,
>                 $communityName,
>                 $masterPassword,
>                 $additionalAppParamsHashRef
>             ));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 5*60; # 5mins
>         }
> 
>         if ($role eq "database") {
>             if ($prodname eq 'an') {
>                 ariba::Ops::Startup::DB::createLinksForCommunities($me);
>             }
>             $rolesLaunched{$role} = 1;
>         }
> 
>         # these may be pure java apps.
>         if ($role eq "perfapps") {
> 
>             ariba::Ops::Startup::Java::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Java::launchApps(
>                 $me,
>                 \@launchApps, 
>                 \@appArgs,
>                 $role, 
>                 $communityName, 
>                 $masterPassword,
>             );
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         # Need to create symlinks to a directory outside builddir for personalities
>         if ($role eq "personalities" ||
>             $role eq "adminpersonalities" ||
>             $role eq "ebapps" ||
>             $role eq "private-label" ||
>             $role eq "admin-private-label") {
> 
>             if($prodname eq 'estore') {
>                 unless ($symlinkedEstorePersonalities) {
>                   ariba::Ops::Startup::EStore::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                   $symlinkedEstorePersonalities = 1;
>                 }
>             }
> 
>             if ($role eq 'admin-private-label' && $prodname eq 'estore' && !$symlinkedAdmin) {  
>                 ariba::Ops::Startup::EStore::createSymLinksForAdminserver($me);
>                 $symlinkedAdmin = 1;
>             } 
> 
>             unless ($symlinkedPersonalities) {
>                 ariba::Ops::Startup::AN::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                 $symlinkedPersonalities = 1;
>             }
> 
>             $rolesLaunched{"personalities"} = 1;
>             $rolesLaunched{"adminpersonalities"} = 1;
>             $rolesLaunched{"private-label"} = 1;
>             $rolesLaunched{"admin-private-label"} = 1;
>         }
> 
>         # Need to create symlinks to a directory outside builddir for logo upload
>         if ($role eq "customer-logo" ) {
>             ariba::Ops::Startup::AN::createSymLinksForLogos($ENV{'BUILDNAME'});
>             $rolesLaunched{"customer-logos"} = 1;
>         }
> 
> 
>         # Set toplevel link to point to latest version of cXML
>         if ($role eq "httpvendor" && $prodname eq "cxml") {
>             ariba::Ops::Startup::CXML::createSymLinks($me);
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "httpvendor" && grep /^$prodname$/, (ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts())) {
>             ariba::Ops::Startup::Common::createVersionedDocrootSymlinks();
>             $rolesLaunched{$role} = 1;
>         }
> 
>         # Set toplevel docs link to point to latest version of docs
>         if (($role eq "doc-contents" || $role eq "httpvendor") && $prodname eq "doc") {
>             my %symlinks = (
>                     'docs'  => 'docs',
>                     );
>             ariba::Ops::Startup::Common::createSymLinks($me->buildName(), \%symlinks);
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "admin-private-label" && $prodname eq 'an') {
>             unless ($symlinkedAdmin) {  
>                 ariba::Ops::Startup::AN::createSymLinksForAdminserver($me);
>                 $symlinkedAdmin = 1;
>             }
>         }
> 
>         if($role eq 'opstools') {
>             ariba::Ops::Startup::Test::setupOpstools($me, $masterPassword);
>             ariba::Ops::Startup::Test::runUnitTests($me, $masterPassword);
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if($role eq 'opstools-webserver') {
>             my $logDir = $me->default('ApacheLogDir');
>             ariba::rc::Utils::mkdirRecursively("$logDir");
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd.conf";
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 		
>         # memcached is now its own role. This way we can stop/start it without
>         # tying it to the stop/start of a JVM.  Community does not use this code.  
>         # It handles memcached separately in AUCCommunity.pm
>         #
>         # memcached is only actioned for a stop or start/install.  We don't
>         # touch it during a rolling upgrade.
>         #
>         # All JVM roles that required memcached need to have their hosts also listed
>         # under the 'memcached' role in roles.cfg
>         if ($role eq 'memcached' && !$rollingStart) {
>             my $product = ariba::rc::InstalledProduct->new();
> 
>             my $memCachedExe = $product->default('Memcached.Exe');
>             my $memCachedArgs = $product->default('Memcached.Args');
> 
>             # Abort startup if memcached is not configured or not found
>             die "ERROR: Memcached.Exe not defined in DeploymentDefaults.xml" unless $memCachedExe;
>             die "ERROR: '$memCachedExe' does not exist" if ! -f $memCachedExe;
> 
>             # strip off the label at the end.  Memcached does not stop for RU and thus we leverage the bin dir soft link so that if
>             # KR restarts an instance it will always be from the current build.
>             my $homeInstallDir = dirname( $INSTALLDIR );
>             ariba::Ops::Startup::Common::launchCommandFeedResponses("$homeInstallDir/bin/keepRunning -w -kp $memCachedExe $memCachedArgs -ki -kn memcached\@$shortHost");
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role =~ /^communityapp/){ ## if we're communityapp or communityappadmin
>             my $SUDO = ariba::Ops::Startup::Common::realOrFakeSudoCmd();
> 
>             my $logDir = $me->default('ApacheLogDir');
>             unless ( -e $logDir ){
>                 r("$SUDO mkdir -p $logDir");
>             }
> 
>             $logDir = $me->default('TestLogDir');
>             unless ( -e $logDir ){
>                 r("$SUDO mkdir -p $logDir");
>             }
> 
>             ## make Drupal File Storage directory:
>             my $fileStore = $me->default('AUC.FileStore');
>             unless ( -e $fileStore ){
>                 r("$SUDO mkdir -p $fileStore");
>             }
> 
>             my $user = $me->deploymentUser();
> 
>             if ( $user ){
> #                r("$SUDO chown -R $user:ariba " . $me->default('ApacheLogDir'));
> #                r("$SUDO chown -R $user:ariba " . $me->default('TestLogDir'));
> #                r("$SUDO chown -R $user:ariba " . $me->default('AUC.FileStore'));
>             } else {
>                 warn "ERROR: Could not change ownership of created directories, couldn't retrieve deploymentUser from Product!\n";
>             }
>             
>             unless ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ) {
>                 ## Open FH to /dev/null and select it, saving the old FH
>                 open my $DEVNULL, '>', '/dev/null' or die "Error redirecting to /dev/null: $!\n";
>                 my $oldFH = select $DEVNULL;
> 
>                 ## Symlink this directory into the build:
>                 unless ( symlink("$fileStore", "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/") ){
>                     ## If the above 'symlink' failed, try this:
>                     r("ln -s $fileStore $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/ 2>&1 > /dev/null");
>                 }
>                 ## I still don't feel 100% comfortable this symlink will get created so ...
>                 if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" ){
>                     ariba::Ops::Startup::Common::makeSymlink( $fileStore, "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" );
>                 }
>                 ## And, if the link is still not there, print an error message:
>                 if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                     warn "ERROR: could not create symlink '$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files'!!\n";
>                 }
>                 ## Reset filehandle
>                 select $oldFH;
>             }
> 
>             ## And if it exists change ownership to the deployment user
>             if ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                 if ( $user ){
>                     r("$SUDO chown $user:ariba $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files");
>                 } else {
>                     warn "ERROR: Could not change ownership of created directories, couldn't retrieve deploymentUser from Product!\n";
>                 }
>             }
> 
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd.conf";
> 
>             unless ( $cipherStoreInit ){
>                 ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 1}, $me);
>                 $cipherStoreInit = 1;
>             }
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::AUCCommunity::launchApps($me, \@launchApps, \@appArgs, $role, $communityName, $masterPassword));
> 
>             #
>             # AUCCommunity::launchApps takes a long time, so reset the 5 minute counter
>             # AFTER we finish it.
>             #
>             ariba::rc::Utils::refreshSudoPrompt($me->deploymentUser())
>                 unless ariba::rc::Globals::isPersonalService($me->service());
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role =~ /^cws/ ){
>             my $logDir = $me->default('ApacheLogDir');
>             my $cacheDir = $me->default('CacheRoot');
>             my @subdirs = qw{ ssl_mutex balancer cache };
>             my $SUDO = ariba::Ops::Startup::Common::realOrFakeSudoCmd();
> #            r("$SUDO mkdir -p $logDir");
> #            r("$SUDO mkdir -p $logDir/ssl_mutex");
> #            r("$SUDO mkdir -p $logDir/balancer");
> #            r("$SUDO mkdir -p $logDir/cache");
> #            r("$SUDO chown -R " . $me->deploymentUser(), ":ariba $logDir");
>             foreach my $dir ( @subdirs ){
>                 ariba::rc::Utils::mkdirRecursively( "$logDir/$dir" )
>                     unless ( -d "$logDir/$dir" );
>             }
>             #create cache dir if it doesn't exist
>             ariba::rc::Utils::mkdirRecursively( "$cacheDir" )
>                 unless ( -d "$cacheDir" );
>         }
>         if ($role eq 'cwswebserver'){
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $balancerFile = "$ENV{'ARIBA_CONFIG_ROOT'}/balancer.conf";
> 
>             ariba::Ops::Startup::Apache::configureHttpdForASPProducts($templateFile,$confFile,$role,$me);
>             ##                                                         Product      Role           Conf File
>             ariba::Ops::Startup::Apache::generateProxyBalancerConfig( 'community', 'communityapp', $balancerFile );
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq 'cwsadminserver'){
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/adminhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $balancerFile = "$ENV{'ARIBA_CONFIG_ROOT'}/balancer-admin.conf";
>             ariba::Ops::Startup::Apache::configureHttpdForASPProducts($templateFile,$confFile,$role,$me);
>             ariba::Ops::Startup::Apache::generateProxyBalancerConfigAdmin( 'community', 'communityappadmin', $balancerFile );
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
>         }
> 
>         if($role eq 'piwikwebserver') {
>             ariba::Ops::Startup::Apache::createPiwikConfigFile($me);
> 
>             my $logDir = $me->default('ApacheLogDir');
>             ariba::rc::Utils::mkdirRecursively("$logDir/fastcgi/dynamic");
> 
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd.conf";
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if($role eq 'pws-webserver') {
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile, $confFile, $role, $me);
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "webserver" || $role eq "adminserver" || $role eq "esigwebserver" || $role eq "poserver" || $role eq "ebswebserver" || $role eq "aodwebserver" || $role eq "aodadminserver" || $role eq "estorewebserver") {
>         
>             my @products = ariba::Ops::Startup::Common::loadInstalledSharedServiceProducts($service);
>             ## Filter out Tomcat Apps
>             @products =  grep { ! $_->tomcatVersion() } @products;
> 
>             ariba::Ops::Startup::Apache::writeWebObjectsXMLConfFile($me, $role, \@products);
> 
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             # Esig doesn't need symlinks, and in fact creates problems. TMID: 13520
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products) unless ($role eq 'esigwebserver' || $role eq 'ebswebserver' || $role eq 'aodwebserver' || $role eq 'aodadminserver');
>             ariba::Ops::Startup::Apache::symlinkModPerlLibs();
>             ariba::Ops::Startup::Apache::buildBusyPageSymlink($me, @products) if ($role eq 'webserver');
> 
>             my $templateFile = '';
> 
>             if ($role eq 'webserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
> 
>             } elsif ($role eq 'adminserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/adminhttpd.conf";
> 
>             } elsif ($role eq 'esigwebserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/esighttpd.conf";
> 
>             } elsif ($role eq 'poserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/poshttpd.conf";
>             } elsif ($role eq 'ebswebserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/ebshttpd.conf";
>             } elsif ($role eq 'aodwebserver') {
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/aodhttpd.conf";
>             } elsif ($role eq 'aodadminserver') {
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/aodadminhttpd.conf";
>             } elsif ($role eq 'estorewebserver') {
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/estorehttpd.conf";
>             }
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
> 
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "ss-webserver" || $role eq "ss-adminserver" || $role eq "ss-testserver" || $role eq 'mwswebserver') {
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledSharedServiceProducts($service);
>             ## Filter for Tomcat Apps and the 'doc' app [HOA-83400] to make sure its rootdoc symlinks get created as well
>             @products =  grep { $_->tomcatVersion() || $_->name() eq 'doc' } @products;
> 
>             ariba::Ops::Startup::Apache::writeModJKConfigFile($me, $role, \@products);
> 
>             #Writes L2P Mappingfiles. This is specifically for handling a case where ssws servers are 
>             #replaced and hence there is no L2P mapping file. 
>             writeL2PMappingFile($me, \@products);
> 
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
> 
>             $monDirCreated ||= ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             if ($role eq 'ss-webserver' || $role eq 'mwswebserver') {
>                 $ENV{'LOGSDIR'} .= $service;
> 
>                 ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>                 #
>                 # Launch daemon to keep realm to community
>                 # map uptodate.
>                 #
>                 my $rotateInterval = 24 * 60 * 60; # 1 day
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/generate-realm-to-community-map -prod buyer -prod s4 -prod s4pm -prod buyerpm -ks $rotateInterval -ki -kn realm-to-community-map\@$shortHost -ke $ENV{'NOTIFY'}");
>             }
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products);
> 
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForSharedService($templateFile,$confFile,$role,$me);
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             ariba::Ops::Startup::Apache::buildBusyPageSymlink($me, @products) if ($role eq 'ss-webserver');
> 
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "ows-webserver" || $role eq "ows-adminserver" || $role eq "ows-testserver") {
>             # XXX We will need a better way to determine which products are included in the future
>             my @products = ();
>             my $archesProduct = ($prodname eq 'owsdr') ? 'archesdr' : 'arches';
>             # here an assumption is made that ows goes with arches using similar naming convention
>             if ( $prodname =~ /^ows(\d+)$/ ) {
>                 $archesProduct = "arches$1";
>             }
> 
>             foreach my $prodName ($archesProduct, "trdb", "logi") {
>                 if(ariba::rc::InstalledProduct->isInstalled($prodName, $service)) {
>                     push(@products, ariba::rc::InstalledProduct->new($prodName, $service));
>                 }
>             }
>  
>             ariba::Ops::Startup::Apache::writeModJKConfigFile($me, $role, \@products);
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
>  
>             $monDirCreated ||= ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>  
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products);
>  
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForSharedService($templateFile,$confFile,$role,$me);
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>  
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
>  
>             ariba::Ops::Startup::Apache::buildBusyPageSymlink($me, @products) if ($role eq 'ows-webserver');
>  
>  
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "bounce-processor") {
>             ariba::Ops::Startup::Common::createSymLinksForBounceProcessor($prodname);
>             ariba::Ops::Startup::Common::createDotForward($me);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "ackparser" || $role eq "smtp-server" ) {
>             ariba::Ops::Startup::Monitoring::createDotForwardForAckparser();
>         }
> 
>         if ($role eq "backup-monitor") {
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>             ariba::Ops::Startup::Common::launchCopyFromSharedFs($me, $masterPassword, $shortHost, "-nomailq");
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "monserver" || $role eq "backup-monserver") {
> 
>             # Refreshing sudo promt again to avoid cache expiry
>             ariba::rc::Utils::refreshSudoPrompt($me->deploymentUser())
>                 unless ariba::rc::Globals::isPersonalService($me->service());
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::Ops::Startup::Monitoring::createSymLinks($ENV{'BUILDNAME'});
>             ariba::Ops::Startup::Monitoring::createMonserverSymLinks();
>             ariba::Ops::Startup::Monitoring::createObjectDirectories($role);    
>             ariba::Ops::Startup::Monitoring::removeWatcherDir();
>             ariba::Ops::Startup::Common::createApacheSymLinks($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             # Start logwatcher in all services.
>             my $lw  = "$INSTALLDIR/bin/logwatcher";
>             my $krargs = "-ke $ENV{'NOTIFY'} -kg $ENV{'NOTIFYPAGERS'}";
>             my $cmd = "$INSTALLDIR/bin/keepRunning -kp $lw -kn logwatcher\@$shortHost $krargs";
>             ariba::Ops::Startup::Common::runKeepRunningCommand($cmd);
> 
>             if ( $role eq "backup-monserver" ) {
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/proxy-queryd -ki -kn proxy-queryd\@$shortHost -ke $ENV{'NOTIFY'}");
>             } else {
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/status-checkerd -ki -kn status-checkerd\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/queryd -ki -kn queryd\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/page/paged -ki -kn paged\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/stale-markerd -ki -kn stale-marker\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/outaged -ki -kn outaged\@$shortHost -ke $ENV{'NOTIFY'}");
> 
> 
>                 # none for product development
>                 if ($service ne 'pd') { 
>                     # build snmptrapd.conf and start snmptrapd for EMC
>                     #ariba::Ops::Startup::Monitoring::buildSNMPTrapdConfig($me);
>                     #ariba::Ops::Startup::Monitoring::launchSNMPTrapd($me);
>                 }
>             }
> 
>             if ($service eq 'pd') { 
> 
>                 # We use a different machinedb interface for
>                 # PD - it talks to Oracle directly.
>                 my $libDir = "$INSTALLDIR/lib/ariba/Ops";
>                 my $oldLib = "$libDir/Machine.pm";
>                 my $newLib = "$libDir/ProductDevelopmentMachine.pm";
> 
>                 unlink($oldLib) or warn "Can't remove $oldLib: $!";
> 
>                 symlink($newLib, $oldLib) or die "Can't symlink $newLib to $oldLib: $!";
> 
>             } else {
> 
>                 # force decryption of mon product passwords while blowfish is
>                 # still initialized with masterpassword.  This is a
>                 # work-around until ariba::util::Encryption is a full-fledged
>                 # class and can handle multiple Blowfish keys.
>                 my $throwawayDecryptedValue = $me->default('dbainfo.system.password');
> 
>                 ### For microservice datacenter, create the product_config(monitoring table) for dynamic product generation
>                 my @ms_services = ariba::Ops::ServiceController::productionMsServicesOnly();
>                 if ( grep $_ eq $service, @ms_services )
>                 {
>                     print ariba::Ops::ProductConfig::Utils::create_product_config_table() . "\n";
>                 }
> 
>                 my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
> 
>                 unless($cipherStoreInit) {
>                     ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
>                     $cipherStoreInit = 1;
>                 }
> 
>                 ariba::Ops::Startup::Apache::generateProxyFilesForRole($me, $role);     
>                 ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>                 if ($role eq "backup-monserver") {
>                     ariba::Ops::Startup::Common::launchCopyFromSharedFs($me, $masterPassword, $shortHost, "-nomailq");
>                 } elsif ($role eq "monserver") {
>                     ariba::Ops::Startup::Common::launchCopyToSharedFs($me, $masterPassword, $shortHost);
>                     ariba::Ops::Startup::Common::launchLogfileWatcher($me);
> 
>                     for my $dc (ariba::Ops::ProductAPIExtensions::datacentersForProducts($me)) {
>                         if (ariba::Ops::Startup::Monitoring::shouldRunNetworkSNMPForServiceAndDatacenter($service, $dc)) {
>                             ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/snmp/rebuild-queries -l $dc -c -i $INSTALLDIR/etc/system.cfg $INSTALLDIR/etc/network.cfg");
>                         } else {
>                             ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/snmp/rebuild-queries -l $dc -c -i $INSTALLDIR/etc/system.cfg");
>                         }
>                     }
>                 }
>             }
> 
>             my @monitorProduct = ($me);
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@monitorProduct);
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/monhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{"monserver"} = 1;
>             $rolesLaunched{"backup-monserver"} = 1;
>         }
> 
>         if ( ($prodname eq 'mon') && (
>             $role eq "replication-source" || 
>             $role eq "database" ||
>             $role eq "product-db-server" || 
>             $role eq "tapebackup-server" || 
>             $role eq "replication-dest" || 
>             $role eq "dataguard-dest" || 
>             $role eq "replication-dest-dr" || 
>             $role eq "veritas-storage" ||
>             $role eq "db-server" ||
>             $role eq "hadoop-server" ||
>             $role eq "replication-dest-reporting" ||
>             $role eq "hanadatabase" ||
>             $role eq "hana-backup" ||
>             $role eq "hana-db-server" ||
>             $role eq "srs-server" ||
>             $role eq "tls-security" ) ) {
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::Ops::Startup::Monitoring::createSymLinks($ENV{'BUILDNAME'});
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
> 
>             #
>             # make sure this doesn't get run twice...
>             #
>             unless($cipherStoreInit) {
>                 ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
>                 $cipherStoreInit = 1;
>             }
> 
>             $rolesLaunched{"tapebackup-source"} = 1;
>             $rolesLaunched{"replication-source"} = 1;
>             $rolesLaunched{"product-db-server"} = 1;
>             $rolesLaunched{"replication-dest"} = 1;
>             $rolesLaunched{"dataguard-dest"} = 1;
>             $rolesLaunched{"db-server"} = 1;
>             $rolesLaunched{"replication-dest-dr"} = 1;
>             $rolesLaunched{"replication-dest-reporting"} = 1;
>             $rolesLaunched{"database"} = 1;
>             $rolesLaunched{"hadoop-server"} = 1;
>             $rolesLaunched{"hanadatabase"} = 1;
>             $rolesLaunched{"hana-db-server"} = 1;
>             $rolesLaunched{"srs-server"} = 1;
>             $rolesLaunched{"tls-security"} = 1;
>         }
>      
>         if ($role eq "monitor" && $prodname eq "anl") {
>             ariba::Ops::Startup::ANL::createDBExportDir($me);
>         }
> 
>         if ($role eq "aes-webserver") {
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledASPProducts($service);
>             ariba::Ops::Startup::Apache::writeModJKConfigFile($me, $role, \@products);
>             ariba::Ops::Startup::Apache::writeModWLConfigFile($me, $role, \@products);
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products);
> 
>             ariba::Ops::Startup::Apache::configureHttpdForASPProducts($templateFile,$confFile,$role,$me);
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "presentation" || $role eq "market" || $role eq "sourcingadmin" || $role eq "sourcing") {
> 
>             ariba::Ops::Startup::AES::setRuntimeEnv($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::AES::makeAttachmentDir($me);
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             ariba::Ops::Startup::AES::launch($me, $role);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq "analysis" ) {
>             ariba::Ops::Startup::Tomcat::setASPRuntimeEnv($me);     
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             # create directories that holds customer provided data
>             ariba::Ops::Startup::ANL::createCustomerSpecificDirectories($me);
> 
>             ariba::Ops::Startup::ANL::launch($me, \@launchApps, $role, $masterPassword);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq "acm" ) {
> 
>             ariba::Ops::Startup::Tomcat::setASPRuntimeEnv($me);     
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             ariba::Ops::Startup::ACM::launch($me, \@launchApps, $role, $masterPassword);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         #
>         # A generic tomcat app launching block
>         #
>         if ( $role eq "tomcatapps" || $role eq "spotbuyapp") {
>             ariba::Ops::Startup::Tomcat::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             if ($role eq "spotbuyapp") {
>                 push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, $prodname, \@launchApps, $role, $communityName, $masterPassword));
>             }
>             else {
>                 ariba::Ops::Startup::Tomcat::launch($me, $prodname, \@launchApps, $role, $communityName, $masterPassword);
>             }
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
> 
>         if ($role =~ /^springboot-/) {
>             push(@appInstancesLaunched, ariba::Ops::Startup::Springboot::launch($me, \@launchApps, $role, $communityName, $masterPassword));
>             $rolesLaunched{$role} = 1;
> 	    
> 	    my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>         }
> 
>         if ($role eq "redis" && !$rollingStart) {
>             push(@appInstancesLaunched, ariba::Ops::Startup::Redis::launch($me, \@launchApps, $role));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq "buyerui" ||
>              $role eq "buyer" ||
>              $role eq "buyertask" ||
>              $role eq "buyercatalog" ||
>              $role eq "buyeradmin"
>             ) {
> 
>             ariba::Ops::Startup::Tomcat::setRuntimeEnv($me);
> 
>             my $additionalAppParamsHashRef;
>             # setup qual test env for each node, if needed
>             if ($me->singleHostForRoleInCluster('testserver')) {
>                 $additionalAppParamsHashRef = ariba::Ops::Startup::TestServer::composeSeleniumArgs($me);
>             }
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             if ($role eq "buyerui") {
>                 ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer, $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             # run load meta. Do not launch appinstances if it fails
>             unless (ariba::Ops::Startup::DB::runLoadMeta($me, $masterPassword, $fullStart)) {
>                 print "Error: Loadmeta command returned error, launching of appinstances skipped.  Exiting!\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ABORT());
>             }
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, "buyer", \@launchApps, $role, $communityName, $masterPassword, undef, $additionalAppParamsHashRef));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
>         }
> 
>         if ( $role =~ /^(ss|cdbuyer)ui$/     || 
>              $role =~ /^(ss|cdbuyer)task$/   || 
>              $role =~ /^(ss|cdbuyer)admin$/ ) {
> 
>             ariba::Ops::Startup::Tomcat::setASPRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>                 # start xvfb server only on the nodes that need it
>             if ($role eq "ssui" ) {
>                 ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             # run load meta. Do not launch appinstances if it fails
>             unless (ariba::Ops::Startup::DB::runLoadMeta($me, $masterPassword, $fullStart)) {
>                 print "Error: Loadmeta command returned error, launching of appinstances skipped.  Exiting!\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ABORT());
>             }
> 
>             my $webInfSubdir = ( $role =~ m/^ss/ ? "sourcing":"buyer" );
>             push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
> 
>             # For S2 only - create symlinks from install-dir/logs to Node Logs, 
>             # to make them available from the UI without exposing other logs
>                     if ( $role =~ /^ss(task|ui)$/ ) {
>                             ariba::Ops::Startup::S2::createSymlinkForS2NodeLogs($me);
>                     }
> 
>         }
> 
>         if ( $role eq "asmopenoffice" ) {
>             ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             push(@appInstancesLaunched, ariba::Ops::Startup::OpenOffice::launch($me, "sourcing", \@launchApps, $role, $communityName, $masterPassword));
>         }
> 
>         if( $role eq "opstools-apps" ) {
>             push(@appInstancesLaunched, ariba::Ops::Startup::Perl::launchApps($me, \@launchApps, "", $role, $communityName, $masterPassword));
>         }
> 
>         if ( $role eq "piwikapps" ) {
>             my $logDir = $me->default('ApacheLogDir');
> 
>             #
>             # create the archiveLogBaseDir on piwik app server so that
>             # log-viewer starts
>             #
>             ariba::rc::Utils::mkdirRecursively( ariba::Ops::Constants->archiveLogBaseDir() );
>             ariba::Ops::Startup::Common::fixArchiveLogDirPermissions(
>                 $service, $prodname, undef
>             );
> 
>             ariba::rc::Utils::mkdirRecursively("$logDir/piwik/monitor");
>             ariba::rc::Utils::mkdirRecursively("$logDir/piwik/logs");
> 
>             my $sharedFS = $me->default('shared-filesystem');
>             ariba::rc::Utils::mkdirRecursively($sharedFS);
> 
>             my $piwik = ariba::rc::InstalledProduct->new();
>             require ariba::Ops::Startup::Monitoring;
>             ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 0}, $me);
>             $cipherStoreInit = 1;
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::PHP::launchApps($me, \@launchApps, "", $role, $communityName, $masterPassword));
>         }
> 
>         if ( $role eq "poemapps" ) {
>             unless($cipherStoreInit) {
>                 ariba::Ops::Startup::Monitoring::initializeCipherStoreWithCOnditions($me, {'user' => 0}, $me);
>             }
>         }
> 
>         if ( $role eq "asmui" ||
>              $role eq "asmsvui" ||
>              $role eq "asmglobaltask" ||
>              $role eq "asmaoddatasync" ||
>              $role eq "asmtask" ||
>              $role eq "asmadmin" ||
>              $role eq "sdbui" ||
>              $role eq "sdbtask"
>             ) {
>             ariba::Ops::Startup::Tomcat::setRuntimeEnv($me);
>             
>             my $additionalAppParamsHashRef;
>             # setup qual test env for each node, if needed
>             if ($me->singleHostForRoleInCluster('testserver')) {
>                 $additionalAppParamsHashRef = ariba::Ops::Startup::TestServer::composeSeleniumArgs($me);
>             }
> 
>             ariba::Ops::Startup::S4::createSymlinkForSystemRealmScratchArea($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             # start xvfb server only on the nodes that need it
>             if ($role eq "asmui" || $role eq "asmsvui" || $role eq "sdbui") {
>                 ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             # run load meta. Do not launch appinstances if it fails
>             unless (ariba::Ops::Startup::DB::runLoadMeta($me, $masterPassword, $fullStart)) {
>                 print "Error: Loadmeta command returned error, launching of appinstances skipped.  Exiting!\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ABORT());
>             }
> 
>             my $webInfSubdir = 'sourcing';
>             if($prodname eq 'sdb') {
>                 $webInfSubdir = 'sdb';
>             }
>             push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword, undef, $additionalAppParamsHashRef));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
> 
>         }
> 
> 
>         if ( $role eq "indexmgr" ||
>              $role eq "shardmgr" ||
>              $role eq "shardwriterosgi" ||
>              $role eq "searchcore" ||  
>              $role eq "testserverosgi" ||
>              $role eq "searchmgr"
>             ) {
>             ariba::Ops::Startup::OSGI::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Arches::writeConfFiles($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ## 1-DET96F - Create and mount ramdisk for shardwriter and searchcore nodes
>             if( $role =~ /shardwriter/ || $role =~ /searchcore/ ){
>                 ariba::Ops::Startup::Arches::createRamdisk( $me );
>             }
>                 
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             #arches5 changes it does not seem this is used directly 
>             #my $webInfSubdir = 'arches';
>             my $webInfSubdir = $prodname;
>             push(@appInstancesLaunched, ariba::Ops::Startup::OSGI::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
> 
>         }
>                 
>         if( $role eq "lily" ){
>             ariba::Ops::Startup::LilyNode::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::LilyNode::launch($me, \@launchApps, $role, $communityName));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if( $role eq "solr" || $role =~ /^aucsolr/ ){
>             ariba::Ops::Startup::Solr::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                     ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             if ($archiveLogDir) {
>                     ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             unless ( $cipherStoreInit ){
>                 ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 1}, $me);
>                 $cipherStoreInit = 1;
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             if ( $role =~ /auc/ ){ ## For Community/AUC/UEX make apahe log dir for Solr logs
>                 my $SUDO = ariba::rc::Utils::sudoCmd();
>                 my $user = $me->deploymentUser();
>                 r("$SUDO mkdir -p " . $me->default('ApacheLogDir'));
>                 r("$SUDO chown -R $user:ariba " . $me->default('ApacheLogDir'));
> 
>                 ## Apparently the SOLR nodes also need the filestore ...
>                 ## CR# : 1-DFUN3P
>                 ## make Drupal File Storage directory:
>                 my $fileStore = $me->default('AUC.FileStore');
>                 unless ( -e $fileStore ){
>                     r("$SUDO mkdir -p $fileStore");
>                 }
>                 
>                 unless ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ) {
>                     ## Open FH to /dev/null and select it, saving the old FH
>                     open my $DEVNULL, '>', '/dev/null' or die "Error redirecting to /dev/null: $!\n";
>                     my $oldFH = select $DEVNULL;
> 
>                     ## Symlink this directory into the build:
>                     unless ( symlink("$fileStore", "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/") ){
>                         ## If the above 'symlink' failed, try this:
>                         r("ln -s $fileStore $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/ 2>&1 > /dev/null");
>                     }
>                     ## I still don't feel 100% comfortable this symlink will get created so ...
>                     if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" ){
>                         ariba::Ops::Startup::Common::makeSymlink( $fileStore, "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" );
>                     }
>                     ## And, if the link is still not there, print an error message:
>                     if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                         warn "ERROR: could not create symlink '$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files'!!\n";
>                     }
>                     ## Reset filehandle
>                     select $oldFH;
>                 }
> 
>                 ## And if it exists change ownership to the deployment user
>                 if ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                     if ( $user ){
>                         r("$SUDO chown $user:ariba $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files");
>                     } else {
>                         warn "ERROR: Could not change ownership of created directories, couldn't retrieve deploymentUser from Product!\n";
>                     }
>                 }
>             }
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Solr::launch($me, \@launchApps, $role, $communityName));
>             $rolesLaunched{$role} = 1;
>         }
> 
> 
>         if ($role eq "seleniumrc") {
> 
>             ariba::Ops::Startup::SeleniumServer::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             print "Starting Selenium associated XVFB processes...\n";
> 
>             my $result = ariba::Ops::Startup::SeleniumServer::startXVFB($me, $role, \@launchApps);
> 
>             unless ($result) {
>                 print "Error starting selenium XVFB processes: got $result\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ERROR());
>             }
> 
>             print "Starting Selenium RC processes...\n";
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::SeleniumServer::startSeleniumRC($me, $role, \@launchApps));
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "testserver") {
> 
>             ariba::Ops::Startup::TestServer::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my @appsToClean = @launchApps;
> 
>             if ($startSpecificRoles) {
>                 push(@appsToClean, "TestServer");
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             my $product = ariba::rc::InstalledProduct->new();
>             my $productName = $product->name();
> 
>             #FIXME this is probably wrong for AN
>             my $webInfSubdir = ( $productName =~ /s4/ ? "sourcing":$productName );
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::TestServer::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword, undef));
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "migration-ui" ) {
> 
>             mkdirRecursively( dirname($main::INSTALLDIR) . "/logs" );
>             mkdirRecursively( $me->default("PE.PHASE1LOCATION" ) );
> 
>             my $tmpDir = $me->default('Ops.BastionHostTempDir') ;
>             mkdirRecursively( $tmpDir ) if $tmpDir;
> 
>             ariba::Ops::Startup::Common::createSymLinks(
>                 $ENV{'BUILDNAME'}, { "docroot/logs" => "logs", }, 1
>             );
> 
>             ariba::Ops::Startup::Common::createSymLinks(
>                 $ENV{'BUILDNAME'}, { "etc" => "etc", }
>             );
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my @extractProduct = ($me);
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@extractProduct);
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/procuriextractionhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
>             unless($cipherStoreInit) {
>                 require ariba::Ops::Startup::Monitoring;
>                 ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
>                 $cipherStoreInit = 1;
>             }
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "logi-server" ) {
> 
>             ariba::Ops::Startup::Logi::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/logihttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             ariba::Ops::Startup::Logi::createDirs($me);
> 
>             require ariba::Ops::Startup::Monitoring;
>             ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 0}, $me);
>             $cipherStoreInit = 1;
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq 'hadoop-journal'      ||
>              $role eq 'hadoop-name'         ||
>              $role eq 'hadoop-secondary'    || 
>              $role eq 'hadoop-data'         || 
>              $role eq 'hadoop-task'         || 
>              $role eq 'hadoop-jobtracker'   ||
>              $role eq 'ha-jobtracker'       ||
>              $role eq 'hadoop-zkfc'         ||
>              $role eq 'mapreduce-zkfc'      ||
>              $role eq 'hadoop-thrift' ) {
>             ariba::Ops::Startup::Hadoop::setRuntimeEnv($me, $role);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Hadoop::createDirs($me);
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             if ($role eq 'hadoop-jobtracker' || $role eq 'ha-jobtracker') {
>                 my @appsLaunched = ariba::Ops::Startup::Hadoop::launch($me, \@launchApps, $role, $communityName);
> 
>                 last unless @appsLaunched;
>                 push(@appInstancesLaunched, @appsLaunched);
>             } else {
>                 push(@appInstancesLaunched, ariba::Ops::Startup::Hadoop::launch($me, \@launchApps, $role, $communityName));
>             }
>             $rolesLaunched{$role} = 1;
> 
>         }
>        
>          if ( $role eq 'hsim-zookeeper' ) {
>             ariba::Ops::Startup::ZooKeeper::setRuntimeEnv($me);
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
>             ariba::Ops::Startup::Enode::createDirs($me);
>             push(@appInstancesLaunched, ariba::Ops::Startup::ZooKeeper::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>          }
> 
> 
> 
>         if ( $role eq 'zookeeper' ) {
>             ariba::Ops::Startup::ZooKeeper::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Hadoop::createDirs($me, $me->default('ZooKeeper.DataDir'));
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::ZooKeeper::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         if ( $role =~ /^mobile-/ ) {
>             ariba::Ops::Startup::Mobile::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Mobile::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         if ( $role eq 'hbase-master' ||
>              $role eq 'hbase-region' ||
>              $role eq 'hbase-thrift' ) {
>             ariba::Ops::Startup::Hbase::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Hadoop::createDirs($me);
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Hbase::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         if ( $role eq 'enode' ||
>              $role eq 'lbnode' ) {
>             ##updating simulator.config.xml file for enode and lbnode too HOA-43074 
>             ariba::Ops::Startup::ZooKeeper::setRuntimeEnv($me);
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Enode::setRuntimeEnv($me);
>             push(@appInstancesLaunched, ariba::Ops::Startup::Enode::launch($me, \@launchApps, $role, $communityName, $masterPassword));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq 'flume-master' ||
>              $role eq 'flume' ) {
>             ariba::Ops::Startup::Flume::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Logi::createDirs($me);
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Flume::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         #
>         # Arches symlink to ariba.catalog.indexadapter.jar in buyer build
>         # Create an instance of buyer / arches product so we can get current build information to construct symlink
>         #
>         # arches5 changes
>         #if ($prodname eq 'arches') {
>         my @aProducts = ariba::rc::Globals::archesProducts();
>         if (grep { $_ eq "$prodname" } @aProducts)  {
>             if (ariba::rc::InstalledProduct->isInstalled('buyer', $me->service())) {
>                 my $buyer = ariba::rc::InstalledProduct->new('buyer', $me->service());
> 
>                 if ( $buyer->servesRoleInCluster($hostname, 'archeshosts', $clusterName) ||
>                      $buyer->servesRoleInCluster($hostname, 'dr-archeshosts', $clusterName) ) {
>                     ariba::Ops::Startup::Arches::createSymLinksForBuyerJar($me, $buyer);
>                 }
>             }
>         }
>         if ($prodname eq "buyer") {
>             # arches5 changes
>             # for all arches product (arches, arches5, etc)
>             my @aProducts = ariba::rc::Global::archesProducts();
>             foreach my $ap ( @aProducts ) {
>                 
>             if (ariba::rc::InstalledProduct->isInstalled($ap, $me->service())) {
>                 my $arches = ariba::rc::InstalledProduct->new($ap, $me->service());
> 
>                 if ( $me->servesRoleInCluster($hostname, 'archeshosts', $clusterName) ||
>                      $me->servesRoleInCluster($hostname, 'dr-archeshosts', $clusterName) ) {
>                     ariba::Ops::Startup::Arches::createSymLinksForBuyerJar($arches, $me);
>                 }
>             } 
>             }
>         }
> 
>         #
>         # This is needed so that we run startup-hooks for roles that
>         # required no other action (and were therefore not in the list)
>         #
>         unless($rolesLaunched{$role}) {
>             $rolesLaunched{$role} = 1;
>         }
>     }
> 
>     # run different role hooks
>     # This should take the rolesToLaunch array not rolesLaunched
>     ariba::Ops::Startup::Common::runStartupHooks($me, \%rolesLaunched, 'install');
> 
>     #
>     # sleep after start if it was a rolling restart,
>     # and we launched one of the roles that needs this sleep
>     #
>     if ($rollingStart && $maxTimeToWaitForStart && @appInstancesLaunched) {
>         unless (ariba::Ops::Startup::Common::waitForAppInstancesToInitialize(\@appInstancesLaunched, $maxTimeToWaitForStart)) {
>             print "Error: All appinstances did not fully initialize in $maxTimeToWaitForStart sec(s).\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_TIMEOUT());
>         }
>     }
> 
>     if ($startSpecificApps) { 
> 
>         my $error = 0;
> 
>         for my $app (grep {/\d/} @launchApps) {
>             my $found = 0;
>             for my $appInstance (@appInstancesLaunched) {
>                 if ( $app eq $appInstance->instanceName() || 
>                      $app eq $appInstance->workerName() ) {
>                     $found = 1;
>                     last;
>                 }
>             }
> 
>             unless ($found) {
>                 print "ERROR: $app does not exist.\n";
>                 $error = 1;
>             }
>                 
>         }
> 
>         if ($error) {
>             print "Applications instances available : \n\t";
>                         
>             my @appInstances = grep {$_->host() eq ariba::Ops::NetworkUtils::hostname()} $me->appInstances();
>             print join("\n\t", map {"Instance : " . $_->instanceName() . "   (role : " . $_->launchedBy() . ", cluster : ". $_->cluster() .")" } @appInstances);
>             print "\n";
>         }
>     }
177a1699,1754
> ##################################################################################
> # This method is responsible for generating L2P Mapping file during server startup
> ###################################################################################
> sub writeL2PMappingFile
> {
>     my $currentSSWS = shift;
>     my $productRef  = shift;
>     my @products    = @$productRef;
> 
>     for my $product (@products) {
>         my $productName = $product->name();
>         if( ($productName eq "buyer") || ($productName eq "s4") ){
>                 my @newInstances = $product->appInstances();
>                 my $l2pContentSource  = getL2PContentSource($product);
>                 ariba::Ops::L2PMap::generateL2PMapFile($currentSSWS,$productName,\@newInstances,$l2pContentSource);
>         }
>     }
> }
> 
> sub getL2PContentSource
> {
>     my $product   = shift;
>     my $buildName = $product->buildName();
>     my $l2pContentSource  = "startup|$buildName:0|$buildName:1";
>     return($l2pContentSource);  
> }
> 
> sub usage
> {
>     my $ver = '$Id: //ariba/services/tools/bin/startup#656 $';
> 
> 
>     print "usage: $0 (version $ver)\n";
>     print "    [wofapp-pattern|wofapp-name]\n";
>     print "    -h : this help\n";
>     print "    -d : run with debug\n";
>     print "    -q : do not print anything, work silently\n";
>     print "    -test : run as test\n";
>     print "    -rolling: will cause startup to wait for initialization to complete\n";
>     print "    -full: will cause full start code to be executed for product (if any)\n";
>     print "    -shell : start a shell with right environment\n";
>     print "    -role : specific role to launch\n";
>     print "    -woconf : just regenerate WebObjects.conf file\n";
>     print "    -readMasterPassword : read password from stdin\n";
>     print "    -cluster <clustername>: which cluster to make active\n";
>     print "    -community <id>: specific community to launch\n";
>     print "    -- args ...: args to pass to the apps\n";
>     print "    wofapp-pattern: pattern like ANCXMLDispatcher\n";
>     print "    wofapp-name: pattern like ANCXMLDispatcher-501\n";
>     print "                 if wofapp* is specified only that piece\n"; 
>     print "                 of service will be started.\n";
>     exit(ariba::Ops::Startup::Common::EXIT_CODE_ERROR());
> }
> 
> 
> main();
> # $Id: //ariba/services/tools/bin/startup#652 $
> #
> # Top level script to start Ariba Internet and all the related services
4d7
< use warnings;
21a25,36
> use ariba::Ops::NetworkUtils;
> use ariba::Ops::ProductAPIExtensions;
> use ariba::Ops::ServiceController;
> 
> use ariba::Ops::Startup::S4;
> use ariba::Ops::Startup::ANL;
> use ariba::Ops::Startup::ACM;
> use ariba::Ops::Startup::AES;
> use ariba::Ops::Startup::AN;
> use ariba::Ops::Startup::EStore;
> use ariba::Ops::Startup::Apache;
> use ariba::Ops::Startup::CXML;
22a38,64
> use ariba::Ops::Startup::DB;
> use ariba::Ops::Startup::Java;
> use ariba::Ops::Startup::WOF;
> use ariba::Ops::Startup::Buyer;
> use ariba::Ops::Startup::OpenOffice;
> use ariba::Ops::Startup::TestServer;
> use ariba::Ops::Startup::ANTestRunner;
> use ariba::Ops::Startup::SeleniumServer;
> use ariba::Ops::Startup::PHP;
> use ariba::Ops::Startup::Perl;
> use ariba::Ops::Startup::LilyNode;
> use ariba::Ops::Startup::Solr;
> use ariba::Ops::Startup::AUCCommunity;
> use ariba::Ops::Startup::S2;
> use ariba::Ops::Startup::Test;
> use ariba::Ops::Startup::Logi;
> use ariba::Ops::Startup::Arches;
> use ariba::Ops::Startup::Hadoop;
> use ariba::Ops::Startup::ZooKeeper;
> use ariba::Ops::Startup::Mobile;
> use ariba::Ops::Startup::Hbase;
> use ariba::Ops::Startup::Flume;
> use ariba::Ops::Startup::Springboot;
> use ariba::Ops::Startup::Enode;
> use ariba::Ops::Startup::OSGI;
> use ariba::Ops::Startup::Redis;
> use ariba::Ops::L2PMap;
26c68
< $SIG{PIPE} = sub { print "startup encountered SIGPIPE. Ignored.\n"; };
---
> $SIG{PIPE} = sub { print "startup encoutered SIGPIPE. Ignored.\n"; };
29,31c71
< main();
< 
< sub main
---
> sub main 
68,69d107
<     print "Hello, Stratus 1!\n";
< 
73,74d110
<     print "Hello, Stratus 2!\n";
< 
82,108d117
<     print "INSTALLDIR is $INSTALLDIR for service $service and prod $prodname for customer $customer on cluster $clusterName for build $buildName\n";
< 
<     print "Hello, Stratus 3!\n";
<     createSymlinks({ clusterName => $clusterName });
< 
<     print "Hello, Stratus 4!\n";
<     # Load in the roles of this host
<     my @roles = $me->rolesForHostInCluster($hostname, $clusterName);
< 
<     print "Hello, Stratus 5!\n";
<     # launch all roles served by this host, or only the ones requested
<     my @rolesToLaunch = $startSpecificRoles ? @launchRoles : @roles;
< 
<     print "Hello, Stratus 6!\n";
<     print "roles is @roles\n";
<     print "rolesToLaunch is  @rolesToLaunch\n";
<     print "Hello, Stratus 7!\n";
<     ariba::Ops::Startup::Common::setAsInstalled($buildName);
<     print "Hello, Stratus 8!\n";
< }
< 
< sub createSymlinks() {
< 
<     my $args = shift;
< 
<     my $clusterName = $args->{clusterName};
< 
119,120c128,129
<         # written post substitution.  We leverage the second file of each pair as it's
<         # possible one of the files could end with '.primary' or '.secondary'.  If so
---
>         # written post substitution.  We leverage the second file of each pair as it's 
>         # possible one of the files could end with '.primary' or '.secondary'.  If so 
122c131
< 
---
>  
140c149
<             # Grab the second file name on each line (see file construct assumptions above).
---
>             # Grab the second file name on each line (see file construct assumptions above).  
151c160
<             # The file candidate has a suffix matching the cluster in which we're running.
---
>             # The file candidate has a suffix matching the cluster in which we're running.  
158a168,1700
>     # Load in the roles of this host
>     my @roles = $me->rolesForHostInCluster($hostname, $clusterName);
> 
>     # launch all roles served by this host, or only the ones requested
>     my @rolesToLaunch = $startSpecificRoles ? @launchRoles : @roles;
> 
>     ariba::Ops::Startup::Common::setAsInstalled($buildName);
> 
>     #
>     # sort roles so we launch them in the right order.
>     #
>     my $sortRoleSub = \&ariba::Ops::Startup::Common::webLogicSortRoles; 
>     $sortRoleSub = \&ariba::Ops::Startup::Hadoop::sortRoles if (grep(/^$prodname$/, ariba::rc::Globals::hadoopProducts()));
>     @rolesToLaunch = sort $sortRoleSub @rolesToLaunch;
> 
>     unless ($quiet) {
>         print '-' x 72, "\n";;
>         print "ARIBA_DEPLOY_ROOT = $ENV{'ARIBA_DEPLOY_ROOT'}\n";
>         print "ARIBA_CONFIG_ROOT = $ENV{'ARIBA_CONFIG_ROOT'}\n";
>         print "BUILDNAME = $ENV{'BUILDNAME'}\n";
>         print "Starting $prodname $service service";
>         print " for customer $customer" if ($customer);
>         print "\n";
>         print "on $hostname in $clusterName cluster\n";
>         print '-' x 72, "\n";;
>         print "Roles in $clusterName cluster: ", join(", ", @roles), "\n";
>         print "Launching roles : ", join(", ", @rolesToLaunch), "\n";
>     }
> 
>     $masterPassword = ariba::rc::Passwords::lookupMasterPci( $me );
> 
>     my %rolesLaunched = ();
> 
>     my @appInstancesLaunched;
> 
>     my $symlinkedPersonalities = 0; 
>     my $symlinkedEstorePersonalities = 0;   
>     my $symlinkedAdmin = 0;
>     my $monDirCreated = 0;
> 
>     ariba::Ops::Startup::Common::setupKeeprunningLogDirs($service, $prodname, $customer);
> 
>     for my $role (@rolesToLaunch) {
> 
>         next if $rolesLaunched{$role};
>         next if !$me->servesRoleInCluster($hostname,$role,$clusterName);
> 
>         # Now start the right pieces of the service based on roles and product
>         if ($role eq "wofapps" ||
>             $role eq "bigwofapps" ||
>             $role eq "cxmlreceive" ||
>             $role eq "aodcxmlreceive" ||
>             $role eq "misc" ||
>             $role eq "uiapps" ||
>             $role eq "supplieruiapps" ||
>             $role eq "buyeruiapps" ||
>             $role eq "lowuiapps" ||
>             $role eq "sourcinguiapps" ||
>             $role eq "batchapps" ||
>             $role eq "dispatchers" ||
>             $role eq "aoddispatchers" ||
>             $role eq "sapconnect" ||
>             $role eq "paymentdispatcher" ||
>             $role eq "validation" ||
>             $role eq "qawofapps"   ||
>             $role eq "cacheapps"   ||
>             $role eq "ebapps"   ||
>             $role eq "adminapps" ||
>             $role eq "aodapps" ||
>             $role eq "aoduiapps" ||
>             $role eq "esigapps" ||
>             $role eq "testrunner" ||
>             $role eq "searchupdater"
>         ) {
> 
>             ariba::Ops::Startup::WOF::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::Ops::Startup::AN::genericFilesystemSetup($me);
> 
>             if ($role eq "esigapps") {
>                 my $SUDO = ariba::rc::Utils::sudoCmd();
>                 r("$SUDO /etc/init.d/pcscd stop");
>                 r("$SUDO /etc/init.d/pcscd start");
>             }
> 
>             if ($role eq "wofapps" || 
>                 $role eq "uiapps" || 
>                 $role eq "supplieruiapps" ||
>                 $role eq "buyeruiapps" ||
>                 $role eq "sourcingsupplieruiapps" ||
>                 $role eq "lowuiapps" ||
>                 $role eq "dispatchers" ||
>                 $role eq "validation" ||
>                 $role eq "cxmlreceive"||
>                 $role eq "sharedcxmlreceive"||
>                 $role eq "aodapps"||
>                 $role eq "aoduiapps"||
>                 $role eq "misc"||
>                 $role eq "searchupdater"
>             ) {
>                 
>                 if ($prodname ne 'estore') {
>                     #we dont want to do this for estore
>                     ariba::Ops::Startup::AN::makePersonalityDirs($me);
>                 }
>             }
> 
>             if ($prodname eq 'estore') {
>                 unless ($symlinkedEstorePersonalities) {
>                   ariba::Ops::Startup::EStore::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                   $symlinkedEstorePersonalities = 1;
>                   ariba::rc::Utils::mkdirRecursively( $me->default('TempFilesDir') );
>                 }
>             } else {
>                 unless ($symlinkedPersonalities) {
>                     ariba::Ops::Startup::AN::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                     $symlinkedPersonalities = 1;
>                 }
>             }
> 
>             my $additionalAppParamsHashRef;
>             # Set the test related variable if test runner defined
>             if ($me->singleHostForRoleInCluster('testrunner')) {
>                 ariba::Ops::Startup::ANTestRunner::setRuntimeEnv($me);
>                 $additionalAppParamsHashRef = ariba::Ops::Startup::ANTestRunner::composeSeleniumArgs($me);
>             }
>             
>             if ($role eq 'adminapps' && $prodname eq 'an' && !$symlinkedAdmin) {    
>                 ariba::Ops::Startup::AN::createSymLinksForAdminserver($me);
>                 $symlinkedAdmin = 1;
>             }
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             if (!$startSpecificApps && !$alreadyDoneCleanTemp ) {
> 
>                 ariba::Ops::Startup::Common::removeJunkFromTempDir($service);
>                 $alreadyDoneCleanTemp++;
> 
>             }
> 
> 
>             #start wof apps
>             push(@appInstancesLaunched, ariba::Ops::Startup::WOF::launchApps(
>                 $me,
>                 \@launchApps,
>                 \@appArgs,
>                 $role,
>                 $communityName,
>                 $masterPassword,
>                 $additionalAppParamsHashRef
>             ));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 5*60; # 5mins
>         }
> 
>         if ($role eq "database") {
>             if ($prodname eq 'an') {
>                 ariba::Ops::Startup::DB::createLinksForCommunities($me);
>             }
>             $rolesLaunched{$role} = 1;
>         }
> 
>         # these may be pure java apps.
>         if ($role eq "perfapps") {
> 
>             ariba::Ops::Startup::Java::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Java::launchApps(
>                 $me,
>                 \@launchApps, 
>                 \@appArgs,
>                 $role, 
>                 $communityName, 
>                 $masterPassword,
>             );
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         # Need to create symlinks to a directory outside builddir for personalities
>         if ($role eq "personalities" ||
>             $role eq "adminpersonalities" ||
>             $role eq "ebapps" ||
>             $role eq "private-label" ||
>             $role eq "admin-private-label") {
> 
>             if($prodname eq 'estore') {
>                 unless ($symlinkedEstorePersonalities) {
>                   ariba::Ops::Startup::EStore::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                   $symlinkedEstorePersonalities = 1;
>                 }
>             }
> 
>             if ($role eq 'admin-private-label' && $prodname eq 'estore' && !$symlinkedAdmin) {  
>                 ariba::Ops::Startup::EStore::createSymLinksForAdminserver($me);
>                 $symlinkedAdmin = 1;
>             } 
> 
>             unless ($symlinkedPersonalities) {
>                 ariba::Ops::Startup::AN::createSymLinksForPersonalities($ENV{'BUILDNAME'});
>                 $symlinkedPersonalities = 1;
>             }
> 
>             $rolesLaunched{"personalities"} = 1;
>             $rolesLaunched{"adminpersonalities"} = 1;
>             $rolesLaunched{"private-label"} = 1;
>             $rolesLaunched{"admin-private-label"} = 1;
>         }
> 
>         # Need to create symlinks to a directory outside builddir for logo upload
>         if ($role eq "customer-logo" ) {
>             ariba::Ops::Startup::AN::createSymLinksForLogos($ENV{'BUILDNAME'});
>             $rolesLaunched{"customer-logos"} = 1;
>         }
> 
> 
>         # Set toplevel link to point to latest version of cXML
>         if ($role eq "httpvendor" && $prodname eq "cxml") {
>             ariba::Ops::Startup::CXML::createSymLinks($me);
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "httpvendor" && grep /^$prodname$/, (ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts())) {
>             ariba::Ops::Startup::Common::createVersionedDocrootSymlinks();
>             $rolesLaunched{$role} = 1;
>         }
> 
>         # Set toplevel docs link to point to latest version of docs
>         if (($role eq "doc-contents" || $role eq "httpvendor") && $prodname eq "doc") {
>             my %symlinks = (
>                     'docs'  => 'docs',
>                     );
>             ariba::Ops::Startup::Common::createSymLinks($me->buildName(), \%symlinks);
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "admin-private-label" && $prodname eq 'an') {
>             unless ($symlinkedAdmin) {  
>                 ariba::Ops::Startup::AN::createSymLinksForAdminserver($me);
>                 $symlinkedAdmin = 1;
>             }
>         }
> 
>         if($role eq 'opstools') {
>             ariba::Ops::Startup::Test::setupOpstools($me, $masterPassword);
>             ariba::Ops::Startup::Test::runUnitTests($me, $masterPassword);
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if($role eq 'opstools-webserver') {
>             my $logDir = $me->default('ApacheLogDir');
>             ariba::rc::Utils::mkdirRecursively("$logDir");
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd.conf";
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 		
>         # memcached is now its own role. This way we can stop/start it without
>         # tying it to the stop/start of a JVM.  Community does not use this code.  
>         # It handles memcached separately in AUCCommunity.pm
>         #
>         # memcached is only actioned for a stop or start/install.  We don't
>         # touch it during a rolling upgrade.
>         #
>         # All JVM roles that required memcached need to have their hosts also listed
>         # under the 'memcached' role in roles.cfg
>         if ($role eq 'memcached' && !$rollingStart) {
>             my $product = ariba::rc::InstalledProduct->new();
> 
>             my $memCachedExe = $product->default('Memcached.Exe');
>             my $memCachedArgs = $product->default('Memcached.Args');
> 
>             # Abort startup if memcached is not configured or not found
>             die "ERROR: Memcached.Exe not defined in DeploymentDefaults.xml" unless $memCachedExe;
>             die "ERROR: '$memCachedExe' does not exist" if ! -f $memCachedExe;
> 
>             # strip off the label at the end.  Memcached does not stop for RU and thus we leverage the bin dir soft link so that if
>             # KR restarts an instance it will always be from the current build.
>             my $homeInstallDir = dirname( $INSTALLDIR );
>             ariba::Ops::Startup::Common::launchCommandFeedResponses("$homeInstallDir/bin/keepRunning -w -kp $memCachedExe $memCachedArgs -ki -kn memcached\@$shortHost");
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role =~ /^communityapp/){ ## if we're communityapp or communityappadmin
>             my $SUDO = ariba::Ops::Startup::Common::realOrFakeSudoCmd();
> 
>             my $logDir = $me->default('ApacheLogDir');
>             unless ( -e $logDir ){
>                 r("$SUDO mkdir -p $logDir");
>             }
> 
>             $logDir = $me->default('TestLogDir');
>             unless ( -e $logDir ){
>                 r("$SUDO mkdir -p $logDir");
>             }
> 
>             ## make Drupal File Storage directory:
>             my $fileStore = $me->default('AUC.FileStore');
>             unless ( -e $fileStore ){
>                 r("$SUDO mkdir -p $fileStore");
>             }
> 
>             my $user = $me->deploymentUser();
> 
>             if ( $user ){
> #                r("$SUDO chown -R $user:ariba " . $me->default('ApacheLogDir'));
> #                r("$SUDO chown -R $user:ariba " . $me->default('TestLogDir'));
> #                r("$SUDO chown -R $user:ariba " . $me->default('AUC.FileStore'));
>             } else {
>                 warn "ERROR: Could not change ownership of created directories, couldn't retrieve deploymentUser from Product!\n";
>             }
>             
>             unless ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ) {
>                 ## Open FH to /dev/null and select it, saving the old FH
>                 open my $DEVNULL, '>', '/dev/null' or die "Error redirecting to /dev/null: $!\n";
>                 my $oldFH = select $DEVNULL;
> 
>                 ## Symlink this directory into the build:
>                 unless ( symlink("$fileStore", "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/") ){
>                     ## If the above 'symlink' failed, try this:
>                     r("ln -s $fileStore $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/ 2>&1 > /dev/null");
>                 }
>                 ## I still don't feel 100% comfortable this symlink will get created so ...
>                 if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" ){
>                     ariba::Ops::Startup::Common::makeSymlink( $fileStore, "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" );
>                 }
>                 ## And, if the link is still not there, print an error message:
>                 if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                     warn "ERROR: could not create symlink '$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files'!!\n";
>                 }
>                 ## Reset filehandle
>                 select $oldFH;
>             }
> 
>             ## And if it exists change ownership to the deployment user
>             if ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                 if ( $user ){
>                     r("$SUDO chown $user:ariba $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files");
>                 } else {
>                     warn "ERROR: Could not change ownership of created directories, couldn't retrieve deploymentUser from Product!\n";
>                 }
>             }
> 
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd.conf";
> 
>             unless ( $cipherStoreInit ){
>                 ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 1}, $me);
>                 $cipherStoreInit = 1;
>             }
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::AUCCommunity::launchApps($me, \@launchApps, \@appArgs, $role, $communityName, $masterPassword));
> 
>             #
>             # AUCCommunity::launchApps takes a long time, so reset the 5 minute counter
>             # AFTER we finish it.
>             #
>             ariba::rc::Utils::refreshSudoPrompt($me->deploymentUser())
>                 unless ariba::rc::Globals::isPersonalService($me->service());
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role =~ /^cws/ ){
>             my $logDir = $me->default('ApacheLogDir');
>             my $cacheDir = $me->default('CacheRoot');
>             my @subdirs = qw{ ssl_mutex balancer cache };
>             my $SUDO = ariba::Ops::Startup::Common::realOrFakeSudoCmd();
> #            r("$SUDO mkdir -p $logDir");
> #            r("$SUDO mkdir -p $logDir/ssl_mutex");
> #            r("$SUDO mkdir -p $logDir/balancer");
> #            r("$SUDO mkdir -p $logDir/cache");
> #            r("$SUDO chown -R " . $me->deploymentUser(), ":ariba $logDir");
>             foreach my $dir ( @subdirs ){
>                 ariba::rc::Utils::mkdirRecursively( "$logDir/$dir" )
>                     unless ( -d "$logDir/$dir" );
>             }
>             #create cache dir if it doesn't exist
>             ariba::rc::Utils::mkdirRecursively( "$cacheDir" )
>                 unless ( -d "$cacheDir" );
>         }
>         if ($role eq 'cwswebserver'){
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $balancerFile = "$ENV{'ARIBA_CONFIG_ROOT'}/balancer.conf";
> 
>             ariba::Ops::Startup::Apache::configureHttpdForASPProducts($templateFile,$confFile,$role,$me);
>             ##                                                         Product      Role           Conf File
>             ariba::Ops::Startup::Apache::generateProxyBalancerConfig( 'community', 'communityapp', $balancerFile );
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq 'cwsadminserver'){
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/adminhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $balancerFile = "$ENV{'ARIBA_CONFIG_ROOT'}/balancer-admin.conf";
>             ariba::Ops::Startup::Apache::configureHttpdForASPProducts($templateFile,$confFile,$role,$me);
>             ariba::Ops::Startup::Apache::generateProxyBalancerConfigAdmin( 'community', 'communityappadmin', $balancerFile );
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
>         }
> 
>         if($role eq 'piwikwebserver') {
>             ariba::Ops::Startup::Apache::createPiwikConfigFile($me);
> 
>             my $logDir = $me->default('ApacheLogDir');
>             ariba::rc::Utils::mkdirRecursively("$logDir/fastcgi/dynamic");
> 
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd.conf";
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if($role eq 'pws-webserver') {
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile, $confFile, $role, $me);
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "webserver" || $role eq "adminserver" || $role eq "esigwebserver" || $role eq "poserver" || $role eq "ebswebserver" || $role eq "aodwebserver" || $role eq "aodadminserver" || $role eq "estorewebserver") {
>         
>             my @products = ariba::Ops::Startup::Common::loadInstalledSharedServiceProducts($service);
>             ## Filter out Tomcat Apps
>             @products =  grep { ! $_->tomcatVersion() } @products;
> 
>             ariba::Ops::Startup::Apache::writeWebObjectsXMLConfFile($me, $role, \@products);
> 
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             # Esig doesn't need symlinks, and in fact creates problems. TMID: 13520
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products) unless ($role eq 'esigwebserver' || $role eq 'ebswebserver' || $role eq 'aodwebserver' || $role eq 'aodadminserver');
>             ariba::Ops::Startup::Apache::symlinkModPerlLibs();
>             ariba::Ops::Startup::Apache::buildBusyPageSymlink($me, @products) if ($role eq 'webserver');
> 
>             my $templateFile = '';
> 
>             if ($role eq 'webserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
> 
>             } elsif ($role eq 'adminserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/adminhttpd.conf";
> 
>             } elsif ($role eq 'esigwebserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/esighttpd.conf";
> 
>             } elsif ($role eq 'poserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/poshttpd.conf";
>             } elsif ($role eq 'ebswebserver') {
> 
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/ebshttpd.conf";
>             } elsif ($role eq 'aodwebserver') {
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/aodhttpd.conf";
>             } elsif ($role eq 'aodadminserver') {
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/aodadminhttpd.conf";
>             } elsif ($role eq 'estorewebserver') {
>                 $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/estorehttpd.conf";
>             }
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
> 
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "ss-webserver" || $role eq "ss-adminserver" || $role eq "ss-testserver" || $role eq 'mwswebserver') {
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledSharedServiceProducts($service);
>             ## Filter for Tomcat Apps and the 'doc' app [HOA-83400] to make sure its rootdoc symlinks get created as well
>             @products =  grep { $_->tomcatVersion() || $_->name() eq 'doc' } @products;
> 
>             ariba::Ops::Startup::Apache::writeModJKConfigFile($me, $role, \@products);
> 
>             #Writes L2P Mappingfiles. This is specifically for handling a case where ssws servers are 
>             #replaced and hence there is no L2P mapping file. 
>             writeL2PMappingFile($me, \@products);
> 
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
> 
>             $monDirCreated ||= ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             if ($role eq 'ss-webserver' || $role eq 'mwswebserver') {
>                 $ENV{'LOGSDIR'} .= $service;
> 
>                 ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>                 #
>                 # Launch daemon to keep realm to community
>                 # map uptodate.
>                 #
>                 my $rotateInterval = 24 * 60 * 60; # 1 day
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/generate-realm-to-community-map -prod buyer -prod s4 -prod s4pm -prod buyerpm -ks $rotateInterval -ki -kn realm-to-community-map\@$shortHost -ke $ENV{'NOTIFY'}");
>             }
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products);
> 
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForSharedService($templateFile,$confFile,$role,$me);
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
> 
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             ariba::Ops::Startup::Apache::buildBusyPageSymlink($me, @products) if ($role eq 'ss-webserver');
> 
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "ows-webserver" || $role eq "ows-adminserver" || $role eq "ows-testserver") {
>             # XXX We will need a better way to determine which products are included in the future
>             my @products = ();
>             my $archesProduct = ($prodname eq 'owsdr') ? 'archesdr' : 'arches';
>             foreach my $prodName ($archesProduct, "trdb", "logi") {
>                 if(ariba::rc::InstalledProduct->isInstalled($prodName, $service)) {
>                     push(@products, ariba::rc::InstalledProduct->new($prodName, $service));
>                 }
>             }
>  
>             ariba::Ops::Startup::Apache::writeModJKConfigFile($me, $role, \@products);
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
>  
>             $monDirCreated ||= ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>  
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products);
>  
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForSharedService($templateFile,$confFile,$role,$me);
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>  
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
>  
>             ariba::Ops::Startup::Apache::buildBusyPageSymlink($me, @products) if ($role eq 'ows-webserver');
>  
>  
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "bounce-processor") {
>             ariba::Ops::Startup::Common::createSymLinksForBounceProcessor($prodname);
>             ariba::Ops::Startup::Common::createDotForward($me);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "ackparser") {
>             ariba::Ops::Startup::Monitoring::createDotForwardForAckparser();
>         }
> 
>         if ($role eq "backup-monitor") {
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>             ariba::Ops::Startup::Common::launchCopyFromSharedFs($me, $masterPassword, $shortHost, "-nomailq");
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "monserver" || $role eq "backup-monserver") {
> 
>             # Refreshing sudo promt again to avoid cache expiry
>             ariba::rc::Utils::refreshSudoPrompt($me->deploymentUser())
>                 unless ariba::rc::Globals::isPersonalService($me->service());
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::Ops::Startup::Monitoring::createSymLinks($ENV{'BUILDNAME'});
>             ariba::Ops::Startup::Monitoring::createMonserverSymLinks();
>             ariba::Ops::Startup::Monitoring::createObjectDirectories($role);    
>             ariba::Ops::Startup::Monitoring::removeWatcherDir();
>             ariba::Ops::Startup::Common::createApacheSymLinks($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             # Start logwatcher in all services.
>             my $lw  = "$INSTALLDIR/bin/logwatcher";
>             my $krargs = "-ke $ENV{'NOTIFY'} -kg $ENV{'NOTIFYPAGERS'}";
>             my $cmd = "$INSTALLDIR/bin/keepRunning -kp $lw -kn logwatcher\@$shortHost $krargs";
>             ariba::Ops::Startup::Common::runKeepRunningCommand($cmd);
> 
>             if ( $role eq "backup-monserver" ) {
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/proxy-queryd -ki -kn proxy-queryd\@$shortHost -ke $ENV{'NOTIFY'}");
>             } else {
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/status-checkerd -ki -kn status-checkerd\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/queryd -ki -kn queryd\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/page/paged -ki -kn paged\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/stale-markerd -ki -kn stale-marker\@$shortHost -ke $ENV{'NOTIFY'}");
>                 ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/keepRunning -w -kp $INSTALLDIR/bin/outaged -ki -kn outaged\@$shortHost -ke $ENV{'NOTIFY'}");
> 
> 
>                 # none for product development
>                 if ($service ne 'pd') { 
>                     # build snmptrapd.conf and start snmptrapd for EMC
>                     #ariba::Ops::Startup::Monitoring::buildSNMPTrapdConfig($me);
>                     #ariba::Ops::Startup::Monitoring::launchSNMPTrapd($me);
>                 }
>             }
> 
>             if ($service eq 'pd') { 
> 
>                 # We use a different machinedb interface for
>                 # PD - it talks to Oracle directly.
>                 my $libDir = "$INSTALLDIR/lib/ariba/Ops";
>                 my $oldLib = "$libDir/Machine.pm";
>                 my $newLib = "$libDir/ProductDevelopmentMachine.pm";
> 
>                 unlink($oldLib) or warn "Can't remove $oldLib: $!";
> 
>                 symlink($newLib, $oldLib) or die "Can't symlink $newLib to $oldLib: $!";
> 
>             } else {
> 
>                 # force decryption of mon product passwords while blowfish is
>                 # still initialized with masterpassword.  This is a
>                 # work-around until ariba::util::Encryption is a full-fledged
>                 # class and can handle multiple Blowfish keys.
>                 my $throwawayDecryptedValue = $me->default('dbainfo.system.password');
> 
>                 ### For microservice datacenter, create the product_config(monitoring table) for dynamic product generation
>                 my @ms_services = ariba::Ops::ServiceController::productionMsServicesOnly();
>                 if ( grep $_ eq $service, @ms_services )
>                 {
>                     print ariba::Ops::ProductConfig::Utils::create_product_config_table() . "\n";
>                 }
> 
>                 my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
> 
>                 unless($cipherStoreInit) {
>                     ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
>                     $cipherStoreInit = 1;
>                 }
> 
>                 ariba::Ops::Startup::Apache::generateProxyFilesForRole($me, $role);     
>                 ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>                 if ($role eq "backup-monserver") {
>                     ariba::Ops::Startup::Common::launchCopyFromSharedFs($me, $masterPassword, $shortHost, "-nomailq");
>                 } elsif ($role eq "monserver") {
>                     ariba::Ops::Startup::Common::launchCopyToSharedFs($me, $masterPassword, $shortHost);
>                     ariba::Ops::Startup::Common::launchLogfileWatcher($me);
> 
>                     for my $dc (ariba::Ops::ProductAPIExtensions::datacentersForProducts($me)) {
>                         if (ariba::Ops::Startup::Monitoring::shouldRunNetworkSNMPForServiceAndDatacenter($service, $dc)) {
>                             ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/snmp/rebuild-queries -l $dc -c -i $INSTALLDIR/etc/system.cfg $INSTALLDIR/etc/network.cfg");
>                         } else {
>                             ariba::Ops::Startup::Common::launchCommandFeedResponses("$INSTALLDIR/bin/snmp/rebuild-queries -l $dc -c -i $INSTALLDIR/etc/system.cfg");
>                         }
>                     }
>                 }
>             }
> 
>             my @monitorProduct = ($me);
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@monitorProduct);
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/monhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{"monserver"} = 1;
>             $rolesLaunched{"backup-monserver"} = 1;
>         }
> 
>         if ( ($prodname eq 'mon') && (
>             $role eq "replication-source" || 
>             $role eq "database" ||
>             $role eq "product-db-server" || 
>             $role eq "tapebackup-server" || 
>             $role eq "replication-dest" || 
>             $role eq "dataguard-dest" || 
>             $role eq "replication-dest-dr" || 
>             $role eq "veritas-storage" ||
>             $role eq "db-server" ||
>             $role eq "hadoop-server" ||
>             $role eq "replication-dest-reporting" ||
>             $role eq "hanadatabase" ||
>             $role eq "hana-backup" ||
>             $role eq "hana-db-server" ||
>             $role eq "srs-server" ||
>             $role eq "mastercard" ||
>             $role eq "tls-security" ) ) {
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::Ops::Startup::Monitoring::createSymLinks($ENV{'BUILDNAME'});
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
> 
>             #
>             # make sure this doesn't get run twice...
>             #
>             unless($cipherStoreInit) {
>                 ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
>                 $cipherStoreInit = 1;
>             }
> 
>             $rolesLaunched{"tapebackup-source"} = 1;
>             $rolesLaunched{"replication-source"} = 1;
>             $rolesLaunched{"product-db-server"} = 1;
>             $rolesLaunched{"replication-dest"} = 1;
>             $rolesLaunched{"dataguard-dest"} = 1;
>             $rolesLaunched{"db-server"} = 1;
>             $rolesLaunched{"replication-dest-dr"} = 1;
>             $rolesLaunched{"replication-dest-reporting"} = 1;
>             $rolesLaunched{"database"} = 1;
>             $rolesLaunched{"hadoop-server"} = 1;
>             $rolesLaunched{"hanadatabase"} = 1;
>             $rolesLaunched{"hana-db-server"} = 1;
>             $rolesLaunched{"srs-server"} = 1;
>             $rolesLaunched{"mastercard"} = 1;
>             $rolesLaunched{"tls-security"} = 1;
>         }
>      
>         if ($role eq "monitor" && $prodname eq "anl") {
>             ariba::Ops::Startup::ANL::createDBExportDir($me);
>         }
> 
>         if ($role eq "aes-webserver") {
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledASPProducts($service);
>             ariba::Ops::Startup::Apache::writeModJKConfigFile($me, $role, \@products);
>             ariba::Ops::Startup::Apache::writeModWLConfigFile($me, $role, \@products);
>             exit(ariba::Ops::Startup::Common::EXIT_CODE_OK()) if $genWoConf;
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/webhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@products);
> 
>             ariba::Ops::Startup::Apache::configureHttpdForASPProducts($templateFile,$confFile,$role,$me);
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile);
>             ariba::Ops::Startup::Apache::start($me, $confFile);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "presentation" || $role eq "market" || $role eq "sourcingadmin" || $role eq "sourcing") {
> 
>             ariba::Ops::Startup::AES::setRuntimeEnv($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::AES::makeAttachmentDir($me);
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             ariba::Ops::Startup::AES::launch($me, $role);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq "analysis" ) {
>             ariba::Ops::Startup::Tomcat::setASPRuntimeEnv($me);     
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             # create directories that holds customer provided data
>             ariba::Ops::Startup::ANL::createCustomerSpecificDirectories($me);
> 
>             ariba::Ops::Startup::ANL::launch($me, \@launchApps, $role, $masterPassword);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq "acm" ) {
> 
>             ariba::Ops::Startup::Tomcat::setASPRuntimeEnv($me);     
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             ariba::Ops::Startup::ACM::launch($me, \@launchApps, $role, $masterPassword);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         #
>         # A generic tomcat app launching block
>         #
>         if ( $role eq "tomcatapps" || $role eq "spotbuyapp") {
>             ariba::Ops::Startup::Tomcat::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             if ($role eq "spotbuyapp") {
>                 push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, $prodname, \@launchApps, $role, $communityName, $masterPassword));
>             }
>             else {
>                 ariba::Ops::Startup::Tomcat::launch($me, $prodname, \@launchApps, $role, $communityName, $masterPassword);
>             }
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
> 
>         if ($role =~ /^springboot-/) {
>             push(@appInstancesLaunched, ariba::Ops::Startup::Springboot::launch($me, \@launchApps, $role, $communityName, $masterPassword));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "redis" && !$rollingStart) {
>             push(@appInstancesLaunched, ariba::Ops::Startup::Redis::launch($me, \@launchApps, $role));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq "buyerui" ||
>              $role eq "buyer" ||
>              $role eq "buyertask" ||
>              $role eq "buyercatalog" ||
>              $role eq "buyeradmin"
>             ) {
> 
>             ariba::Ops::Startup::Tomcat::setRuntimeEnv($me);
> 
>             my $additionalAppParamsHashRef;
>             # setup qual test env for each node, if needed
>             if ($me->singleHostForRoleInCluster('testserver')) {
>                 $additionalAppParamsHashRef = ariba::Ops::Startup::TestServer::composeSeleniumArgs($me);
>             }
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             if ($role eq "buyerui") {
>                 ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer, $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             # run load meta. Do not launch appinstances if it fails
>             unless (ariba::Ops::Startup::DB::runLoadMeta($me, $masterPassword, $fullStart)) {
>                 print "Error: Loadmeta command returned error, launching of appinstances skipped.  Exiting!\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ABORT());
>             }
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, "buyer", \@launchApps, $role, $communityName, $masterPassword, undef, $additionalAppParamsHashRef));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
>         }
> 
>         if ( $role =~ /^(ss|cdbuyer)ui$/     || 
>              $role =~ /^(ss|cdbuyer)task$/   || 
>              $role =~ /^(ss|cdbuyer)admin$/ ) {
> 
>             ariba::Ops::Startup::Tomcat::setASPRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>                 # start xvfb server only on the nodes that need it
>             if ($role eq "ssui" ) {
>                 ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             # run load meta. Do not launch appinstances if it fails
>             unless (ariba::Ops::Startup::DB::runLoadMeta($me, $masterPassword, $fullStart)) {
>                 print "Error: Loadmeta command returned error, launching of appinstances skipped.  Exiting!\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ABORT());
>             }
> 
>             my $webInfSubdir = ( $role =~ m/^ss/ ? "sourcing":"buyer" );
>             push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
> 
>             # For S2 only - create symlinks from install-dir/logs to Node Logs, 
>             # to make them available from the UI without exposing other logs
>                     if ( $role =~ /^ss(task|ui)$/ ) {
>                             ariba::Ops::Startup::S2::createSymlinkForS2NodeLogs($me);
>                     }
> 
>         }
> 
>         if ( $role eq "asmopenoffice" ) {
>             ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             push(@appInstancesLaunched, ariba::Ops::Startup::OpenOffice::launch($me, "sourcing", \@launchApps, $role, $communityName, $masterPassword));
>         }
> 
>         if( $role eq "opstools-apps" ) {
>             push(@appInstancesLaunched, ariba::Ops::Startup::Perl::launchApps($me, \@launchApps, "", $role, $communityName, $masterPassword));
>         }
> 
>         if ( $role eq "piwikapps" ) {
>             my $logDir = $me->default('ApacheLogDir');
> 
>             #
>             # create the archiveLogBaseDir on piwik app server so that
>             # log-viewer starts
>             #
>             ariba::rc::Utils::mkdirRecursively( ariba::Ops::Constants->archiveLogBaseDir() );
>             ariba::Ops::Startup::Common::fixArchiveLogDirPermissions(
>                 $service, $prodname, undef
>             );
> 
>             ariba::rc::Utils::mkdirRecursively("$logDir/piwik/monitor");
>             ariba::rc::Utils::mkdirRecursively("$logDir/piwik/logs");
> 
>             my $sharedFS = $me->default('shared-filesystem');
>             ariba::rc::Utils::mkdirRecursively($sharedFS);
> 
>             my $piwik = ariba::rc::InstalledProduct->new();
>             require ariba::Ops::Startup::Monitoring;
>             ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 0}, $me);
>             $cipherStoreInit = 1;
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::PHP::launchApps($me, \@launchApps, "", $role, $communityName, $masterPassword));
>         }
> 
>         if ( $role eq "poemapps" ) {
>             unless($cipherStoreInit) {
>                 ariba::Ops::Startup::Monitoring::initializeCipherStoreWithCOnditions($me, {'user' => 0}, $me);
>             }
>         }
> 
>         if ( $role eq "asmui" ||
>              $role eq "asmsvui" ||
>              $role eq "asmglobaltask" ||
>              $role eq "asmaoddatasync" ||
>              $role eq "asmtask" ||
>              $role eq "asmadmin" ||
>              $role eq "sdbui" ||
>              $role eq "sdbtask"
>             ) {
>             ariba::Ops::Startup::Tomcat::setRuntimeEnv($me);
>             
>             my $additionalAppParamsHashRef;
>             # setup qual test env for each node, if needed
>             if ($me->singleHostForRoleInCluster('testserver')) {
>                 $additionalAppParamsHashRef = ariba::Ops::Startup::TestServer::composeSeleniumArgs($me);
>             }
> 
>             ariba::Ops::Startup::S4::createSymlinkForSystemRealmScratchArea($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             # start xvfb server only on the nodes that need it
>             if ($role eq "asmui" || $role eq "asmsvui" || $role eq "sdbui") {
>                 ariba::Ops::Startup::Common::startVirtualFrameBufferServer($me->default('Ops.XDisplay'));
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
>             # run load meta. Do not launch appinstances if it fails
>             unless (ariba::Ops::Startup::DB::runLoadMeta($me, $masterPassword, $fullStart)) {
>                 print "Error: Loadmeta command returned error, launching of appinstances skipped.  Exiting!\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ABORT());
>             }
> 
>             my $webInfSubdir = 'sourcing';
>             if($prodname eq 'sdb') {
>                 $webInfSubdir = 'sdb';
>             }
>             push(@appInstancesLaunched, ariba::Ops::Startup::Tomcat::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword, undef, $additionalAppParamsHashRef));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
> 
>         }
> 
> 
>         if ( $role eq "indexmgr" ||
>              $role eq "shardmgr" ||
>              $role eq "shardwriterosgi" ||
>              $role eq "searchcore" ||  
>              $role eq "testserverosgi" ||
>              $role eq "searchmgr"
>             ) {
>             ariba::Ops::Startup::OSGI::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Arches::writeConfFiles($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ## 1-DET96F - Create and mount ramdisk for shardwriter and searchcore nodes
>             if( $role =~ /shardwriter/ || $role =~ /searchcore/ ){
>                 ariba::Ops::Startup::Arches::createRamdisk( $me );
>             }
>                 
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             my $webInfSubdir = 'arches';
>             push(@appInstancesLaunched, ariba::Ops::Startup::OSGI::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword));
> 
>             $rolesLaunched{$role} = 1;
>             $maxTimeToWaitForStart = 25*60; # 25 mins
> 
>         }
>                 
>         if( $role eq "lily" ){
>             ariba::Ops::Startup::LilyNode::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::LilyNode::launch($me, \@launchApps, $role, $communityName));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if( $role eq "solr" || $role =~ /^aucsolr/ ){
>             ariba::Ops::Startup::Solr::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($logDir) {
>                     ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             if ($archiveLogDir) {
>                     ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
> 
>             unless ( $cipherStoreInit ){
>                 ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 1}, $me);
>                 $cipherStoreInit = 1;
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             if ( $role =~ /auc/ ){ ## For Community/AUC/UEX make apahe log dir for Solr logs
>                 my $SUDO = ariba::rc::Utils::sudoCmd();
>                 my $user = $me->deploymentUser();
>                 r("$SUDO mkdir -p " . $me->default('ApacheLogDir'));
>                 r("$SUDO chown -R $user:ariba " . $me->default('ApacheLogDir'));
> 
>                 ## Apparently the SOLR nodes also need the filestore ...
>                 ## CR# : 1-DFUN3P
>                 ## make Drupal File Storage directory:
>                 my $fileStore = $me->default('AUC.FileStore');
>                 unless ( -e $fileStore ){
>                     r("$SUDO mkdir -p $fileStore");
>                 }
>                 
>                 unless ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ) {
>                     ## Open FH to /dev/null and select it, saving the old FH
>                     open my $DEVNULL, '>', '/dev/null' or die "Error redirecting to /dev/null: $!\n";
>                     my $oldFH = select $DEVNULL;
> 
>                     ## Symlink this directory into the build:
>                     unless ( symlink("$fileStore", "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/") ){
>                         ## If the above 'symlink' failed, try this:
>                         r("ln -s $fileStore $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/ 2>&1 > /dev/null");
>                     }
>                     ## I still don't feel 100% comfortable this symlink will get created so ...
>                     if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" ){
>                         ariba::Ops::Startup::Common::makeSymlink( $fileStore, "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/" );
>                     }
>                     ## And, if the link is still not there, print an error message:
>                     if ( ! -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                         warn "ERROR: could not create symlink '$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files'!!\n";
>                     }
>                     ## Reset filehandle
>                     select $oldFH;
>                 }
> 
>                 ## And if it exists change ownership to the deployment user
>                 if ( -e "$ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files" ){
>                     if ( $user ){
>                         r("$SUDO chown $user:ariba $ENV{'ARIBA_DEPLOY_ROOT'}/drupal/sites/default/files");
>                     } else {
>                         warn "ERROR: Could not change ownership of created directories, couldn't retrieve deploymentUser from Product!\n";
>                     }
>                 }
>             }
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Solr::launch($me, \@launchApps, $role, $communityName));
>             $rolesLaunched{$role} = 1;
>         }
> 
> 
>         if ($role eq "seleniumrc") {
> 
>             ariba::Ops::Startup::SeleniumServer::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             print "Starting Selenium associated XVFB processes...\n";
> 
>             my $result = ariba::Ops::Startup::SeleniumServer::startXVFB($me, $role, \@launchApps);
> 
>             unless ($result) {
>                 print "Error starting selenium XVFB processes: got $result\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_ERROR());
>             }
> 
>             print "Starting Selenium RC processes...\n";
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::SeleniumServer::startSeleniumRC($me, $role, \@launchApps));
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "testserver") {
> 
>             ariba::Ops::Startup::TestServer::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my @appsToClean = @launchApps;
> 
>             if ($startSpecificRoles) {
>                 push(@appsToClean, "TestServer");
>             }
> 
>             my $logDir = $me->default('System.Logging.DirectoryName');
>             if ($logDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($logDir, ariba::Ops::Constants->systemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             my $archiveLogDir = $me->default('System.Logging.ArchiveDirectoryName');
>             if ($archiveLogDir) {
>                 ariba::Ops::Startup::Common::symlinkAdditionalLogDir($archiveLogDir, ariba::Ops::Constants->archivedSystemLogsSubdir(), $service, $prodname, $customer);
>             }
>             
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             my $product = ariba::rc::InstalledProduct->new();
>             my $productName = $product->name();
> 
>             #FIXME this is probably wrong for AN
>             my $webInfSubdir = ( $productName =~ /s4/ ? "sourcing":$productName );
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::TestServer::launch($me, $webInfSubdir, \@launchApps, $role, $communityName, $masterPassword, undef));
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "migration-ui" ) {
> 
>             mkdirRecursively( dirname($main::INSTALLDIR) . "/logs" );
>             mkdirRecursively( $me->default("PE.PHASE1LOCATION" ) );
> 
>             my $tmpDir = $me->default('Ops.BastionHostTempDir') ;
>             mkdirRecursively( $tmpDir ) if $tmpDir;
> 
>             ariba::Ops::Startup::Common::createSymLinks(
>                 $ENV{'BUILDNAME'}, { "docroot/logs" => "logs", }, 1
>             );
> 
>             ariba::Ops::Startup::Common::createSymLinks(
>                 $ENV{'BUILDNAME'}, { "etc" => "etc", }
>             );
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my @extractProduct = ($me);
>             ariba::Ops::Startup::Apache::buildDocRoot($me,\@extractProduct);
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/procuriextractionhttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             my @products = ariba::Ops::Startup::Common::loadInstalledProducts($service);
>             unless($cipherStoreInit) {
>                 require ariba::Ops::Startup::Monitoring;
>                 ariba::Ops::Startup::Monitoring::initializeCipherStore($me, @products);
>                 $cipherStoreInit = 1;
>             }
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ($role eq "logi-server" ) {
> 
>             ariba::Ops::Startup::Logi::setRuntimeEnv($me);
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             my $templateFile = "$ENV{'ARIBA_CONFIG_ROOT'}/logihttpd.conf";
>             my $confFile = "$ENV{'ARIBA_CONFIG_ROOT'}/httpd-$role.conf";
>             my $defines = ariba::Ops::Startup::Apache::configureHttpdForWebObjects(
>                 $templateFile,$confFile,$role,$me
>             );
> 
>             ariba::Ops::Startup::Logi::createDirs($me);
> 
>             require ariba::Ops::Startup::Monitoring;
>             ariba::Ops::Startup::Monitoring::initializeCipherStoreWithConditions($me, {'user'=> 0}, $me);
>             $cipherStoreInit = 1;
> 
>             ariba::Ops::Startup::Common::symlinkAdditionalLogDir(ariba::Ops::Startup::Apache::apacheLogDir(), "apache-logs", $service, $prodname, $customer);
>             ariba::Ops::Startup::Apache::stop($me, $confFile, $defines);
>             ariba::Ops::Startup::Apache::start($me, $confFile, $defines);
> 
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq 'hadoop-journal'      ||
>              $role eq 'hadoop-name'         ||
>              $role eq 'hadoop-secondary'    || 
>              $role eq 'hadoop-data'         || 
>              $role eq 'hadoop-task'         || 
>              $role eq 'hadoop-jobtracker'   ||
>              $role eq 'ha-jobtracker'       ||
>              $role eq 'hadoop-zkfc'         ||
>              $role eq 'mapreduce-zkfc'      ||
>              $role eq 'hadoop-thrift' ) {
>             ariba::Ops::Startup::Hadoop::setRuntimeEnv($me, $role);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Hadoop::createDirs($me);
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             if ($role eq 'hadoop-jobtracker' || $role eq 'ha-jobtracker') {
>                 my @appsLaunched = ariba::Ops::Startup::Hadoop::launch($me, \@launchApps, $role, $communityName);
> 
>                 last unless @appsLaunched;
>                 push(@appInstancesLaunched, @appsLaunched);
>             } else {
>                 push(@appInstancesLaunched, ariba::Ops::Startup::Hadoop::launch($me, \@launchApps, $role, $communityName));
>             }
>             $rolesLaunched{$role} = 1;
> 
>         }
>        
>          if ( $role eq 'hsim-zookeeper' ) {
>             ariba::Ops::Startup::ZooKeeper::setRuntimeEnv($me);
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
>             ariba::Ops::Startup::Enode::createDirs($me);
>             push(@appInstancesLaunched, ariba::Ops::Startup::ZooKeeper::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>          }
> 
> 
> 
>         if ( $role eq 'zookeeper' ) {
>             ariba::Ops::Startup::ZooKeeper::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Hadoop::createDirs($me, $me->default('ZooKeeper.DataDir'));
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::ZooKeeper::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         if ( $role =~ /^mobile-/ ) {
>             ariba::Ops::Startup::Mobile::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
> 
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Mobile::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         if ( $role eq 'hbase-master' ||
>              $role eq 'hbase-region' ||
>              $role eq 'hbase-thrift' ) {
>             ariba::Ops::Startup::Hbase::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Hadoop::createDirs($me);
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Hbase::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         if ( $role eq 'enode' ||
>              $role eq 'lbnode' ) {
>             ##updating simulator.config.xml file for enode and lbnode too HOA-43074 
>             ariba::Ops::Startup::ZooKeeper::setRuntimeEnv($me);
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Enode::setRuntimeEnv($me);
>             push(@appInstancesLaunched, ariba::Ops::Startup::Enode::launch($me, \@launchApps, $role, $communityName, $masterPassword));
>             $rolesLaunched{$role} = 1;
>         }
> 
>         if ( $role eq 'flume-master' ||
>              $role eq 'flume' ) {
>             ariba::Ops::Startup::Flume::setRuntimeEnv($me);
> 
>             ariba::Ops::Startup::Hadoop::writeXmlConfFiles($me, $role);
> 
>             ariba::Ops::Startup::Common::startShell() if $startShell;
>             
>             ariba::Ops::Startup::Logi::createDirs($me);
>             ariba::rc::Utils::mkdirRecursively($ENV{'LOGSDIR'});
> 
>             ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($me->service());
> 
>             push(@appInstancesLaunched, ariba::Ops::Startup::Flume::launch($me, \@launchApps, $role, $communityName));
> 
>             $rolesLaunched{$role} = 1;
> 
>         }
> 
>         #
>         # Arches symlink to ariba.catalog.indexadapter.jar in buyer build
>         # Create an instance of buyer / arches product so we can get current build information to construct symlink
>         #
>         if ($prodname eq 'arches') {
>             if (ariba::rc::InstalledProduct->isInstalled('buyer', $me->service())) {
>                 my $buyer = ariba::rc::InstalledProduct->new('buyer', $me->service());
> 
>                 if ( $buyer->servesRoleInCluster($hostname, 'archeshosts', $clusterName) ||
>                      $buyer->servesRoleInCluster($hostname, 'dr-archeshosts', $clusterName) ) {
>                     ariba::Ops::Startup::Arches::createSymLinksForBuyerJar($me, $buyer);
>                 }
>             }
>         }
>         if ($prodname eq "buyer") {
>             if (ariba::rc::InstalledProduct->isInstalled('arches', $me->service())) {
>                 my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
> 
>                 if ( $me->servesRoleInCluster($hostname, 'archeshosts', $clusterName) ||
>                      $me->servesRoleInCluster($hostname, 'dr-archeshosts', $clusterName) ) {
>                     ariba::Ops::Startup::Arches::createSymLinksForBuyerJar($arches, $me);
>                 }
>             } 
>         }
> 
>         #
>         # This is needed so that we run startup-hooks for roles that
>         # required no other action (and were therefore not in the list)
>         #
>         unless($rolesLaunched{$role}) {
>             $rolesLaunched{$role} = 1;
>         }
>     }
> 
>     # run different role hooks
>     # This should take the rolesToLaunch array not rolesLaunched
>     ariba::Ops::Startup::Common::runStartupHooks($me, \%rolesLaunched, 'install');
> 
>     #
>     # sleep after start if it was a rolling restart,
>     # and we launched one of the roles that needs this sleep
>     #
>     if ($rollingStart && $maxTimeToWaitForStart && @appInstancesLaunched) {
>         unless (ariba::Ops::Startup::Common::waitForAppInstancesToInitialize(\@appInstancesLaunched, $maxTimeToWaitForStart)) {
>             print "Error: All appinstances did not fully initialize in $maxTimeToWaitForStart sec(s).\n";
>                 exit(ariba::Ops::Startup::Common::EXIT_CODE_TIMEOUT());
>         }
>     }
> 
>     if ($startSpecificApps) { 
> 
>         my $error = 0;
> 
>         for my $app (grep {/\d/} @launchApps) {
>             my $found = 0;
>             for my $appInstance (@appInstancesLaunched) {
>                 if ( $app eq $appInstance->instanceName() || 
>                      $app eq $appInstance->workerName() ) {
>                     $found = 1;
>                     last;
>                 }
>             }
> 
>             unless ($found) {
>                 print "ERROR: $app does not exist.\n";
>                 $error = 1;
>             }
>                 
>         }
> 
>         if ($error) {
>             print "Applications instances available : \n\t";
>                         
>             my @appInstances = grep {$_->host() eq ariba::Ops::NetworkUtils::hostname()} $me->appInstances();
>             print join("\n\t", map {"Instance : " . $_->instanceName() . "   (role : " . $_->launchedBy() . ", cluster : ". $_->cluster() .")" } @appInstances);
>             print "\n";
>         }
>     }
> }
> 
> ##################################################################################
> # This method is responsible for generating L2P Mapping file during server startup
> ###################################################################################
> sub writeL2PMappingFile
> {
>     my $currentSSWS = shift;
>     my $productRef  = shift;
>     my @products    = @$productRef;
> 
>     for my $product (@products) {
>         my $productName = $product->name();
>         if( ($productName eq "buyer") || ($productName eq "s4") ){
>                 my @newInstances = $product->appInstances();
>                 my $l2pContentSource  = getL2PContentSource($product);
>                 ariba::Ops::L2PMap::generateL2PMapFile($currentSSWS,$productName,\@newInstances,$l2pContentSource);
>         }
>     }
160a1703,1739
> sub getL2PContentSource
> {
>     my $product   = shift;
>     my $buildName = $product->buildName();
>     my $l2pContentSource  = "startup|$buildName:0|$buildName:1";
>     return($l2pContentSource);  
> }
> 
> sub usage
> {
>     my $ver = '$Id: //ariba/services/tools/bin/startup#652 $';
> 
> 
>     print "usage: $0 (version $ver)\n";
>     print "    [wofapp-pattern|wofapp-name]\n";
>     print "    -h : this help\n";
>     print "    -d : run with debug\n";
>     print "    -q : do not print anything, work silently\n";
>     print "    -test : run as test\n";
>     print "    -rolling: will cause startup to wait for initialization to complete\n";
>     print "    -full: will cause full start code to be executed for product (if any)\n";
>     print "    -shell : start a shell with right environment\n";
>     print "    -role : specific role to launch\n";
>     print "    -woconf : just regenerate WebObjects.conf file\n";
>     print "    -readMasterPassword : read password from stdin\n";
>     print "    -cluster <clustername>: which cluster to make active\n";
>     print "    -community <id>: specific community to launch\n";
>     print "    -- args ...: args to pass to the apps\n";
>     print "    wofapp-pattern: pattern like ANCXMLDispatcher\n";
>     print "    wofapp-name: pattern like ANCXMLDispatcher-501\n";
>     print "                 if wofapp* is specified only that piece\n"; 
>     print "                 of service will be started.\n";
>     exit(ariba::Ops::Startup::Common::EXIT_CODE_ERROR());
> }
> 
> 
> main();
161a1741
> __END__
filename:./bin/ws/cache-and-log-size
107,110d106
<             inf_field   => "ssl_session_cache_size",
<             inf_tags    => "web_server=\"$webserver\"",
<             inf_default => 0,
<             group_by    => "$webserver",
124,127d119
<             inf_field   => "error_log_size",
<             inf_tags    => "web_server=\"$webserver\"",
<             inf_default => 0,
<             group_by    => "$webserver",
131d122
<     $queries{'influx_details'} = { measurement => 'ws_cache_log_size' };
filename:./bin/ws/modjk-worker-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
64,66c64
< 	        timeout                         => 600,
<             inf_field                       => "status",
<             inf_default                     => "none",
---
> 	    timeout                         => 600,
68,69c66
<  
<         $queries{'influx_details'} = { measurement => 'ssws_modjk_worker_status' };
---
> 
filename:./lib/FCGI.pm
filename:./lib/ariba/HTTPWatcherPlugin/SSRealms.pm
filename:./lib/ariba/HTTPWatcherPlugin/TomcatAppInstance.pm
filename:./lib/ariba/Ops/Constants.pm
filename:./lib/ariba/Ops/ControlDeploymentHelper.pm
filename:./lib/ariba/Ops/DatasetManager.pm
filename:./lib/ariba/Ops/DateTime.pm
122c122
< 			$retval .= sprintf("%d %s", $time / $times[$i], $names[$i]);
---
> 			$retval .= sprintf("%d %s ", $time / $times[$i], $names[$i]);
filename:./lib/ariba/Ops/FileSystemUtils.pm
filename:./lib/ariba/Ops/HanaControl.pm
filename:./lib/ariba/Ops/MCL/BaseAction.pm
filename:./lib/ariba/Ops/MCL/HadoopAction.pm
filename:./lib/ariba/Ops/MCL/HbaseAction.pm
filename:./lib/ariba/Ops/MCL/MCLAction.pm
filename:./lib/ariba/Ops/MCL/ShellAction.pm
filename:./lib/ariba/Ops/NetworkDevice/BaseDevice.pm
filename:./lib/ariba/Ops/NetworkDevice/inserv.pm
filename:./lib/ariba/Ops/NetworkDevice/ontap.pm
filename:./lib/ariba/Ops/OracleClient.pm
673,674c673,674
< 			while( my $row = $sth->fetchrow_hashref() ) {
< 				push(@results, $row);
---
> 			while( my @row = $sth->fetchrow_array() ) {
> 				push(@results, join($colsep, @row));
filename:./lib/ariba/Ops/ProductConfig/Constants.pm
filename:./lib/ariba/Ops/ProductConfig/Hana.pm
filename:./lib/ariba/Ops/ProductConfig/Oracle.pm
filename:./lib/ariba/Ops/ProductConfig/Utils.pm
filename:./lib/ariba/Ops/Startup/Common.pm
filename:./lib/ariba/Ops/Startup/StartupHooks.pm
filename:./lib/ariba/Ops/Startup/Tomcat.pm
filename:./lib/ariba/monitor/BusinessObjects.pm
filename:./lib/ariba/monitor/Query.pm
1981,1983d1980
<         if( ref($codeOutput) eq 'ARRAY' or ref($codeOutput) eq 'HASH'){
<             return $codeOutput;
<         }
filename:./lib/ariba/monitor/QueryManager.pm
1,3c1,6
< 
< # wing keys can be set in a queries hash as hints to QueryManager:
< #   runForCommunities: create Query object for ',' seperated list of
---
> #
> # $Id: //ariba/services/monitor/lib/ariba/monitor/QueryManager.pm#97 $
> #
> #
> # Following keys can be set in a queries hash as hints to QueryManager:
> #   runForCommunities: create Query object for ',' seperated list of 
6c9
< #   aggregationMethod: rows|counts create an AggregateQuery for
---
> #   aggregationMethod: rows|counts create an AggregateQuery for 
8c11
< #                                rows: combine results using simple addition
---
> #                                rows: combine results using simple addition 
10,11c13,14
< #                                counts: combine results by simply listing
< #                                        each row from results one after
---
> #                                counts: combine results by simply listing 
> #                                        each row from results one after 
24d26
< use Cwd qw( realpath );
25a28
> use ariba::monitor::misc;
27a31
> use ariba::monitor::MonitoringClient;
30,31c34
< use ariba::Ops::Machine;
< 
---
> use ariba::Ops::SharedMemoryChild;
32a36,42
> use ariba::Ops::ServiceController;
> 
> use ariba::Ops::PageUtils;
> use ariba::Ops::PageFilter;
> use ariba::Ops::PageRequest;
> 
> use ariba::monitor::Transit;
36d45
< 
39c48,52
< use DateTime;
---
> 
> use File::Basename;
> use File::Path;
> use Carp;
> 
43c56
< my $monitorDir  = ariba::monitor::misc::monitorDir();
---
> my $monitorDir = ariba::monitor::misc::monitorDir();
46,51c59,63
< sub newWithDetails
< {
<     my $class        = shift;
<     my $qmName       = shift () || die "need queryManagerName";
<     my $productName  = shift;
<     my $serviceName  = shift;
---
> sub newWithDetails {
>     my $class = shift;
>     my $qmName = shift() || die "need queryManagerName";
>     my $productName = shift;
>     my $serviceName = shift;
53,55c65,67
<     my $clusterName  = shift;
<     my $queriesHash  = shift;
<     my $subDir       = shift;
---
>     my $clusterName = shift;  
>     my $queriesHash = shift;
>     my $subDir = shift;
58,59c70
<     if (ref ($clusterName) eq 'HASH')
<     {
---
>     if ( ref($clusterName) eq 'HASH' ) {
61c72
<         undef ($clusterName);
---
>         undef($clusterName);
63c74
<     undef ($clusterName) unless (ariba::rc::Globals::isActiveActiveProduct($productName));
---
>     undef($clusterName) unless ( ariba::rc::Globals::isActiveActiveProduct($productName) );
65c76
<     #
---
>     # 
68,69c79
<     if (ref ($qmName) eq "HASH")
<     {
---
>     if ( ref($qmName) eq "HASH" ) {
73,74c83
<     if (ref ($customerName) eq "HASH")
<     {
---
>     if ( ref($customerName) eq "HASH" ) {
81c90
<     bless ($self, $class);
---
>     bless($self, $class);
93,104c102
<     $self->setTickMetaData(1);
<     if (defined $queriesHash->{"influx_details"})
<     {
<         my $inf = $queriesHash->{"influx_details"};
<         $self->setInflux($inf->{'measurement'});
<         my $script = realpath "$0";
<         $self->setTags($self->_computeTags($productName, $serviceName, $script, $inf->{tags}));
<         delete $queriesHash->{"influx_details"};
<     }
< 
<     if (ref ($queriesHash) eq "HASH")
<     {
---
>     if ( ref($queriesHash) eq "HASH" ) {
106,109c104,105
<     }
<     else
<     {
<         #old style setting of details, with run method on Query
---
>     } else {    
>         #old style setting of details, with run method on Query 
114c110
<     return $self;
---
>     return $self;   
117,121c113,116
< sub generateInstanceName
< {
<     my $class        = shift;
<     my $qmName       = shift;
<     my $productName  = shift;
---
> sub generateInstanceName {
>     my $class = shift; 
>     my $qmName = shift;
>     my $productName = shift;
123,124c118,119
<     my $clusterName  = shift;
<     my $subDir       = shift;
---
>     my $clusterName = shift;
>     my $subDir = shift;
127c122
<     undef ($clusterName) unless (ariba::rc::Globals::isActiveActiveProduct($productName));
---
>     undef($clusterName) unless ( ariba::rc::Globals::isActiveActiveProduct($productName) );
130,131c125
<     if (defined ($customerName))
<     {
---
>     if ( defined($customerName) ) {
134,135c128
<     if (defined ($clusterName))
<     {
---
>     if ( defined($clusterName) ) {
138,139c131
<     if (defined ($subDir))
<     {
---
>     if ( defined($subDir) ) {
148,149c140
< sub objectLoadMap
< {
---
> sub objectLoadMap {
154,156c145,147
<     $$mapRef{'queries'}           = '@ariba::monitor::Query';
<     $$mapRef{'runForCommunities'} = '@SCALAR';
<     $$mapRef{'runForSchemaIds'}   = '@SCALAR';
---
>     $$mapRef{'queries'} =  '@ariba::monitor::Query';
>     $$mapRef{'runForCommunities'} =  '@SCALAR';
>     $$mapRef{'runForSchemaIds'} =  '@SCALAR';
161,162c152,153
< sub dir
< {
---
> 
> sub dir {
168,170c159,160
< sub _computeBackingStoreForInstanceName
< {
<     my $class        = shift;
---
> sub _computeBackingStoreForInstanceName {
>     my $class = shift;
178,179c168
<     if ($instanceName =~ m|^/|)
<     {
---
>     if ($instanceName =~ m|^/|) {
181,183c170
<     }
<     else
<     {
---
>     } else {
187,188c174
<     if ($instanceName !~ m|$qmExtension$|)
<     {
---
>     if ($instanceName !~ m|$qmExtension$|) {
198,222d183
< sub _computeTags
< {
<     my ($self, $productName, $serviceName, $caller, $inf_tags) = @_;
< 
<     my $hostname = ariba::Ops::NetworkUtils::hostname();
<     my $dc       = ariba::Ops::Machine->new()->datacenter();
<     my $tag_str  = qq(product=$productName,dc=$dc,service=$serviceName,ran_on_host=$hostname,ran_by=$caller);
< 
<     ### Return if $tag_str is null
<     return ($tag_str) unless ($inf_tags);
< 
<     ### Escape space
<     $tag_str =~ s/(\s+)/\\$1/g;
< 
<     my @tags = split (/,/, $inf_tags);    ### Append all the other flags, besides product,service etc
<     foreach my $tag (@tags)
<     {
<         next if ($tag =~ /^product/);
<         next if ($tag =~ /^service/);
<         next if ($tag =~ /^dc/);
<         $tag_str .= ",$tag";
<     }
<     return ($tag_str);
< }
< 
227,230c188,190
< sub instancesForProduct
< {
<     my $class    = shift;
<     my $product  = shift;
---
> sub instancesForProduct {
>     my $class = shift;
>     my $product = shift;
232c192
<     my $cluster  = shift;
---
>     my $cluster = shift;
239c199
<     $productRoot .= "/$cluster"  if ($cluster);
---
>     $productRoot .= "/$cluster" if ($cluster);
242,244c202,204
<     opendir (QMDIR, $productRoot) || return @instances;
<     my @contents = grep (!/^\./o, readdir (QMDIR));
<     closedir (QMDIR);
---
>     opendir(QMDIR, $productRoot) || return @instances;
>     my @contents = grep(!/^\./o,readdir(QMDIR));
>     closedir(QMDIR);
246c206
<     @contents = grep (($_ = "$productRoot/$_"), @contents);
---
>     @contents = grep(($_="$productRoot/$_"), @contents);
248,249c208
<     for my $file (sort (grep (-f $_, @contents)))
<     {
---
>     for my $file (sort(grep(-f $_, @contents))) {
253c212
<         push (@instances, $qm);
---
>         push(@instances, $qm);
256,257c215
<     for my $sdir (grep (-d $_, @contents))
<     {
---
>     for my $sdir (grep(-d $_, @contents)) {
259d216
< 
262c219
<         push (@instances, $class->instancesForProduct($sdir));
---
>         push(@instances, $class->instancesForProduct($sdir));
268,269c225,249
< sub DESTROY
< {
---
> sub lastUpdate {
>     my $self = shift;
>     my $instance = $self->instance();
> 
>     my $file = ref($self)->_computeBackingStoreForInstanceName($instance);
> 
>     my $lastmod = (stat($file))[9];
> 
>     return ($lastmod);
> }
> 
> sub _saveStateToFile {
>     my $self = shift;
>     my $recursive = shift;
> 
>     my $prevUmask = umask 000;
> 
>     my $ret = $self->SUPER::_saveStateToFile($recursive);
> 
>     umask $prevUmask;
> 
>     return $ret;
> }
> 
> sub DESTROY {
277,279c257,285
< sub convertQueriesHashToQuery
< {
<     my $self        = shift;
---
> sub lock {
>     my $self = shift;
>     my $lockTries = shift || 720;
> 
>     my $lockFile = $self->_backingStore();
>     my $queryDir = dirname($lockFile);
> 
>     return 1 if dmail::LockLib::haslock($lockFile);
> 
>     mkpath($queryDir) unless -d $queryDir;
> 
>     return(dmail::LockLib::requestlock($lockFile,$lockTries));
> }
> 
> sub unlock {
>     my $self = shift;
> 
>     my $lockFile = $self->_backingStore();
>     my $r = 1;
> 
>     if ( dmail::LockLib::haslock($lockFile) ) {
>         $r = dmail::LockLib::releaselock($lockFile);
>     }
> 
>     return $r;
> }
> 
> sub convertQueriesHashToQuery {
>     my $self = shift;
281c287
<     my $subDir      = shift;
---
>     my $subDir = shift;
285,286c291
<     for my $queryName (sort (keys (%$queriesHash)))
<     {
---
>     for my $queryName ( sort(keys(%$queriesHash)) ) {
295,296c300
<         for my $qmHint (qw(runForCommunities runForSchemaIds aggregationMethod recordAggregateDBFileName))
<         {
---
>         for my $qmHint (qw(runForCommunities runForSchemaIds aggregationMethod recordAggregateDBFileName)) {
301,302c305,306
<         my $aggregateOn           = $qhashRef->{"aggregationMethod"};
<         my $qmHint                = "runForCommunities";
---
>         my $aggregateOn = $qhashRef->{"aggregationMethod"};
>         my $qmHint = "runForCommunities";
305,309c309,312
<         my @communities = (0);
<         if ($qhashRef->{$qmHint})
<         {
<             @communities = split (/\s*,\s*/, $qhashRef->{$qmHint});
<             push (@{$communitiesAndSchemas{"community"}}, @communities);
---
>         my @communities = ( 0 );
>         if ($qhashRef->{$qmHint}) {
>             @communities = split(/\s*,\s*/,$qhashRef->{$qmHint});
>             push(@{$communitiesAndSchemas{"community"}}, @communities);
314,318c317,320
<         my @schemaIds = (0);
<         if ($qhashRef->{$qmHint})
<         {
<             @schemaIds = split (/\s*,\s*/, $qhashRef->{$qmHint});
<             push (@{$communitiesAndSchemas{"schema"}}, @schemaIds);
---
>         my @schemaIds = ( 0 );
>         if ($qhashRef->{$qmHint}) {
>             @schemaIds = split(/\s*,\s*/,$qhashRef->{$qmHint});
>             push(@{$communitiesAndSchemas{"schema"}}, @schemaIds);
326,328c328,329
<         unless (keys (%communitiesAndSchemas))
<         {
<             push (@{$communitiesAndSchemas{"none"}}, @schemaIds);
---
>         unless (keys(%communitiesAndSchemas)) {
>             push(@{$communitiesAndSchemas{"none"}}, @schemaIds);
333,334c334
<         for my $subQuery (keys (%communitiesAndSchemas))
<         {
---
>         for my $subQuery (keys(%communitiesAndSchemas)) {
336,337c336
<             for my $part (@parts)
<             {
---
>             for my $part (@parts) {
341,342c340
<                 if ($aggregateOn)
<                 {
---
>                 if ($aggregateOn) { 
345c343
<                 $querySubDir = $subDir;
---
>                 $querySubDir = $subDir; 
347,348c345
<                 if ($part > 0)
<                 {
---
>                 if ($part > 0) {
351,355c348,350
< 
<                     unless ($qhashRef->{"uiHint"} eq "ignore")
<                     {
<                         if ($qhashRef->{"uiHint"})
<                         {
---
>     
>                     unless($qhashRef->{"uiHint"} eq "ignore") {
>                         if($qhashRef->{"uiHint"}) {
357,359c352
<                         }
<                         else
<                         {
---
>                         } else {
361c354
<                         }
---
>                         } 
363,365c356,357
< 
<                     if ($subDir)
<                     {
---
>                         
>                     if ($subDir) {
367,369c359
<                     }
<                     else
<                     {
---
>                     } else {
374c364,373
<                 $q = ariba::monitor::Query->newFromHash($communityQueryName, $self->productName(), $self->service(), $self->customer(), $self->cluster(), \%communityQueryHash, $querySubDir, $self,);
---
>                 $q = ariba::monitor::Query->newFromHash(
>                     $communityQueryName, 
>                     $self->productName(), 
>                     $self->service(), 
>                     $self->customer(),
>                     $self->cluster(),
>                     \%communityQueryHash,
>                     $querySubDir,
>                     $self,
>                 );
376c375
<                 push (@queryList, $q);
---
>                 push(@queryList, $q);
380c379
<         push (@queries, @queryList);
---
>         push(@queries, @queryList);
382,384c381,393
<         if ($aggregateOn)
<         {
<             $q = ariba::monitor::AggregateQuery->newWithSubQueries($queryName, $self->productName(), $self->service(), $self->customer(), $self->cluster(), $subDir, $aggregateOn, $qhashRef->{'recordAggregateDBFileName'}, $self, @queryList);
---
>         if ($aggregateOn) {
>             $q = ariba::monitor::AggregateQuery->newWithSubQueries(
>                 $queryName,
>                 $self->productName(),
>                 $self->service(),
>                 $self->customer(),
>                 $self->cluster(),
>                 $subDir,
>                 $aggregateOn,
>                 $qhashRef->{'recordAggregateDBFileName'},
>                 $self,
>                 @queryList
>             );
386c395
<             push (@queries, $q);
---
>             push(@queries, $q);
390c399,492
<     $self->setQueries(@queries);
---
>     #print "Following queries are defined in this qm\n";
>     #for my $q (@queries) {
>         #print $q->queryName(), "\n";
>     #}
> 
>     $self->setQueries( @queries ) ;
> }
> 
> #
> # compute a flat list of uiHints (expandos) for display within vm
> #
> sub _expandosInUiForQueryList {
>     my $self = shift;
>     my $allQueries = shift;
>     my @queries = @_;
> 
>     my $name = $self->uiManager() || $self->name();
> 
>     $self->{'uiHints'} = ();
> 
>     for my $query ( @queries ) {
>         my $queryUiHint = $query->uiHint();
>         my $uiHint = $name;
> 
>         next if (!$allQueries && $queryUiHint && $queryUiHint =~ m|^(.*/)?ignore$|i);
> 
>         if ($queryUiHint) {
>             $uiHint .= "/$queryUiHint";
>         }
> 
>         push(@{$self->{'uiHints'}{$uiHint}}, $query);
>     }
> 
>     my @expandos = sort { expandoCmp($a,$b) } (keys(%{$self->{'uiHints'}}));
> 
>     return (@expandos);
> }
> 
> sub expandoCmp {
>     my $a = shift;
>     my $b = shift;
> 
>     my @a = split('/', $a);
>     my @b = split('/', $b);
> 
>     my $max = $#a;
>     if($#b > $#a) {
>         $max = $#b;
>     }
> 
>     #
>     # We check at even "slash" levels first so that aaaa/ora05a/FC0 comes before
>     # aaaa/ora05a-backup in a sort
>     #
>     my $aa = "";
>     my $bb = "";
>     for(my $i = 0 ; $i <= $max ; $i++) {
>         $aa .= $a[$i] if ($a[$i]);
>         $bb .= $b[$i] if ($b[$i]);
>         return($aa cmp $bb) if ($aa cmp $bb);
>     }
> 
>     #
>     # and if they are equal on even slash levels, THEN we do a straight cmp
>     #
>     return($a cmp $b);
> }
> 
> sub expandosInUi {
>     my $self = shift;
>     return $self->_expandosInUiForQueryList(0, $self->queries());
> }
> 
> # same as above, but just for graphables
> sub graphableExpandosInUi {
>     my $self = shift;
>     return $self->_expandosInUiForQueryList(1, $self->graphableQueries());
> }
> 
> #
> # given an expando name find all the Query objects that should be
> # displayed under it (based on uiHint in the Query)
> #
> sub queriesForExpando {
>     my $self = shift;
>     my $uiHint = shift;
> 
>     my @queries;
> 
>     if ($self->{'uiHints'}{$uiHint}) {
>         @queries =  @{$self->{'uiHints'}{$uiHint}};
>     }
> 
>     return @queries;
398,401c500,502
< sub _queriesForExpandoAndChildren
< {
<     my $self     = shift;
<     my $expando  = shift;
---
> sub _queriesForExpandoAndChildren {
>     my $self = shift;
>     my $expando = shift;
406,407c507
<     for my $childExpando (@expandos)
<     {
---
>     for my $childExpando (@expandos) {
410,411c510
<         unless ($childExpando =~ m|^$expando/|)
<         {
---
>         unless ($childExpando =~ m|^$expando/|) {
414c513
<         push (@queries, $self->queriesForExpando($childExpando));
---
>         push(@queries, $self->queriesForExpando($childExpando));
425,428c524,526
< sub statusForExpando
< {
<     my $self     = shift;
<     my $expando  = shift;
---
> sub statusForExpando {
>     my $self = shift;
>     my $expando = shift;
437c535,537
<     my $status = ariba::monitor::Query::combineStatusOfQueries($self->_queriesForExpandoAndChildren($expando, @expandos));
---
>     my $status = ariba::monitor::Query::combineStatusOfQueries(
>         $self->_queriesForExpandoAndChildren($expando, @expandos)
>     );
442,443c542,635
< sub setServerConnection
< {
---
> #
> # get commulative runTime for the expando based on it's own Query objects
> # and any other child expando's Query objects.
> #
> sub runTimeForExpando {
>     my $self = shift;
>     my $expando = shift;
>     my @expandos = @_;
> 
>     my $runTime = 0;
> 
>     for my $query ($self->_queriesForExpandoAndChildren($expando,@expandos)) {
>         $runTime += $query->runTime();
>     }
> 
>     return $runTime;
> }
> 
> #
> # get commulative lastUpdated time for the expando based on it's own 
> # Query objects and any other child expando's Query objects.
> #
> sub lastUpdateForExpando {
>     my $self = shift;
>     my $expando = shift;
>     my @expandos = @_;
> 
>     my $lastUpdate = 0;
> 
>     for my $query ($self->_queriesForExpandoAndChildren($expando, @expandos)) {
>         my $instance = $query->instance();
>         my $file = ref($query)->_computeBackingStoreForInstanceName($instance);
>         my $lastmod = (stat($file))[9];
> 
>         if ($lastmod > $lastUpdate) {
>             $lastUpdate = $lastmod;
>         }
>     }
> 
>     return $lastUpdate;
> }
> 
> #
> # get commulative isStale flag for the expando based on it's own Query objects
> # and any other child expando's Query objects.
> #
> sub isStaleForExpando {
>     my $self = shift;
>     my $expando = shift;
>     my @expandos = @_;
> 
>     for my $query ($self->_queriesForExpandoAndChildren($expando,@expandos)) {
>         if ($query->isStale()) {
>             return 1;
>         }
>     }
> 
>     return 0;
> }
> 
> sub isStale {
>     my $self = shift;
> 
>     my $isStale = 0;
>     for my $query ($self->queries()) {
>         return 1 if $query->isStale();
>     }
> 
>     return 0;
> }
> 
> sub hasGraphableQueries {
>     my $self = shift;
> 
>     for my $query ($self->queries()) {
>         return 1 if $query->isGraphable();
>     }
> 
>     return 0;
> }
> 
> sub graphableQueries {
>     my $self = shift;
> 
>     my @graphableQueries = ();
> 
>     for my $query ($self->queries()) {
>         push(@graphableQueries, $query) if $query->isGraphable();
>     }
> 
>     return @graphableQueries;
> }
> 
> sub setServerConnection {
448,449c640
< sub serverConnection
< {
---
> sub serverConnection {
454,457c645,647
< sub setOracleClient
< {
<     my $self          = shift;
<     my $oracleClient  = shift;
---
> sub setOracleClient {
>     my $self = shift;
>     my $oracleClient = shift;
460,461c650,651
<     if ($connectionTag)
<     {
---
> 
>     if ($connectionTag) {
463,465c653
<     }
<     else
<     {
---
>     } else {
469,480c657,663
<     for my $query ($self->queries())
<     {
<         if (
<             (!$connectionTag && !$query->communityId() && !$query->schemaId())
<             || (   $query->communityId()
<                 && $connectionTag
<                 && $query->communityId() eq $connectionTag)
<             || (   $query->schemaId()
<                 && $connectionTag
<                 && $query->schemaId() eq $connectionTag)
<            )
<         {
---
>     for my $query ( $self->queries() ) {
>         if ((!$connectionTag && !$query->communityId() && !$query->schemaId()) || 
>             ($query->communityId() && $connectionTag &&
>              $query->communityId() eq $connectionTag) ||
>             ($query->schemaId() && $connectionTag &&
>              $query->schemaId() eq $connectionTag)
>          ) {
486,488c669,670
< sub oracleClient
< {
<     my $self          = shift;
---
> sub oracleClient {
>     my $self = shift;
491,492c673
<     if ($connectionTag)
<     {
---
>     if ($connectionTag) {
494,496c675
<     }
<     else
<     {
---
>     } else {
501,504c680,682
< sub setHanaClient
< {
<     my $self          = shift;
<     my $hanaClient    = shift;
---
> sub setHanaClient {
>     my $self = shift;
>     my $hanaClient = shift;
507,508c685,686
<     if ($connectionTag)
<     {
---
> 
>     if ($connectionTag) {
510,512c688
<     }
<     else
<     {
---
>     } else {
516,527c692,698
<     for my $query ($self->queries())
<     {
<         if (
<             (!$connectionTag && !$query->communityId() && !$query->schemaId())
<             || (   $query->communityId()
<                 && $connectionTag
<                 && $query->communityId() eq $connectionTag)
<             || (   $query->schemaId()
<                 && $connectionTag
<                 && $query->schemaId() eq $connectionTag)
<            )
<         {
---
>     for my $query ( $self->queries() ) {
>         if ((!$connectionTag && !$query->communityId() && !$query->schemaId()) ||
>             ($query->communityId() && $connectionTag &&
>              $query->communityId() eq $connectionTag) ||
>             ($query->schemaId() && $connectionTag &&
>              $query->schemaId() eq $connectionTag)
>          ) {
533,535c704,705
< sub hanaClient
< {
<     my $self          = shift;
---
> sub hanaClient {
>     my $self = shift;
538,539c708
<     if ($connectionTag)
<     {
---
>     if ($connectionTag) {
541,543c710
<     }
<     else
<     {
---
>     } else {
548,551c715,717
< sub setMySQLClient
< {
<     my $self          = shift;
<     my $mySQLClient   = shift;
---
> sub setMySQLClient {
>     my $self = shift;
>     my $mySQLClient = shift;
554,555c720
<     if ($connectionTag)
<     {
---
>     if ($connectionTag) {
557,559c722
<     }
<     else
<     {
---
>     } else {
563,574c726,732
<     for my $query ($self->queries())
<     {
<         if (
<             (!$connectionTag && !$query->communityId() && !$query->schemaId())
<             || (   $query->communityId()
<                 && $connectionTag
<                 && $query->communityId() eq $connectionTag)
<             || (   $query->schemaId()
<                 && $connectionTag
<                 && $query->schemaId() eq $connectionTag)
<            )
<         {
---
>     for my $query ( $self->queries() ) {
>         if ((!$connectionTag && !$query->communityId() && !$query->schemaId()) || 
>             ($query->communityId() && $connectionTag &&
>              $query->communityId() eq $connectionTag) ||
>             ($query->schemaId() && $connectionTag &&
>              $query->schemaId() eq $connectionTag)
>          ) {
580,582c738,739
< sub mySQLClient
< {
<     my $self          = shift;
---
> sub mySQLClient {
>     my $self = shift;
585,586c742
<     if ($connectionTag)
<     {
---
>     if ($connectionTag) {
588,590c744
<     }
<     else
<     {
---
>     } else {
595,597c749,750
< sub setSQLConnectInfoFromDBConnection
< {
<     my $self   = shift;
---
> sub setSQLConnectInfoFromDBConnection {
>     my $self = shift;
603,609c756,761
< sub setSQLConnectInfo
< {
<     my $self          = shift;
<     my $user          = shift;
<     my $password      = shift;
<     my $sid           = shift;
<     my $hostname      = shift;
---
> sub setSQLConnectInfo {
>     my $self = shift;
>     my $user = shift;
>     my $password = shift;
>     my $sid = shift;
>     my $hostname = shift;
617,618c769
<     unless ($oracleClient->connect(20, 4))
<     {
---
>     unless ($oracleClient->connect(20,4)) {
621,623c772
<     }
<     else
<     {
---
>     } else {
630,631c779
< sub setSQLConnectInfoForMySQL
< {
---
> sub setSQLConnectInfoForMySQL {
634c782
<     my $user     = shift;
---
>     my $user = shift;
637c785
<     my $port     = shift;
---
>     my $port = shift;
647,648c795
<     unless ($mySQLClient->connect(20, 4))
<     {
---
>     unless ($mySQLClient->connect(20,4)) {
651,653c798
<     }
<     else
<     {
---
>     } else {
656a802
> 
660,661c806
< sub setSQLConnectInfoForHana
< {
---
> sub setSQLConnectInfoForHana {
664c809
<     my $user     = shift;
---
>     my $user = shift;
667c812
<     my $port     = shift;
---
>     my $port = shift;
677,678c822
<     unless ($hanaClient->connect(20, 4))
<     {
---
>     unless ($hanaClient->connect(20,4)) {
681,683c825
<     }
<     else
<     {
---
>     } else {
686a829
> 
690,693c833,835
< sub setSQLConnectInfoFromOracleClient
< {
<     my $self          = shift;
<     my $oracleClient  = shift;
---
> sub setSQLConnectInfoFromOracleClient {
>     my $self = shift;
>     my $oracleClient = shift;
699,700c841
<     unless ($oracleClient->isa("ariba::Ops::OracleClient"))
<     {
---
>     unless ( $oracleClient->isa("ariba::Ops::OracleClient") ) {
707,710c848,850
< sub setSQLConnectInfoFromHanaClient
< {
<     my $self          = shift;
<     my $hanaClient    = shift;
---
> sub setSQLConnectInfoFromHanaClient {
>     my $self = shift;
>     my $hanaClient = shift;
716,717c856
<     unless ($hanaClient->isa("ariba::Ops::HanaClient"))
<     {
---
>     unless ( $hanaClient->isa("ariba::Ops::HanaClient") ) {
724,727c863,865
< sub setSQLConnectInfoFromMySQLClient
< {
<     my $self          = shift;
<     my $mySQLClient   = shift;
---
> sub setSQLConnectInfoFromMySQLClient {
>     my $self = shift;
>     my $mySQLClient = shift;
733,734c871
<     unless ($mySQLClient->isa("ariba::Ops::MySQLClient"))
<     {
---
>     unless ( $mySQLClient->isa("ariba::Ops::MySQLClient") ) {
741,744c878,880
< sub setAQLClient
< {
<     my $self          = shift;
<     my $aqlClient     = shift;
---
> sub setAQLClient {
>     my $self = shift;
>     my $aqlClient = shift;
747,748c883,884
<     if ($connectionTag)
<     {
---
> 
>     if ($connectionTag) {
750,752c886
<     }
<     else
<     {
---
>     } else {
756,757c890
<     for my $query ($self->queries())
<     {
---
>     for my $query ( $self->queries() ) {
762,764c895,896
< sub AQLClient
< {
<     my $self          = shift;
---
> sub AQLClient {
>     my $self = shift;
767,768c899
<     if ($connectionTag)
<     {
---
>     if ($connectionTag) {
770,772c901
<     }
<     else
<     {
---
>     } else {
777,780c906,908
< sub setAQLConnectInfo
< {
<     my $self          = shift;
<     my $product       = shift;
---
> sub setAQLConnectInfo {
>     my $self = shift;
>     my $product = shift;
793,796c921,923
< sub setAQLConnectInfoFromAQLClient
< {
<     my $self          = shift;
<     my $aqlClient     = shift;
---
> sub setAQLConnectInfoFromAQLClient {
>     my $self = shift;
>     my $aqlClient = shift;
802,803c929
<     unless ($aqlClient->isa("ariba::Ops::AQLClient"))
<     {
---
>     unless ( $aqlClient->isa("ariba::Ops::AQLClient") ) {
810,811c936
< sub run
< {
---
> sub run {
812a938,941
>     my $runTime = 0;
>     my $checkTime = time();
> 
>     $self->_inProgress();
814,815c943
<     for my $query ($self->queries())
<     {
---
>     for my $query ( $self->queries() ) {
820a949,950
>         $runTime += $query->runTime();
>         $checkTime = $query->checkTime() if ($query->checkTime() > $checkTime);
821a952,956
>     
>     $self->setCheckTime($checkTime);
>     $self->setRunTime($runTime);
>     $self->setIsStale(0);
>     $self->setTotalThreadTime($runTime);
824,825c959
< sub generateTickMetaData
< {
---
> sub runInParallel {
826a961
>     my $threadCount = shift;
828c963,969
<     my $service = $self->service();
---
>     # this is really to protect against shared memory problems
>     if ( $threadCount > 50 ) {
>         $threadCount = 50;
>     }
>     
>     my @queries = $self->queries();
>     my $queryCount = scalar( @queries );
830,831c971,991
<     ### Hardcoding to run only for test,dev and prod
<     return if ( $service ne 'test' and $service ne 'dev' and $service ne 'prod');
---
>     if ( $threadCount > $queryCount ){
>         $threadCount = $queryCount;
>     }
> 
>     $self->_inProgress();
> 
>     my $threadRunTime = 0;
> 
>     my $startTime = time;
> 
>     my $currentQuery = 0;
>     my $launchedQueries = 0;
> 
>     foreach my $query ( @queries ) {
>         $currentQuery++;
>         next if $query->skip();
> 
>         $self->_launchChildQuery($query);
>         $launchedQueries++;
> 
>         last if $launchedQueries >= $threadCount;
833,888d992
<     my $measurement_name = $self->{_info}->{influx};
<     return unless ( $measurement_name );
< 
<     my $dt = DateTime->today( time_zone => 'local' );
<     my $year  = $dt->year;
<     my $month = sprintf( "%02d", $dt->month() );
<     my $day   = sprintf( "%02d", $dt->day() );
<     my $d     = "$year-$month-$day";
<        
<     my $nfs_loc   = { dev => "/subzero/opsdumps/$d/stratus", test => "/subzero/opsdumps/$d/stratus", prod => "/nfs/never/monprod/stratus/$d" };
< 
<     ### Create base directory, if not present with 777, so other non mon<service> scripts can write the data
<     my $fs = $nfs_loc->{$service};
<     unless ( -e $fs )
<     {
<         ariba::rc::Utils::mkdirRecursively($fs);
<         chmod(0777,$fs);
<     }
< 
<     my $meta_data = ();
<     for my $query ($self->queries())
<     {
<         my $inf_field   = $query->{_info}->{inf_field};
<         my $sql         = $query->{_info}->{sql};
< 
<         next if ( !$inf_field && !$sql );
< 
<         my @fields ;
<         if ( $sql )
<         {
<             if ( ref($query->{_info}->{results}) eq 'ARRAY')
<             {
<                 my $hash = $query->{_info}->{results}->[0];
<                 my @tempf= ( keys %{$hash});
<                 @fields = map{ lc($_)} @tempf;
<             }
<             if ( ref($query->{_info}->{results}) eq 'HASH')
<             {
<                 foreach my $key (keys %{$query->{_info}->{results}})
<                 {
<                         push(@fields, lc($key));
<                 }       
<             }       
<         } else {
<             push(@fields, $inf_field);
<         }       
< 
<         foreach my $field ( @fields )
<         {    
<             if ( $query->{_info}->{warn} || $query->{_info}->{crit} )
<             {       
<                 $meta_data->{$measurement_name}->{$field}->{info} = $query->{_info}->{info};
<                 $meta_data->{$measurement_name}->{$field}->{warn} = $query->{_info}->{warn};
<                 $meta_data->{$measurement_name}->{$field}->{crit} = $query->{_info}->{crit};
<             }       
<         }
891,903c995,1032
<     ### Generate flat file
<     my $script_name = ariba::Ops::Utils::basename($0);
<     my $f_name = qq($fs/threshold_).qq($script_name).qq(.txt);
<     foreach my $measurement ( keys %{$meta_data} )
<     {
<         open(my $fh, ">", $f_name) || die "error:$!\n";
<         foreach my $field ( keys %{$meta_data->{$measurement}} )
<         {
<             my $row = qq($measurement;$field;);
<             my $field_hash = $meta_data->{$measurement}->{$field};
<             foreach my $key ( keys %{$field_hash} )
<             {
<                 $row .= qq($key:$field_hash->{$key};);
---
>     my $grownKids = 0;
> 
>     while( 1 ) {
> 
>         #wait
> 
>         my $kid = (ariba::Ops::SharedMemoryChild->waitForChildren(1))[0];
>         unless( defined( $kid )) {
>             die "kid is undefined in reap\n";
>         }
>         my $query = ariba::monitor::Query->_objectWithNameFromCache( $kid->tag() );
> 
>         # make really sure this is one of ours
>         next unless defined( $query );
> 
>         $grownKids++;
> 
>         # duplicate into the parent proc some of the work
>         # the real _runQuery() methods did in the child proc
> 
>         $query->_setRunStatsAndResults($kid->returnValue());
>         $query->runProcessAnswer();
> 
>         $threadRunTime += $query->runTime();
> 
>         if ( $grownKids >= $launchedQueries ) {
>             last;
>         }
> 
>         while ( $currentQuery < $queryCount ) {
>             my $query = $queries[$currentQuery];
>             $currentQuery++;
>             if ( $query->skip() ) {
>                 next;
>             } else {
>                 $self->_launchChildQuery($query);
>                 $launchedQueries++;
>                 last;
905d1033
<             print $fh "$row\n";
907c1035
<         close($fh);
---
> 
908a1037,1052
> 
>     $self->setRunTime(time - $startTime);
>     $self->setTotalThreadTime($threadRunTime);
> }
> 
> sub _launchChildQuery {
>     my $self = shift;
>     my $query = shift;
> 
>     my $coderef = sub {
>         return($query->run());
>     };
> 
>     my $child = ariba::Ops::SharedMemoryChild->new($coderef);
>     $child->setTag( $query->instance() );
>     $child->run();
911,912c1055,1058
< sub generateInfluxLines
< {
---
> # unlike checkStatus, this method does not cause any side effects,
> # it just calls status() on all its queries and sets its status
> # based on the aggregated results
> sub recomputeStatus {
915c1061,1142
<     my $influxLines = {};
---
>     my $status = ariba::monitor::Query::combineStatusOfQueries( $self->queries() );
> 
>     $self->setStatus($status);
> }
> 
> # here we do the work necessary to send a query result to MonX
> # This is very conservative to absolutely minimize the chance of any
> # impact or regression to the current, legacy system
> # It can block no more than one second.
> # Benchmarking has shown that IPC::Transit::send with pure-perl JSON
> # encoding runs more than 40,000 times per CPU second.
> sub _transitSend {
>     my $query = shift;
> 
>     if(not -w '/tmp/ipc_transit/') {
>         mkdir '/tmp/ipc_transit/', 0777;
>         return unless -w '/tmp/ipc_transit/';
>     }
> 
>     my $message = {
>         backingStore => $query->{_backingStore},
>         legacyInstance => $query->{instance},
>         previousRowCount => $query->{_info}->{previousRowCount},
>         lastInfoResultTimestBecameStaleTime => $query->{_info}->{lastInfoResultTime},
>         lastBecameStaleTime => $query->{_info}->{lastBecameStaleTime},
>         statusChangeTime => $query->{_info}->{statusChangeTime},
>         crit => $query->{_info}->{crit},
>         'error' => $query->{_info}->{'error'},
>         'info' => $query->{_info}->{'warn'},
>         info => $query->{_info}->{info},
>         ticketOnWarnOpenAfterMinutes => $query->{_info}->{ticketOnWarnOpenAfterMinutes},
>         openTicketInServices => $query->{_info}->{openTicketInServices},
>         description => $query->{_info}->{description},
>         format => $query->{_info}->{format},
>         fingerPrint => $query->{_info}->{fingerPrint},
>         queryName => $query->{_info}->{queryName},
>         customer => $query->{_info}->{customer},
>         checkTime => $query->{_info}->{checkTime},
>         service => $query->{_info}->{service},
>         status => $query->{_info}->{status},
>         productName => $query->{_info}->{productName},
>         ranOnHost => $query->{_info}->{ranOnHost},
>         results => $query->{_info}->{results},
>         ranAsUser => $query->{_info}->{ranAsUser},
>         ranByProgram => $query->{_info}->{ranByProgram},
>         previousCheckTime => $query->{_info}->{previousCheckTime},
>         previousStatus => $query->{_info}->{previousStatus},
>         previousResults => $query->{_info}->{previousResults},
>         sql => $query->{_info}->{sql},
>         runTime => $query->{_info}->{runTime},
>         #parentQueryManager => $query->{_info}->{parentQueryManager},
>         isStale => $query->{_info}->{isStale},
>         recordDataType => $query->{_info}->{recordDataType},
>         recordItem => $query->{_info}->{recordItem},
>         answer => $query->{_info}->{answer},
>         uiHint => $query->{_info}->{uiHint},
>         source => 'QueryManager',
>         isLegacy => 1,
>         sendTime => time,
>     };
>     $message->{queryManagerName} = 'unknown';
>     if(     $query->{_info}->{parentQueryManager} and
>             $query->{_info}->{parentQueryManager}->{_info} and
>             $query->{_info}->{parentQueryManager}->{_info}->{name}) {
>         $message->{queryManagerName} = $query->{_info}->{parentQueryManager}->{_info}->{name};
>     }
> 
>     eval {
>         #conservative timeout
>         local $SIG{ALRM} = sub { die "timed out\n"; };
>         alarm 1;
> 
>         ariba::monitor::Transit::send(
>             qname => 'AribaLegacy',
>             message => $message,
>         );
>     };
>     alarm 0;
>     if($@) {
>         print STDERR "ariba::monitor::QueryManager::_transitSend failed: $@\n";
>     }
> }
917,919c1144,1145
<     for my $query ($self->queries())
<     {
<         next if ($query->{_info}->{measurement});
---
> sub checkStatus {
>     my $self = shift;
921,922c1147
<         ### Run for schemas
<         my $schema_id = ($query->{_info}->{schemaId}) ? $query->{_info}->{schemaId} : undef;
---
>     my @statuses = qw(crit warn info);
924,931c1149
<         ### Get meta info
<         my $cid         = ($query->{_info}->{communityId}) ? $query->{_info}->{communityId} : 0;
<         my $results     = $query->{_info}->{results} || ();
<         my $group_by    = $query->{_info}->{group_by} || undef;
<         my $inf_tags    = ($query->{_info}->{inf_tags}) ? lc($query->{_info}->{inf_tags}) : undef;
<         my $inf_default = $query->{_info}->{inf_default};
<         my $inf_field   = $query->{_info}->{inf_field};
<         my $row_key     = $group_by || qq(row_1);
---
>     my $startTime = time();
933,935c1151,1152
<         ### Escape space in tag and community
<         $inf_tags =~ s/(\s+)/\\$1/g if ( $inf_tags );
<         $cid      =~ s/(\s+)/\\$1/g if ( $cid );
---
>     # you can make a claim that this loop should be in Query
>     # but I'm not sure exactly where.
937,941c1154
<         ### If rfc is present
<         if ($cid)
<         {
<             ### Concat with existing group_by
<             $row_key = ($group_by) ? qq(community=$cid) . qq(_) . $group_by : qq(community=$cid);
---
>     for my $query ( $self->queries() ) {
943,944c1156,1159
<             ### Add community to existing tags
<             $query->{_info}->{inf_tags} = $inf_tags = ($inf_tags) ? qq(community="$cid",$inf_tags) : qq(community="$cid");
---
>         next if $query->skip();
> 
>         if ( defined($query->status()) ) {
>             $query->setPreviousStatus($query->status());
947,950c1162,1165
<         if ( $schema_id )
<         {
<             ### Concat with existing group_by
<             $row_key = ($group_by) ? qq(schema_id=$schema_id) . qq(_) . $group_by : qq(schema_id=$schema_id);
---
>         # Don't check a query if we're in an outage. See order-status
>         if ($query->outageSchedule()) {
> 
>             my $outage = $query->outageSchedule()->isInScheduledOutage();
952,953c1167,1178
<             ### Add community to existing tags
<             $query->{_info}->{inf_tags} = $inf_tags = ($inf_tags) ? qq(schema_id="$schema_id",$inf_tags) : qq(schema_id="$schema_id");
---
>             # unconditionally set the status to info, just like
>             # downgrades
>             if (defined $outage) {
> 
>                 $query->setError("in scheduled outage: $outage");
>                 $query->setStatus('info-forced');
>                 #
>                 # treat scheduled outage time as info results
>                 #
>                 $query->setLastInfoResultTime( $query->checkTime() );
>                 next;
>             }
956,960c1181,1183
<         ### Escape comma's in tag values && Process multi-col results
<         if ( $inf_tags )
<         {
<             $inf_tags = $self->escape_commas_between_quotes($inf_tags);
<             $influxLines->{$row_key}->{tag} = $inf_tags;
---
>         $query->setStatus('info');
>         for my $status (@statuses) {
>             last if $query->checkThresholds($status);
963,969c1186,1187
<         if (ref ($results) eq 'HASH')
<         {
<             ### Copy key/value to influxLines hash
<             foreach my $key (keys %{$results})
<             {
<                 $influxLines->{$row_key}->{$key} = $results->{$key};
<             }
---
>         if ( $query->status() eq 'warn' && $query->forceInfoOnWarn() ) {
>             $query->setStatus('info-forced');
971,986c1189,1196
<         elsif (ref ($results) eq 'ARRAY')  ### AoA or AoH
<         {
<             my $i = 0;
<             foreach my $row (@{$results})
<             {
<                 if ( ref($row) eq 'HASH' )
<                 {
<                     $i++;
<                     $influxLines->{$i} = $row;
<                     $influxLines->{$i}->{tag} = ( $inf_tags ) ? $inf_tags : qq(row_id=$i);
<                 } elsif ( ref($row) eq 'ARRAY' || ref($row) eq '' )
<                 {
<                     $influxLines->{$row_key}->{$inf_field."_cnt"} = scalar(@{$query->{_info}->{results}});
<                     $influxLines->{$row_key}->{$inf_field}        = join(",",@{$query->{_info}->{results}});
<                 }
<             }
---
> 
>         if ($query->critOnWarnAfterMinutes() && $query->lastInfoResultTime() && 
>             $query->status() && $query->status() eq 'warn' &&
>             ($query->lastInfoResultTime() + ($query->critOnWarnAfterMinutes() * 60) < time())) {
> 
>             $query->setStatus('crit');
>             $query->setError('Escalated to crit after being warn for ' . 
>                 $query->critOnWarnAfterMinutes() . ' min(s).');
988,992c1198,1200
<         else
<         {
<             ### When sql error happens, it'll be a scalar and inf_field will be null
<             $inf_field = "error_str" if ( $results || $inf_default ) && (!$inf_field);
<             $influxLines->{$row_key}->{$inf_field} = $results || $inf_default;
---
> 
>         if( $query->status() eq 'info' || !$query->lastInfoResultTime() ) {
>             $query->setLastInfoResultTime( $query->checkTime() );
993a1202,1214
> 
>         if ( ! defined($query->previousStatus()) ||
>             ( defined($query->previousStatus()) && 
>             $query->status() ne $query->previousStatus() ) ) {
> 
>             $query->setStatusChangeTime( $query->checkTime() );
>         }
> 
>         # let _transit_send figure out what pieces of the query to send to
>         # MonX
>         eval {
>             _transitSend($query);
>         };
995,997d1215
<     #print "influx_hash" . Dumper($influxLines);
<     return ($influxLines);
< }
999,1002c1217,1223
< sub escape_commas_between_quotes
< {
< 	my $self = shift;
< 	my $inf_tags = shift;
---
>     # now that we've computed the status of our child queries, recompute
>     # our status based on those
>     $self->recomputeStatus();
> 
>     # add time for checking to each query and to queries total
>     my $runTime = time - $startTime;
>     my $currentRunTime = $self->runTime();
1004,1005c1225,1227
< 	my @quote_index;
<         my $new_inf_tags;
---
>     $self->setRunTime( $currentRunTime + $runTime );
>     $self->setTotalThreadTime( $currentRunTime + $runTime );
> }
1007,1008c1229,1231
<         my $previous_c = '';
<         my $espace_flag = -1;
---
> sub longestRunInterval {
>     my $self = shift;
>     my $interval = 0;
1010,1016c1233,1238
< 	my @str = split(//, $inf_tags);
< 	foreach my $c (@str)
<         {
< 		if ($c eq '"' && $previous_c ne '\\')
<                 {
< 			  $espace_flag *= -1;
< 		}
---
>     #
>     # check the frequency of the the queries in this qm, and return
>     # the longest interval
>     #
>     for my $query ( $self->queries() ) {
>         next if $query->skip();
1018,1019c1240
< 		$c = '\\'.$c if($espace_flag == 1 && $c eq ',' && $previous_c ne '\\');
< 		$new_inf_tags .= $c;
---
>         my $queryInterval = $query->runInterval();
1021c1242,1243
< 		$previous_c = $c;
---
>         if ($queryInterval && $queryInterval > $interval) {
>             $interval = $queryInterval;
1022a1245
>     }
1024,1027c1247,1254
<         #remove double quotes and escaped double quotes in tags values
<         $new_inf_tags =~ s/(\\)?\"//g;
< 	
< 	return $new_inf_tags;
---
>     return $interval;
> }
> 
> sub markStaleQueries {
>     my $self = shift;
>     my $currentTime = shift;
> 
>     $self->setIsStale(0);
1028a1256,1265
>     for my $query ( $self->queries() ) {
>         next if $query->skip();
> 
>         if ($query->checkAndSetStaleStatus($currentTime)) {
>             $self->setIsStale(1);
>             $self->setStatus('crit');
>         }
>     }
> 
>     return $self->isStale();
1031,1034c1268,1285
< sub printInfluxLines
< {
<     my $self        = shift;
<     my $influxLines = shift;
---
> sub openTicketsForWarnStatus {
>     my $self = shift;
>     my $currentTime = shift;
>     my $throttler = shift;
>     my $service = shift;
> 
>     # Ticket on warn is no longer useful.  Turning it off.
>     return;
> 
>     for my $query ( $self->queries() ) {
>         unless($query->isAnnotated()) {
>             next unless($query->ticketOnWarnOpenAfterMinutes());
>             next unless(ariba::Ops::ServiceController::isProductionServicesOnly($service) || $query->openTicketInServices());
>             if($query->openTicketInServices()) {
>                 next unless($query->openTicketInServices() eq "all" ||
>                     $query->openTicketInServices() =~ /\b$service\b/i);
>             }
>         }
1036,1037c1287
<     my $measurement = $self->{_info}->{influx};
<     my $parent_tag  = $self->{_info}->{tags};
---
>         my $qbr;
1039c1289,1343
<     return unless ($measurement);
---
>         if ( $query->isAnnotated() ) {
>             $qbr = $query->annotateBehaviorRequest();
>         } 
> 
>         # check to see if we need to open a ticket.
>         if( $query->status() =~ /(?:crit|warn)/ &&
>             $query->lastInfoResultTime() &&
>             $query->lastInfoResultTime()+($query->ticketOnWarnOpenAfterMinutes() * 60) < time() &&
>             !$qbr) {
> 
>             # check to see if we match a page filter -- page filters match
>             # on page requests, so we have to create one here to match
>             # against -- we throw it away (it's not saved) when we're done
> 
>             my ($subject, $body) = split(/\n/, $query->displayResultsToString(), 2);    
>             $subject = $query->status() . ": $subject";
>             $body .= $query->displayDetailsToString() || '';
> 
>             my $pageRequest = ariba::Ops::PageRequest->newWithError(
>                 undef, # don't need a sending program
>                 $query->productName(),
>                 $query->service(),
>                 $subject,
>                 $query->customer(),
>                 $query->cluster(),
>                 $body,
>                 undef # don't need email recipients
>             );
> 
>             unless(ariba::Ops::PageFilter->doesPageRequestMatchAnyFilter($pageRequest)) {
>                 # open ticket here
>                 # every query currently has a productName
>                 my $prodId = $query->productName() || "<unknown-product>";
>                 $prodId .= "/" . $query->customer() if $query->customer();
>                 $prodId .= "/" . $query->cluster() if $query->cluster();
> 
>                 my $severity = '';
>                 $severity = ' s' . $query->severity() if (defined($query->severity()));
> 
>                 my $subject = sprintf("%s %s%s %s warn or crit for %d mins [%s]",
>                     $prodId,
>                     $service,
>                     $severity,
>                     $query->queryName(),
>                     $query->ticketOnWarnOpenAfterMinutes(),
>                     scalar(localtime())
>                 );
>                 my $note = sprintf("%s has been status warn or crit for %d mins in %s",
>                     $query->queryName(),
>                     $query->ticketOnWarnOpenAfterMinutes(),
>                     $service
>                 );
>                 $note .= "\n\n" . $query->displayResultsToString();
>                 $note .= $query->displayDetailsToString() || '';
>                 $note .= "\n";
1041,1048c1345,1346
<     foreach my $row_key (keys %{$influxLines})
<     {
<         my $row = $influxLines->{$row_key};
<         my $fields;
<         foreach my $key (sort keys %{$row})
<         {
<             my $value   = $row->{$key};
<             my $lc_key  = lc ($key);
---
>                 if($throttler and !$throttler->throttleTMID()) {
>                     ariba::Ops::Utils::email('hoa-alert@sap.com', $subject, $note);
1050,1052c1348
<             ### Do not generate field, if both key and value are empty(for some reason)
<             next unless ($key || $value);
<             next if ($key eq 'tag');
---
>                     $query->annotate(undef, undef, 'mon');
1054,1055c1350,1379
<             ### Store strings in double quotes
<             $fields .= ($value =~ /[a-z|\s|:]/i) ? qq($lc_key="$value",) : qq($lc_key=$value,);
---
>                     $throttler->addTicket();
>                 }
>             } # match page filter?
>         } # crit or warn for longer than threshold?
>     } # foreach $self->queries()
> } # end function
> 
> sub archiveResults {
>     my $self = shift;
> 
>     for my $query ( $self->queries() ) {
>         next if $query->skip();
> 
>         $query->recordResults();
>         $query->graphResults();
>     }
> }
> 
> sub archiveResultsOnServer {
>     my $self = shift;
> 
>     my $server = $self->server();
> 
>     if ( !defined($server) || $server->server() ne ariba::Ops::NetworkUtils::hostname() ) {
>         $self->archiveResults();
>     }
> 
>     if ( defined($server) ) {
>         if ( my $r = $server->archiveResults() ) {
>             print STDERR "Error: ",$self->name(),"->archiveResultsOnServer(", $server->server(), ") returned $r\n";
1056a1381,1430
>     } else {
>         die "must call sendToServer() first";
>     }
> }
> 
> sub notifyForStatuses {
>     my $self = shift;
>     my $notifyEmailAddress = shift;
>     my $notifyForWarns = shift;
>     my $notifyForCrits = shift;
> 
>     for my $query ( $self->queries() ) {
>         $query->notifyForStatuses($notifyEmailAddress, $notifyForWarns, $notifyForCrits);
>     }
> }
> 
> sub notifyAboutStatus {
>     my $self = shift;
>     my $warnEmailAddress = shift;
>     my $critEmailAddress = shift;
> 
>     # this method is only for backwards compatiblity
>     # try to map it to newer API
> 
>     $self->notifyForStatuses(
>         $warnEmailAddress, defined($warnEmailAddress), defined($critEmailAddress)
>     );
> }
> 
> sub displayAsText {
>     my $self = shift;
>     my $fd = shift;
> 
>     #my $name = $self->name();
>     #my $status = $self->status() || "unknown";
> 
>     #print $fd "$name: $status\n";
> 
>     for my $query ( $self->queries() ){
>         next if $query->skip();
> 
>         $query->displayResults($fd);
>         $query->displayDetails($fd);
>     }
> }
> 
> sub displayToStdout {       
>     my $self = shift;
>     $self->displayAsText(*STDOUT);
> }
1058,1060c1432,1433
<         ### Do not generate line when there're no fields
<         next unless ($fields);
<         chop ($fields);
---
> sub displayToLog {
>     my $self = shift;
1062,1065c1435,1455
<         my $line = qq($measurement,$parent_tag);
<         $line .= qq(,$row->{tag}) if ($row->{tag});
<         $line .= qq( $fields) if ($fields);
<         print "$line\n";
---
>     $self->lock();
>     $self->recursiveSave();
>     $self->unlock();
> }
> 
> sub processQueries {
>     my $self = shift;
>     my $quickView = shift;
>     my $notifyEmailAddress = shift;
>     my $notifyOnWarn = shift;
>     my $notifyOnCrit = shift;
> 
>     $self->run();
> 
>     if ($quickView) {
>         $self->displayToStdout();
>     } else {
>         $self->checkStatus();
>         $self->archiveResults();
>         $self->displayToLog();
>         $self->notifyForStatuses($notifyEmailAddress, $notifyOnWarn, $notifyOnCrit);
1066a1457,1459
> 
>     # no clue what correct return value should be
>     return 1;
1069,1072c1462,1464
< sub processQueries
< {
<     my $self               = shift;
<     my $quickView          = shift;
---
> sub processQueriesUsingServer {
>     my $self = shift;
>     my $quickView = shift;
1074,1075c1466,1474
<     my $notifyOnWarn       = shift;
<     my $notifyOnCrit       = shift;
---
>     my $notifyOnWarn = shift;
>     my $notifyOnCrit = shift;
>     my $monserver = shift;
> 
>     $monserver = ariba::Ops::PageUtils::monitorServer() unless defined($monserver);
> 
>     unless (defined $monserver) {
>         warn "ariba::Ops::PageUtils::monitorServer() couldn't find a monitor server.\n";
>     }
1079c1478,1485
<     $self->generateTickMetaData() if ( $self->tickMetaData() );
---
>     if ($quickView) {
>         $self->displayToStdout();
>     } else {
>         $self->checkStatus();
> 
>         if ((my $ret = $self->appendToServer($monserver)) != 0) {
>             return $ret;
>         }
1081,1082c1487,1489
<     my $influxLines = $self->generateInfluxLines();
<     $self->printInfluxLines($influxLines);
---
>         $self->archiveResultsOnServer();
>         $self->notifyForStatusesOnServer($notifyEmailAddress, $notifyOnWarn, $notifyOnCrit);
>     }
1085c1492,1670
<     return 1;
---
>     return 0;
> }
> 
> # wraps around processQueriesUsingServer() with a timeout.
> # purposely wrapping it so that we can handle the signal in case of timeout, while maintaining backward compatibility.
> sub processQueriesUsingServerWithTimeout {
>     my $self = shift;
>     my @args = @_;
>     my $timeout = pop @args;
>     
>     croak "processQueriesUsingServerWithTimeout was triggered without timeout value." unless ( $timeout && $timeout =~ /^\d+$/ );
>     $SIG{ ALRM } = sub { croak "processQueriesUsingServerWithTimeout() has timed out."; };
> 
>     alarm( $timeout );
>     my $ret = $self->processQueriesUsingServer( @args );
>     alarm ( 0 );    
> 
>     return $ret;
> }
> 
> sub sendToServer {
>     my $self = shift;
>     my $host = shift;
> 
>     #$self->displayToLog();     #save ourselves to local disk first
> 
>     my @queries = $self->queries();
> 
>     # XXXX
>     # need to set the bogus qm to clean, otherwise it will be written out
>     # during recursiveSave. This is temporary until permissions on
>     # qm-storage are fixed.
>     $self->_clean();
> 
>     for my $query ( @queries ) {
>         $query->recursiveSave();
>     }
> 
>     my $server = ariba::monitor::MonitoringClient->new($host);
> 
>     # wish we had real exceptions
>     if ((my $ret = $server->connect()) != 0) {
>         return $ret;
>     }
> 
>     if ( my $r = $server->readQueryManager($self) ) {
>         print STDERR "Error: ",$self->name(),"->archiveResultsOnServer(", $server->server(), ") returned $r\n";
>     }
> 
>     $self->setServer($server);
> 
>     return 0;
> }
> 
> sub appendToServer {
>     my $self = shift;
>     my $host = shift;
> 
>     #$self->displayToLog();     #save ourselves to local disk first
> 
>     my @queries = $self->queries();
> 
>     # XXXX
>     # need to set the bogus qm to clean, otherwise it will be written out
>     # during recursiveSave. This is temporary until permissions on
>     # qm-storage are fixed.
>     $self->_clean();
> 
>     for my $query ( @queries ) {
>         $query->recursiveSave();
>     }
> 
>     my $server = ariba::monitor::MonitoringClient->new($host);
> 
>     # wish we had real exceptions
>     if ((my $ret = $server->connect()) != 0) {
>         return $ret;
>     }
> 
>     if ( my $r = $server->readAppendQueryManager($self) ) {
>         print STDERR "Error: ",$self->name(),"->appendToServer($host) returned $r\n";
>     }
> 
>     $self->setServer($server);
> 
>     return 0;
> }
> 
> sub notifyAboutStatusOnServer {
>     my $self = shift;
>     my $warnEmail = shift;
>     my $critEmail = shift;
> 
>     my $server = $self->server();
> 
>     unless ( defined($server) ) {
>         die "must call sendToServer() first";
>     }
> 
>     if ( my $r = $server->notifyAboutStatus($warnEmail, $critEmail) ) {
>         print STDERR "Error: ",$self->name(),"->notifyAboutStatusOnServer(",
>              $server->server(), ") returned $r\n";
>     }
>     $server->disconnect();
>     $self->setServer(undef);
> }
> 
> 
> sub notifyForStatusesOnServer {
>     my $self = shift;
>     my $notifyEmailAddress = shift;
>     my $notifyOnWarns = shift;
>     my $notifyOnCrits = shift;
> 
>     my $server = $self->server();
> 
>     unless ( defined($server) ) {
>         die "must call sendToServer() first";
>     }
> 
>     if ( my $r = $server->notifyForStatuses($notifyEmailAddress, $notifyOnWarns, $notifyOnCrits) ) {
>         print STDERR "Error: ",$self->name(),"->notifyAboutStatusesOnServer(", 
>             $server->server(), ") returned $r\n";
>     }
> 
>     $server->disconnect();
>     $self->setServer(undef);
> }
> 
> 
> sub _inProgress {
>     my $self = shift;
> 
>     # we don't warn about not being able to write because
>     # it's mainly cosmetic
> 
>     my $file = $self->inProgressMarkerFile() || return 0;
>     open(MARKER,"> $file");
>     close(MARKER);
> }
> 
> sub _doneProgress {
>     my $self = shift;
> 
>     my $file = $self->inProgressMarkerFile();
> 
>     unlink($file) if ($file);
> }
> 
> sub isInProgress {
>     my $self = shift;
> 
>     my $file = $self->inProgressMarkerFile();
> 
>     return ( -f $file );
> }
> 
> 
> #-------------------------------------------------------------------------------
> 
> # helper function
> #
> # This should go away the same time notifyAboutStatus goes away
> #
> 
> sub notifyList {
>     my $shouldEmail = shift;
>     my $shouldPage = shift;
>     my $warnEmail = shift;
>     my $critEmail = shift;
> 
>     unless ( $shouldPage ) {
>         $critEmail = undef;
>     }
>     unless ( $shouldEmail ) {
>         $warnEmail = undef;
>     }   
> 
>     return ($warnEmail, $critEmail);
53d52
< use ariba::Ops::NetworkUtils;
103,109d101
<     if(defined $queriesHash->{"influx_details"}){
< 	my $inf = $queriesHash->{"influx_details"};
<     	$self->setInflux($inf->{'measurement'});
<         my $script = realpath "$0";
< 	    $self->setTags($self->_computeTags($productName,$serviceName,$script,$inf->{tags}));
< 	    delete $queriesHash->{"influx_details"};
<     }
949,950d940
<     #print "\n CALEER => ", (caller 1)[3];
<     my $inf_group;
952,957c942
<     my $rfc;
<     if(defined $self->{_info}->{runForCommunities}){
< 	$rfc =1;		
<     }
<     my $atleastone = 0;
<     my $ishash = 0;
---
> 
961,963c946
< 	if ($rfc) { 
< 		$query->{'_info'}->{'group_by'} =  $query->{_info}->{communityId};
< 	}
---
> 
969,1106d960
< 	if( $query->{'_info'}->{'inf_field'} =~ /hash/i){
< 		$ishash =1;
< 		$query->{_info}->{communityId} = 'default' if( $query->{_info}->{communityId} !~/\S+/);
< 		$query->{'_info'}->{'inf_default'} = 'none' if( not defined $query->{'_info'}->{'inf_default'});
< 		my $sortflag = $query->{'_info'}->{'inf_sort'};
< 		my $line_proto = $self->{'_info'}->{"influx"} . ",".$self->{'_info'}->{"tags"};
< 		my $result = $query->{'_info'}->{'results'} ;
< 		next if(ref ($result) ne 'ARRAY');
< 		next if(scalar @$result < 2 and !$rfc );
< 		$atleastone++;
< 		foreach my $res(@$result){
< 			my @flds = keys %$res;
< 			next if($flds[0] eq 'headers');
< 			if($sortflag == 2) { @flds = reverse sort @flds; }
< 			else { push @flds, $flds[$sortflag];	}
< 			my $rop;
< 			my $fval = pop @flds;
< 			foreach my $f(@flds){
< 				$res->{$f} =~ s/\s/\\ /g;
< 				$rop .= "$f=\"".$res->{$f}."\",";
< 			}		
< 			if($rfc){
< 				#$rop .= "community=\"".$query->{_info}->{communityId}."\"";
< 				$line_proto .= ",community=\"".$query->{_info}->{communityId}."\"" if($line_proto !~ /community/);
< 			}
< 			$rop =~ s/\,$//;
< 			$res->{$fval} =~ s/\s/\\ /g;
< 			my $final;
< 			$final = $line_proto.",".$rop.' '."$fval=\"".$res->{$fval}."\"";		
< 			#$final = $line_proto.","."$fval=\"".$res->{$fval}."\""." $rop";		
< 			if($query->{'_info'}->{'inf_default'} ne 'none'){		
< 				$final = $line_proto . ' '.$rop;		
< 			}
< 			print "$final\n";
< 		}
< 		next;
< 	}
< 	if($query->{'_info'}->{'group_by'}){
< 		if($rfc) {
< 			$inf_group->{$query->{_info}->{communityId}}->{'inf_tag'} = 'community="' . $query->{_info}->{communityId}.'"';
< 			next if(ref ($query->{'_info'}->{'results'}) ne 'HASH');
< 			foreach my $k( keys %{$query->{'_info'}->{'results'}}){
< 				$inf_group->{$query->{'_info'}->{'group_by'}}->{$k} = $query->{'_info'}->{'results'}->{$k};
< 			}
< 			
< 		}
< 		else {
< 			$inf_group->{$query->{'_info'}->{'group_by'}}->{$query->{'_info'}->{'inf_field'}} = $query->{'_info'}->{'results'};	
< 			$inf_group->{$query->{'_info'}->{'group_by'}}->{'inf_tag'} = $query->{'_info'}->{'inf_tags'};
< 			$inf_group->{$query->{'_info'}->{'group_by'}}->{'default'} = $query->{'_info'}->{'inf_default'};
< 		}
< 		$atleastone++;
< 	}
<     }
<     return if($atleastone == 0 and $ishash);
<     if(defined $inf_group ){
< 	my $line_proto = $self->{'_info'}->{"influx"} . ",".$self->{'_info'}->{"tags"};
< 	foreach my $group(keys %$inf_group){
< 		$inf_group->{$group}->{'inf_tag'} =~ s/\s/\\ /g;	
< 		my $proto = $line_proto.','.$inf_group->{$group}->{'inf_tag'}. ' ' if(defined $inf_group->{$group}->{'inf_tag'});	
< 		my @fields = keys %{$inf_group->{$group}};
< 		next if($fields[0] eq 'inf_tag' and scalar @fields == 1);
< 		foreach my $fld(@fields){
< 			next if($fld eq 'inf_tag');
< 			next if($fld eq 'default');
< 			my $value = $inf_group->{$group}->{$fld};
< 			$value = $inf_group->{$group}->{'default'} if(not defined $value);
< 			if(ref $value eq  'ARRAY'){
< 					my $svalue = join ",", @$value;
< 					if($svalue !~ /\S+/) { $svalue = 'none';}
< 					$value ="$svalue";
< 			}
< 			my $pj;	
< 			if($value =~ /HASH/){
< 				foreach my $k(keys %$value){
< 					$pj .= $value->{$k}." ";
< 				}
< 				$value = $pj;
< 			}
< 			$value =~ s/\s+$//;
< 			$value =~ s/"yes\"/0/g;
< 			$value =~ s/up/0/g;
< 			$value =~ s/down/1/g;
< 			$value =~ s/sick/2/g;
< 			if($value =~ /[a-z]/i){
< 				$proto .= "$fld=\"$value\",";	
< 			}
< 			else {
< 				$proto .= "$fld=$value,";	
< 			}
< 		}
< 		$proto =~ s/\,$//;
< 		print "$proto\n";
< 	}
<     	return;
<     }
<     elsif(defined $self->{'_info'}->{"influx"} ){	
< 	    my $line_proto = $self->{'_info'}->{"influx"} . ",".$self->{'_info'}->{"tags"};
< 	    for my $query ( $self->queries() ) {
< 
< 	        next if $query->skip();
< 		my $field = $query->{'_info'}->{'inf_field'};
< 		my $result = $query->{'_info'}->{'results'} ;
< 		if(defined $query->{'_info'}->{'inf_tags'}){
< 			$query->{'_info'}->{'inf_tags'} =~ s/ /\\ /g;	
< 			$line_proto .= ','.$query->{'_info'}->{'inf_tags'};
< 		}
< 		else { $line_proto .= ' ';}
< 		$result =$query->{'_info'}->{'default'} if( not defined $result);
< 		my $pj;
< 		if($result =~ /HASH/){
< 			foreach my $k(keys %$result){
< 				$pj .= $result->{$k}." ";
< 			}
< 		}
< 		else{
< 			$pj = $result;
< 			$result  ="\"$result\"";
< 		}
<         if ( defined $pj )
<         {
< 		    #$pj =~ s/\s*$/0/;
< 		    $pj =~ s/\s*$//;
< 		    $pj =~ s/"yes\"/0/g;
< 		    $pj =~ s/\"up\"$/0/g;
< 		    $pj =~ s/\"down\"$/1/g;
< 		    $pj =~ s/\"sick\"$/2/g;
< 		    $result = $pj;
<         }
< 		$line_proto .= "$field=$result".",";
< 	    }
<     	$line_proto =~ s/\,$//;
<     
< 	if($line_proto =~ /(ARRAY|HASH)/i){
< 			# do nothin
< 		}
< 	$line_proto =~ s/\, /\,/g;
<     print "$line_proto\n" if($line_proto !~ /(ARRAY|HASH)/i);
1104c952
<  
---
>     
1237c1375
>    my $currentRunTime = $self->runTime();
<    my $currentRunTime = $self->runTime() || 0;
1606c1454
<         #$self->displayToLog();
---
>         $self->displayToLog();
1629c1477
<     exit;
---
> 
1825,1846d1672
< sub _computeTags
< {
<     my ($self, $productName, $serviceName, $caller, $inf_tags) = @_;
< 
<     my $hostname = ariba::Ops::NetworkUtils::hostname();
<     my $tag_str = qq(product=$productName,service=$serviceName,ran_on_host=$hostname,ran_by=$caller);
< 
<     ### Return if $tag_str is null
<     return ($tag_str) unless ( $inf_tags );
< 
<     my @tags = split(/,/,$inf_tags);  ### Append all the other flags, besides product,service etc
<     foreach my $tag ( @tags )
<     {
< 	next if ( $tag =~ /^product/ );	
< 	next if ( $tag =~ /^service/ );	
< 	$tag_str .= ",$tag";
<      }; 
< 
<     return ($tag_str);
< }
< 
< 
filename:./lib/ariba/monitor/TlsSecurityUtil.pm
filename:./lib/ariba/rc/AUCSolrAppInstance.pm
filename:./lib/ariba/rc/CipherStore.pm
filename:./lib/ariba/rc/Globals.pm
336,341d335
<     } elsif ( $product eq 'stratus' ) {
<         # for now, this has to be installed alongside 'mon', as both
<         # will run parallely until further notice. So this must be installed
<         # under mon<service> user, in subdir
< 	return "$localDrive" . HOMEPREFIX . "/mon${service}/$product";
< 
726,727d719
<     } elsif ( $product eq 'stratus') {
< 	return "mon${service}"; 
filename:./lib/ariba/rc/Passwords.pm
filename:./lib/ariba/rc/Product.pm
filename:./lib/ariba/rc/ProductsCfg.pm
filename:./lib/ariba/rc/ServicesCfg.pm
filename:./lib/ariba/rc/SpringbootAppInstance.pm
filename:./lib/ariba/rc/Utils.pm
filename:./lib/ariba/rc/expect-covers.pl
filename:./lib/ariba/util/Crontab.pm
filename:./lib/ariba/util/Encryption.pm
filename:./bin/arches/health-check
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/arches/health-check#14 $
---
> # $Id: //ariba/services/monitor/bin/arches/health-check#15 $
23c23
< Usage: $0 [-e|-p|-d|-h]
---
> Usage: $0 [-e|-p|-d|-h] [-prod prodname]
28a29
>     -prod     arches product name.
39a41
>     my $prodname = "arches";
45a48
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
49a53,54
>     usage("arches product name not specified") unless $prodname;
> 
51,52c56,57
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
58,65c63,70
<         lastPublishDurationInMillis => { name => 'last_publish_dur' , desc => 'Check Last Publish Duration In Millis'},
<         lastSearchDurationInMillis => { name => 'last_search_dur', desc => 'Check Last Search Duration In Millis'},
<         lastPublishedTime => { name => 'last_publish_time', desc => 'Checks last publish time' },
<         publishStatus => { name => 'publish_status', desc => 'Checks publish status' },
<         searchStatus => { name => 'search_status', desc => 'Checks search status' },
<         shardStatus => { name => 'shard_status', desc => 'Check Shard Status'},
<         archesMode => { name => 'arches_mode', desc => 'Checks Arches mode' },
<         jobId => { name => 'job_id', desc => 'Check Job ID'},
---
>         lastPublishDurationInMillis => { name => 'Last Publish Duration In Millis' , desc => 'Check Last Publish Duration In Millis'},
>         lastSearchDurationInMillis => { name => 'Last Search Duration In Millis', desc => 'Check Last Search Duration In Millis'},
>         lastPublishedTime => { name => 'Last Published Time', desc => 'Checks last publish time' },
>         publishStatus => { name => 'Publish Status', desc => 'Checks publish status' },
>         searchStatus => { name => 'Search Status', desc => 'Checks search status' },
>         shardStatus => { name => 'Shard Status', desc => 'Check Shard Status'},
>         archesMode => { name => 'Arches Mode', desc => 'Checks Arches mode' },
>         jobId => { name => 'Job ID', desc => 'Check Job ID'},
78c83
<     my $healthCheckName = "active_nrt_publish_status";
---
>     my $healthCheckName = "Active NRT Publish Status";
86c91
<         if ($healthCheckValue && $healthCheckValue ne 'OK') {
---
>         if ($healthCheckValue ne 'OK') {
89c94,95
<             $healthCheckValue = ( $healthCheckReason ) ? $healthCheckValue . qq( - ) . $healthCheckReason : undef;
---
>             $healthCheckValue .= " - ";
>             $healthCheckValue .= $healthCheckReason;
104,105d103
<         inf_field => $healthCheckName,
<         inf_default => "none",
109d106
<     $queries{'influx_details'} = { measurement => 'arches_health_check'};
112c109
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
116,121c113,117
<         undef %queries;
<         my $app = ($arches->appInstancesLaunchedByRoleInClusterMatchingFilter('indexmgr', 'secondary', 'IndexMgr'))[0];
<         $url = 'http://' . $app->host . ':' . $app->httpPort . '/Arches/api/health/get';
<         $cluster = 'secondary';
<         $queries{'influx_details'} = { measurement => 'arches_health_check'};
<         setQueries ($url, \%queries, $cluster, \%nameInfo);
---
>     undef %queries;
>     my $app = ($arches->appInstancesLaunchedByRoleInClusterMatchingFilter('indexmgr', 'secondary', 'IndexMgr'))[0];
>     $url = 'http://' . $app->host . ':' . $app->httpPort . '/Arches/api/health/get';
>     $cluster = 'secondary';
>     setQueries ($url, \%queries, $cluster, \%nameInfo);
123,124c119,120
<         $qm = ariba::monitor::QueryManager->newWithDetails('health-check', $arches->name(), $arches->service(), undef, $cluster, \%queries);
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm = ariba::monitor::QueryManager->newWithDetails('health-check', $arches->name(), $arches->service(), undef, $cluster, \%queries);
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
160,163d155
<                 inf_field => $nameInfoHashRef->{$metric}->{'name'},
<                 inf_default => "none",
<                 inf_tags    => "cluster=\"$cluster\"",
<                 group_by    => $cluster,
filename:./bin/auc/auc-cache-status
55c55
<     # tmid 182437, temporarily disable alerts
---
> 	# tmid 182437, temporarily disable alerts
60c60
<         sql     => "select (to_number(to_date(to_char(systimestamp AT TIME ZONE 'UTC','DD-MM-YYYY HH24:MI:SS'),'DD-MM-YYYY HH24:MI:SS') - TO_DATE('01-01-1970 00:00:00', 'DD-MM-YYYY HH24:MI:SS')) * (86400)) - max(created) as learning_status from cache_ariba_learning",
---
>         sql     => "select (to_number(to_date(to_char(systimestamp AT TIME ZONE 'UTC','DD-MM-YYYY HH24:MI:SS'),'DD-MM-YYYY HH24:MI:SS') - TO_DATE('01-01-1970 00:00:00', 'DD-MM-YYYY HH24:MI:SS')) * (86400)) - max(created) from cache_ariba_learning",
71c71
<         sql   => "select count(*) as misc_status from users where \"UID\" = 0",
---
>         sql   => "select count(*) from users where \"UID\" = 0",
81c81
<         sql   => "select max(created) as import_status_last_created from node",
---
>         sql   => "select max(created) from node",
89c89
<         sql   => "select max(changed) as import_status_last_updated from node",
---
>         sql   => "select max(changed) from node",
3c3
< # $Id: //ariba/services/monitor/etc/monitor-query-template#6 $
---
> # $Id: //ariba/services/tools/bin/auc/auc-cache-status#3 $
68,69d67
<         inf_field   => "learning_status",
<         inf_default => 0,
80,81d77
<         inf_field   => "misc_status",
<         inf_default => 0,
90,91d85
<         inf_field   => "import_status_last_created",
<         inf_default => 0,
100,101d93
<         inf_field   => "import_status_last_updated",
<         inf_default => 0,
105c97
<     $queries{'influx_details'} = { measurement => 'community_cache_status'};
---
> 
filename:./bin/auc/current-memcached-connections
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
153,156d152
<                 inf_field   => "is_up",
<                 inf_default => "none",
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
184,187d179
<                 inf_field   => "num_of_open_connection",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
200,203d191
<                 inf_field   => "accepting_connections",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
208,209c196,198
<     $queries{'influx_details'} = { measurement => 'memcached_current_connections'};
< 	my $q = ariba::monitor::QueryManager->newWithDetails( "Memcached Current Connections", $me->name(), $me->service(), $me->customer(), \%queries);
---
> 	my $q = ariba::monitor::QueryManager->newWithDetails(
> 		"Memcached Current Connections", $me->name(), $me->service(), $me->customer(), \%queries
> 	);
211c200
< 	my $ret = $q->processQueries($debug, $me->default('notify.email'), $sendEmail, $sendPage);
---
> 	my $ret = $q->processQueriesUsingServer($debug, $me->default('notify.email'), $sendEmail, $sendPage);
filename:./bin/auc/memcached-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
88,90d87
<                 inf_field   => "is_up",
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
107,109d103
<                 inf_field   => "is_up",
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
120,123d113
<                 inf_field   => "num_cached_items",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
133,136d122
<                 inf_field   => "total_connections",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
146,149d131
<                 inf_field   => "bytes_read",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
159,162d140
<                 inf_field   => "bytes_written",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
172,175d149
<                 inf_field   => "store_size",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
190,193d163
<                 inf_field   => "percent_available",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
203,206d172
<                 inf_field   => "misses_cnt",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
216,219d181
<                 inf_field   => "hits_cnt",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
229,232d190
<                 inf_field   => "evitions_cnt",
<                 inf_default => 0,
<                 inf_tags    => "mem_cache_host=\"$memCacheHost\"",
<                 group_by    => $memCacheHost,
236,238c194,198
<     $queries{'influx_details'} = { measurement => 'memcached_status'};
< 	my $q = ariba::monitor::QueryManager->newWithDetails( "Memcached Status", $me->name(), $me->service(), $me->customer(), \%queries);
< 	my $ret = $q->processQueries($debug, $me->default('notify.email'), $sendEmail, $sendPage);
---
> 	my $q = ariba::monitor::QueryManager->newWithDetails(
> 		"Memcached Status", $me->name(), $me->service(), $me->customer(), \%queries
> 	);
> 
> 	my $ret = $q->processQueriesUsingServer($debug, $me->default('notify.email'), $sendEmail, $sendPage);
filename:./bin/common/redis-status-embedded
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
75,78d74
<                 inf_field => "status",
<                 inf_default => "none",
<                 inf_tags => qq(instance_name="$instanceName",app_name="$appName"),
<                 group_by => qq($appName,$instanceName)
82,83c78,80
<         $queries{"influx_details"} = { 'measurement' => "redi_status" };
<         my $q = ariba::monitor::QueryManager->newWithDetails( "redis-status", $product->name(), $service, $product->customer(), \%queries);
---
>         my $q = ariba::monitor::QueryManager->newWithDetails(
>             "redis-status", $product->name(), $service, $product->customer(), \%queries
>         );
86c83
<         my $ret = $q->processQueries($debug, $product->default('notify.email'), $sendEmail, $sendPage);
---
>         my $ret = $q->processQueriesUsingServer($debug, $product->default('notify.email'), $sendEmail, $sendPage);
filename:./bin/mobile/mobile-oauth-check
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl
75,76c75
<                                             perl   => sub {return $status ? qq(OK) : qq(FAILED);},
<                                             inf_field => "oauth_check",
---
>                                             perl   => sub {return $status ? "OK" : "FAILED";},
79d77
<     $query{'influx_details'} = { measurement => 'mobile_oauth_status' };
filename:./bin/mobile/mobile-status
1c1
< #!/usr/local/bin/perl -w 
---
> #!/usr/local/bin/perl
395,397d394
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
399d395
< 
426,428d421
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
455,457d447
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
478,480d467
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
497,500c484
<                                                 ],
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
---
>                                                                                  ],
530,532d513
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$answer\"",
<                                             group_by  => "$namePrefix,$host,$status",
619,621d599
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
638,640d615
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
650,652d624
<                                             inf_field => $keyName,
<                                             inf_tags  => "name=\"$namePrefix\",host=\"$host\",$status=\"$message\"",
<                                             group_by  => "$namePrefix,$host,$status",
660,661c632,634
< $queries{'influx_details'} = { measurement => 'mobile_status' };
< my $q = ariba::monitor::QueryManager->newWithDetails( "mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries);
---
> my $q = ariba::monitor::QueryManager->newWithDetails(
>     "mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries
> );
663c636
< $q->processQueries($debug, $email, $sendEmail, $sendPage); # unless $test;
---
> $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage); # unless $test;
44c44
< my $test = 0;
---
> my $test  = 0;
47,60c47,60
< GetOptions(
<            'debug|d'     => \$debug,
<            'sendemail|e' => \$sendEmail,
<            'sendpage|p'  => \$sendPage,
<            'test|t'      => \$test,
<            'cluster|c'   => \$cluster,
<           );
< 
< my $monProduct = ariba::rc::InstalledProduct->new();
< my $product    = ariba::rc::InstalledProduct->new('mobile', $monProduct->service());
< my $name       = $product->name();
< my $service    = $product->service();
< my $email      = $product->default('notify.email');
< my $customer   = $product->customer() || undef;
---
> GetOptions  (
>                 'debug|d'      => \$debug,
>                 'sendemail|e'  => \$sendEmail,
>                 'sendpage|p'   => \$sendPage,
>                 'test|t'       => \$test,
>                 'cluster|c'    => \$cluster,
>             );
> 
> my $monProduct = ariba::rc::InstalledProduct->new ();
> my $product = ariba::rc::InstalledProduct->new ('mobile', $monProduct->service()); 
> my $name = $product->name ();
> my $service = $product->service ();
> my $email = $product->default ('notify.email');
> my $customer = $product->customer () || undef;
63c63
< my $etc = $monProduct->installDir() . '/etc';
---
> my $etc = $monProduct->installDir () . '/etc';
67c67
<     $cluster = $product->currentCluster() || 'primary';
---
>     $cluster = $product->currentCluster () || 'primary';
70c70
< my @instances = $product->appInstancesInCluster($cluster);
---
> my @instances = $product->appInstancesInCluster ($cluster);
78c78,79
<     my $contents = read_file($config_file) or die "failed to read_file $config_file: $!";
---
>     my $contents = read_file($config_file)
>         or die "failed to read_file $config_file: $!";
83,84c84
< if ($@)
< {
---
> if($@) {
97c97
< if (%msg)    # msg was populated above.
---
> if (%msg) # msg was populated above.
99,112c99,112
<     $queries{"MOBILE 2.0 Config FAILED!"} = {
<         crit   => "answer =~ /FAILED/",
<         uiHint => "MOBILE 2.0",
<         perl   => sub {
<             return "Open/DeCode of $config_file failed:  $msg{ConfigReadERROR}";
<         },
<         ticketOwner                  => 'unassigned-sre',
<         ticketOnWarnOpenAfterMinutes => 1,
<         severity                     => 0,
<         description                  => "This errro will only appear if the script fails to load it's config file.",
<         correctiveActions            => [
<                               Ops => "Open a Sev 0 ticket with Ops.",
<                              ],
<     };
---
>     $queries {"MOBILE 2.0 Config FAILED!"} = {
>                              crit                         => "answer =~ /FAILED/",
>                              uiHint                       => "MOBILE 2.0",
>                              perl                         => sub {
>                                                                     return "Open/DeCode of $config_file failed:  $msg{ConfigReadERROR}";
>                                                                  },
>                              ticketOwner                  => 'unassigned-sre',
>                              ticketOnWarnOpenAfterMinutes => 1,
>                              severity                     => 0,
>                              description                  => "This errro will only appear if the script fails to load it's config file.",
>                              correctiveActions            => [
>                                                                  Ops => "Open a Sev 0 ticket with Ops.",
>                                                              ],
>                           };
126,127c126
<     my $hostMachine = ariba::Ops::Machine->new(ariba::Ops::NetworkUtils::hostname());
< 
---
>     my $hostMachine = ariba::Ops::Machine->new (ariba::Ops::NetworkUtils::hostname());
129c128
<     my $totalMemory = ($hostMachine->memorySize() || 8192) * 1024;
---
>     my $totalMemory = ($hostMachine->memorySize () || 8192) * 1024;
131c130
<   INSTANCE:
---
>     INSTANCE:
134,135c133
<         my $instanceName = $instance->instanceName();
< 
---
>         my $instanceName = $instance->instanceName ();
145c143
<         if ($instanceName =~ /^Redis-/)    # Uses netcat (nc) to extract
---
>         if ($instanceName =~ /^Redis-/) # Uses netcat (nc) to extract
148c146,148
<             my $attrPattern = '^(                       # check at the beginning for any of the following strings,' . "\n" . join ('|', @attributes) . "\n" . '):                      # and followed by a colon.  ';
---
>             my $attrPattern = '^(                       # check at the beginning for any of the following strings,'
>                                 . "\n" . join ('|', @attributes) . "\n" .
>                                '):                      # and followed by a colon.  ';
175c175
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
177c177
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
179c179
<         elsif ($instanceName =~ /^RedisSentinel-/)    # Uses netcat (nc) to extract
---
>         elsif ($instanceName =~ /^RedisSentinel-/) # Uses netcat (nc) to extract
182c182
<             $port       = $instance->port;
---
>             $port = $instance->port;
208c208
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
210c210
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
212c212
<         elsif ($instanceName =~ /^Nginx-/)    # HTTP request
---
>         elsif ($instanceName =~ /^Nginx-/) # HTTP request
216c216
<             $port = $product->default('Nginx.Mobile.Port');
---
>             $port = $product->default ('Nginx.Mobile.Port');
234,235c234,235
<                 my $httpObj = ariba::Ops::HTTP->new("http://$host:$port/nginx_status");
<                 $response   = $httpObj->get_data();
---
>                 my $httpObj = ariba::Ops::HTTP->new ("http://$host:$port/nginx_status");
>                 $response = $httpObj->get_data ()
259c259
<                 while (!$results[0])
---
>                 while (! $results[0])
272c272
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
274c274
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
276c276
<         elsif ($instanceName =~ /^Oauth-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Oauth-/)  # Jolokia/JVM
279,280c279,280
<             $port       = $instance->jolokiaPort;
<             %msg        = ("$instanceName", "$host $port");
---
>             $port = $instance->jolokiaPort;
>             %msg = ("$instanceName", "$host $port");
282c282
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
284c284
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
286c286
<         elsif ($instanceName =~ /^Kafka-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Kafka-/)  # Jolokia/JVM
291c291
<             $port       = $instance->jolokiaPort;
---
>             $port = $instance->jolokiaPort;
293c293
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
295c295
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
297c297
<         elsif ($instanceName =~ /^Notification-/)    # Jolokia/JVM
---
>         elsif ($instanceName =~ /^Notification-/)  # Jolokia/JVM
302,303c302,303
<             $port       = $instance->jolokiaPort;
<             %msg        = ("$instanceName", "$host $port");
---
>             $port = $instance->jolokiaPort;
>             %msg = ("$instanceName", "$host $port");
305c305
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
307c307
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
312,315c312,315
<             $port       = $instance->port;
<             $port1      = $instance->zkleaderPort;                          # I don't know what to do with this,
<             $port2      = $instance->zkpeerPort;                            # or with this, if anything.
<             %msg        = ("$instanceName", "$host $port $port1 $port2");
---
>             $port = $instance->port;
>             $port1 = $instance->zkleaderPort; # I don't know what to do with this,
>             $port2 = $instance->zkpeerPort;   # or with this, if anything.
>             %msg = ("$instanceName", "$host $port $port1 $port2");
317c317
<             $keyName     = "$instanceName";
---
>             $keyName = "$instanceName";
319c319
<             $action      = 'Open a ticket with the Mobile 2.0 team';
---
>             $action = 'Open a ticket with the Mobile 2.0 team';
344c344
<                   if $debug or $test;
---
>                         if $debug or $test;
361c361
<                 if ($namePrefix eq 'Redis' && $status =~ /^used_memory/)    # Either basic used memory, or used_memory_rss (3 of them):
---
>                 if ($namePrefix eq 'Redis' && $status =~ /^used_memory/) # Either basic used memory, or used_memory_rss (3 of them):
379,405c379,393
<                     $queries{"$keyName $status"} = {
<                         crit   => $c,
<                         warn   => $w,
<                         uiHint => "$namePrefix/$host",
<                         perl   => sub { return $message; },
<                         ticketOwner                  => 'unassigned-sre',
<                         ticketOnWarnOpenAfterMinutes => 1,
<                         severity                     => 1,
<                         description                  => "$description $status",
<                         correctiveActions            => [
<                                               Ops => $action,
<                                              ],
<                         inf_field   => "count",
<                         inf_default => 0,
<                         inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                         group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $c,
<                                                          warn        => $w,
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => 0,
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $c,
>                                              warn                         => $w,
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {
>                                                                                     return $message;
>                                                                                  },
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description $status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
409,410c397
<                     my $message = 0;
< 
---
>                     my $message = 'OK';
420,446c407,421
<                     $queries{"$keyName $status"} = {
<                         crit   => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
<                         warn   => "answer eq $warn",
<                         uiHint => "$namePrefix/$host",
<                         perl   => sub { return $message; },
<                         ticketOwner                  => 'unassigned-sre',
<                         ticketOnWarnOpenAfterMinutes => 1,
<                         severity                     => 1,
<                         description                  => "$description $status",
<                         correctiveActions            => [
<                                               Ops => $action,
<                                              ],
<                         inf_field   => "count",
<                         inf_default => 0,
<                         inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                         group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
<                                                          warn        => "answer eq $warn",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status;},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => "(answer eq $crit && previousAnswer eq $crit) || answer =~ /Connection refused|UNDEFINED/",
>                                              warn                         => "answer eq $warn",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {
>                                                                                     return $message;
>                                                                                  },
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description $status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
457,485c432,447
<                         $queries{"$keyName $status"} = {
<                             crit   => $critical,
<                             warn   => "answer >= $warn",
<                             info   => "$info",
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              crit        => $critical,
<                                                              warn        => "answer >= $warn",
<                                                              info        => "$info",
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
---
>                         $queries {"$keyName $status"} = {
>                                                  crit                         => $critical,
>                                                  warn                         => "answer >= $warn",
>                                                  info                         => "$info",
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
491,517c453,467
<                         $queries{"$keyName $status"} = {
<                             crit   => $critical,
<                             warn   => "answer >= $warn",
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              crit        => $critical,
<                                                              warn        => "answer >= $warn",
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
---
>                         $queries {"$keyName $status"} = {
>                                                  crit                         => $critical,
>                                                  warn                         => "answer >= $warn",
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
521,546c471,484
<                         $queries{"$keyName $status"} = {
<                             info   => $info,
<                             uiHint => "$namePrefix/$host",
<                             perl   => sub { return $message; },
<                             ticketOwner                  => 'unassigned-sre',
<                             ticketOnWarnOpenAfterMinutes => 1,
<                             severity                     => 1,
<                             description                  => "$description $status",
<                             correctiveActions            => [
<                                                   Ops => $action,
<                                                  ],
<                             inf_field   => "count",
<                             inf_default => 0,
<                             inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                             group_by    => "$keyName,$status",
<                                                        };
<                         $queries{"$keyName $status type"} = {
<                                                              info        => $info,
<                                                              uiHint      => "$namePrefix/$host",
<                                                              perl        => sub {return $status;},
<                                                              inf_field   => "type",
<                                                              inf_default => "none",
<                                                              inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                              group_by    => "$keyName,$status",
<                                                             };
< 
---
>                         $queries {"$keyName $status"} = {
>                                                  info                         => $info,
>                                                  uiHint                       => "$namePrefix/$host",
>                                                  perl                         => sub {
>                                                                                         return $message;
>                                                                                      },
>                                                  ticketOwner                  => 'unassigned-sre',
>                                                  ticketOnWarnOpenAfterMinutes => 1,
>                                                  severity                     => 1,
>                                                  description                  => "$description $status",
>                                                  correctiveActions            => [
>                                                                                      Ops => $action,
>                                                                                  ],
>                                               };
563,568c501,506
<                     warn        => 'answer ne 0',
<                     crit        => '(previousAnswer ne 0 && answer ne 0) || answer =~ /Connection refused|none|ERROR:\s\s/',
<                     perl        => sub {return $answer},
<                     severity    => 1,
<                     uiHint      => "$namePrefix/$host",
<                     description => 'Sends a "ruok" (are you ok) message to the zookeeper node. If it is working properly,
---
>                             warn    => 'answer ne "imok"',
>                             crit    => '(previousAnswer ne "imok" && answer ne "imok") || answer =~ /Connection refused|none|ERROR:\s\s/',
>                             perl    => sub {return $answer},
>                             severity    => 1,
>                             uiHint  => "$namePrefix/$host",
>                             description => 'Sends a "ruok" (are you ok) message to the zookeeper node. If it is working properly,
570,591c508,515
<                     correctiveActions => [
<                                           Ops => 'Check the kr log for details on why the zookeeper node is not ok. In a cluster setup, '
<                                             . 'zookeeper must have majority of its nodes up and running to work. Ex. If there are 3 '
<                                             . 'nodes, then at least 2 nodes must be up. If only one node is up, it will not work. '
<                                             . 'Escalate to Tools if needed.',
<                                           Tools => 'Troubleshoot based on kr log',
<                                          ],
<                     inf_field   => "count",
<                     inf_default => 0,
<                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                     group_by    => "$keyName,$status",
<                                                };
<                 $queries{"$keyName $status type "} = {
<                                                       warn        => 'answer ne 0',
<                                                       crit        => '(previousAnswer ne 0 && answer ne 0) || answer =~ /Connection refused|none|ERROR:\s\s/',
<                                                       perl        => sub {return $status},
<                                                       uiHint      => "$namePrefix/$host",
<                                                       inf_field   => "type",
<                                                       inf_default => "none",
<                                                       inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                       group_by    => "$keyName,$status",
<                                                      };
---
>                             correctiveActions => [
>                                 Ops => 'Check the kr log for details on why the zookeeper node is not ok. In a cluster setup, ' .
>                                     'zookeeper must have majority of its nodes up and running to work. Ex. If there are 3 ' .
>                                     'nodes, then at least 2 nodes must be up. If only one node is up, it will not work. ' .
>                                     'Escalate to Tools if needed.',
>                                 Tools => 'Troubleshoot based on kr log',
>                             ],
>                     };
594c518
<         else    # All the JVM Jolokia/JMX hosts processed here.
---
>         else # All the JVM Jolokia/JMX hosts processed here.
601c525
<             eval {$jmx = JMX::Jmx4Perl->new(url => "http://$host:$port/jolokia/")};
---
>             eval {$jmx = JMX::Jmx4Perl->new (url => "http://$host:$port/jolokia/")};
615,623c539,547
<                     my $request = JMX::Jmx4Perl::Request->new(
<                                                               READ,
<                                                               {
<                                                                mbean     => $statusMap{$namePrefix}->{$status}->{request}->{mbean},
<                                                                attribute => $statusMap{$namePrefix}->{$status}->{request}->{attribute},
<                                                               }
<                                                              );
<                     $response = $jmx->request($request);
<                 };
---
>                         my $request = JMX::Jmx4Perl::Request->new (
>                                                                      READ,
>                                                                      {
>                                                                         mbean => $statusMap{$namePrefix}->{$status}->{request}->{mbean},
>                                                                         attribute => $statusMap{$namePrefix}->{$status}->{request}->{attribute},
>                                                                      }
>                                                                   );
>                         $response = $jmx->request ($request);
>                      };
635c559
<                 if (!defined $message)    # Be sure there's a message to report.
---
>                 if (! defined $message) # Be sure there's a message to report.
664,693c588,601
<                     $queries{"$keyName $status"} = {
<                                                     crit                         => $critical,
<                                                     warn                         => "answer >= $warn",
<                                                     info                         => "answer >= $info",
<                                                     uiHint                       => "$namePrefix/$host",
<                                                     perl                         => sub {return $message},
<                                                     ticketOwner                  => 'unassigned-sre',
<                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                     severity                     => 1,
<                                                     description                  => "$description$status",
<                                                     correctiveActions            => [
<                                                                           Ops => $action,
<                                                                          ],
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $critical,
<                                                          warn        => "answer >= $warn",
<                                                          info        => "answer >= $info",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "typ",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
< 
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $critical,
>                                              warn                         => "answer >= $warn",
>                                              info                         => "answer >= $info",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description$status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
697,724c605,617
<                     $queries{"$keyName $status"} = {
<                                                     crit                         => $critical,
<                                                     warn                         => "answer >= $warn",
<                                                     uiHint                       => "$namePrefix/$host",
<                                                     perl                         => sub {return $message},
<                                                     ticketOwner                  => 'unassigned-sre',
<                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                     severity                     => 1,
<                                                     description                  => "$description$status",
<                                                     correctiveActions            => [
<                                                                           Ops => $action,
<                                                                          ],
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          crit        => $critical,
<                                                          warn        => "answer >= $warn",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
< 
---
>                     $queries {"$keyName $status"} = {
>                                              crit                         => $critical,
>                                              warn                         => "answer >= $warn",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              ticketOwner                  => 'unassigned-sre',
>                                              ticketOnWarnOpenAfterMinutes => 1,
>                                              severity                     => 1,
>                                              description                  => "$description$status",
>                                              correctiveActions            => [
>                                                                                  Ops => $action,
>                                                                              ],
>                                           };
728,745c621,626
<                     $queries{"$keyName $status"} = {
<                                                     info        => "answer >= $info",
<                                                     uiHint      => "$namePrefix/$host",
<                                                     perl        => sub {return $message},
<                                                     inf_field   => "count",
<                                                     inf_default => 0,
<                                                     inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                     group_by    => "$keyName,$status",
<                                                    };
<                     $queries{"$keyName $status type"} = {
<                                                          info        => "answer >= $info",
<                                                          uiHint      => "$namePrefix/$host",
<                                                          perl        => sub {return $status},
<                                                          inf_field   => "type",
<                                                          inf_default => "none",
<                                                          inf_tags    => qq(name="$namePrefix",host="$host",node="$keyName"),
<                                                          group_by    => "$keyName,$status",
<                                                         };
---
>                     $queries {"$keyName $status"} = {
>                                              info                         => "answer >= $info",
>                                              uiHint                       => "$namePrefix/$host",
>                                              perl                         => sub {return $message},
>                                              description                  => "$description$status",
>                                           };
752,753c633,635
< $queries{'influx_details'} = {measurement => 'mobile_status'};
< my $q = ariba::monitor::QueryManager->newWithDetails("mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries);
---
> my $q = ariba::monitor::QueryManager->newWithDetails(
>     "mobile-2.0-api-response-counts", $name, $service, $customer, $cluster, \%queries
> );
755c637
< $q->processQueries($debug, $email, $sendEmail, $sendPage);    # unless $test;
---
> $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage); # unless $test;
768,777c650,659
<         if (/$attrPattern/x)
<         {
<             # Retruns two items.
<             split /:/;
<         }
<         else
<         {
<             # This is a "do nothing" branch, to ignore the unwanted fields.
<         }
<     } @_;
---
>                     if (/$attrPattern/x)
>                     {
>                         # Retruns two items.
>                         split /:/;
>                     }
>                     else
>                     {
>                         # This is a "do nothing" branch, to ignore the unwanted fields.
>                     }
>                } @_;
791,794c673,675
<             my $telnet = Net::Telnet->new(Host => $host, Port => $port,);
<             $telnet->print("ruok");
<             $output = $telnet->getline();
<             $output = 0 if ($output eq 'imok');
---
>                 my $telnet = Net::Telnet->new(Host => $host, Port => $port,);
>                 $telnet->print("ruok");
>                 $output = $telnet->getline();
filename:./bin/spotbuy/ebay-watcher
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
76,77d75
<         inf_field => "ping_status",
<         inf_default => "none",
90,91d87
<         inf_field => "enabled_status",
<         inf_default => "none",
95d90
<     $queries{'influx_details'} = { measurement => 'spotbuy_ebay_status'};
168c163
<     return qq($ret);
---
>     return $ret;
182c177
<     return qq($ret);
---
>     return $ret;
filename:./bin/ws/http-connection-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
148,151c148
<     	inf_field => "connections",
< 	inf_tags => "webserver=\"$webMachine\"",
< 	group_by => $webMachine,
<     	inf_default => "none",
---
> 
158,160c155,158
<     $queries{'influx_details'} = { measurement => 'ssws_httpd_connection_status' };
<     my $q = ariba::monitor::QueryManager->newWithDetails( "Per webserver http connections", $product, $me->service(), $me->customer(), \%queries );
<     $q->processQueries( $debug, $email, $sendEmail, $sendPage );
---
> 
>     my $q = ariba::monitor::QueryManager->newWithDetails( "Per webserver http connections",
>         $product, $me->service(), $me->customer(), \%queries );
>     $q->processQueriesUsingServer( $debug, $email, $sendEmail, $sendPage );
filename:./bin/ws/realm-community-map-file
69,72d68
<                 inf_field => "last_checked",
<                 inf_tags  => "webserver=\"$webserver\",product_name=\"$prodname\"",
<                 group_by  => "$webserver,$prodname",
<                 inf_default => 0
77d72
<     $queries{'influx_details'} = { measurement => 'ssws_realm_community_map' };
79c74,75
< 	my $qm = ariba::monitor::QueryManager->newWithDetails( "realm-community-map-file", $ssws->name(), $service, undef, \%queries);
---
> 	my $qm = ariba::monitor::QueryManager->newWithDetails(
> 		"realm-community-map-file", $ssws->name(), $service, undef, \%queries);
filename:./lib/ariba/Ops/HanaClient.pm
filename:./lib/ariba/Ops/Utils.pm
filename:./bin/auc/auc-balancer-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
101,102d100
<             inf_field => "$role"."_status",
<             inf_default => "none",
106d103
<     $q{'influx_details'} = { measurement => 'cws_balancer_status'};
133c130
<     return qq("$result");
---
>     return $result;
filename:./bin/auc/auc-clamAV-status
118,120c118
< 				                    perl => sub {  return scan_status('timeout_calls'); }, 
<                                     inf_field   => "timed_out_calls",
<                                     inf_default => 0,
---
> 				    perl => sub {  return scan_status('timeout_calls'); }, 
133,134d130
<                                           inf_field   => "request_failed_calls",
<                                           inf_default => 0,
142,143d137
<                                    inf_field   => "clean_calls",
<                                    inf_default => 0,
154,155d147
<                                          inf_field   => "virus_found_calls",
<                                          inf_default => 0,
164,165d155
<                                                  inf_field   => "total_virus_scan_requests",
<                                                  inf_default => 0,
170d159
<       $queries{'influx_details'} = { measurement => 'community_clamav_status'};
filename:./bin/auc/auc-comm-content-import-status
141,142d140
<                     inf_field => "content_import_status",
<                     inf_default => 0,
147,148c145,146
< 	my $email = $me->default('notify.email');
<     $queries{'influx_details'} = { measurement => 'community_front_door'};
---
> 	 my $email = $me->default('notify.email');
> 
filename:./bin/auc/auc-notifications-status
53c53
<         sql   => "SELECT count(*) as notification_events_queue FROM noti_events WHERE created < ((SYSDATE - TO_DATE('01-JAN-1970','DD-MON-YYYY')) * (86400)) - (30*60) and status = 0",
---
>         sql   => "SELECT count(*) FROM noti_events WHERE created < ((SYSDATE - TO_DATE('01-JAN-1970','DD-MON-YYYY')) * (86400)) - (30*60) and status = 0",
65c65
<         sql   => "SELECT count(*) as notification_queue FROM queue WHERE created < ((SYSDATE - TO_DATE('01-JAN-1970','DD-MON-YYYY')) * (86400)) - (30*60) and name = 'ariba_notifications_queue'",
---
>         sql   => "SELECT count(*) FROM queue WHERE created < ((SYSDATE - TO_DATE('01-JAN-1970','DD-MON-YYYY')) * (86400)) - (30*60) and name = 'ariba_notifications_queue'",
62,63d61
<         inf_field   => "notification_events_queue",
<         inf_default => 0,
75,76d72
<         inf_field   => "notification_queue",
<         inf_default => 0,
80c76
<     $queries{'influx_details'} = { measurement => 'community_notification_status'};
---
> 
filename:./bin/auc/auc-siebel-routing
53c53
<         sql   => "SELECT count(*) as count FROM queue WHERE created < ((SYSDATE - TO_DATE('01-JAN-1970','DD-MON-YYYY')) * (86400)) - (30*60) and name = 'ariba_question_sr_queue'",
---
>         sql   => "SELECT count(*) FROM queue WHERE created < ((SYSDATE - TO_DATE('01-JAN-1970','DD-MON-YYYY')) * (86400)) - (30*60) and name = 'ariba_question_sr_queue'",
61,62d60
<         inf_field   => 'siebel_routing',
<         inf_default => 0,
67c65
<     $queries{'influx_details'} = { measurement => 'community_siebel_routing'};
---
> 
filename:./bin/auc/auc-solr-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
77,79d76
<         inf_field => "indexer_status",
<         inf_tags  => qq(uihint="search handler status"),
<         group_by => 'search_handler_status',
94,96d90
<         inf_field => "search_status",
<         inf_tags  => qq(uihint="search handler status"),
<         group_by => 'search_handler_status',
112,114d105
<         inf_field => "search_handler_status",
<         inf_tags  => qq(uihint="solr node status"),
<         group_by => 'solr_node_status',
159,161d149
<             inf_field => "solr_node_status",
<             inf_tags  => qq(uihint="search handler status",host="$hostname:$port"),
<             group_by => qq(search_handler_status,"$hostname:$port"),
199,201d186
<             inf_field => "solr_node_status",
<             inf_tags  => qq(uihint="solr node status",host="$hostname:$port"),
<             group_by => qq("solr_node_status,"$hostname:$port"),
220c205
<     $queries{'influx_details'} = { measurement => 'community_solr_status'};
---
> 
348a334
> 
filename:./bin/auc/auc-validateLinks-status
58,60c58
< 				                    perl => sub {  return scan_status('timeout_calls'); }, 
<                                     inf_field   => "timed_out_calls",
<                                     inf_default => 0,
---
> 				    perl => sub {  return scan_status('timeout_calls'); }, 
74,75d71
<                                           inf_field   => "link_validation_failed",
<                                           inf_default => 0,
84,85d79
<                                    inf_field   => "succeeded",
<                                    inf_default => 0,
98,99d91
<                                          inf_field   => "found_bad_links",
<                                          inf_default => 0,
109,110c101
<                                                  inf_field   => "total_link_validation_runs",
<                                                  inf_default => 0,
---
>        
114d104
<       $queries{'influx_details'} = { measurement => 'community_links_validation'};
filename:./bin/sdb/sdb-activity
94,95d93
<         'inf_field'   => "d&b_load_prep_status",
<         'inf_default' => "none",
120,121d117
<         'inf_field'   => "d&b_ftp_download_status",
<         'inf_default' => "none",
145,146d140
<         'inf_field'   => "an_load_status",
<         'inf_default' => "none",
36c36
< 	return qq($status);
---
> 	return $status;
67,68d66
<         'inf_field'   => "d&b_load_status",
<         'inf_default' => "none",
86,87d83
<         'inf_field'   => "d&b_load_time",
<         'inf_default' => "0",
93,95c89
< 		'perl' => sub { return '"'. $monitorStats->dnBLoadPreperationStatusMetric() . '"'; },
<         'inf_field'   => "d&b_load_prep_status",
<         'inf_default' => "none",
---
> 		'perl' => sub { return $monitorStats->dnBLoadPreperationStatusMetric(); },
111,112d104
<         'inf_field'   => "d&b_load_prep_time",
<         'inf_default' => "0",
119,121c111
< 		'perl' => sub { return '"' . $monitorStats->dnBFtpDownload() . '"'; },
<         'inf_field'   => "d&b_ftp_download_status",
<         'inf_default' => "none",
---
> 		'perl' => sub { return $monitorStats->dnBFtpDownload(); },
137,138d126
<         'inf_field'   => "d&b_ftp_download_time",
<         'inf_default' => "0",
144,146c132
< 		'perl' => sub { return '"' . $monitorStats->aNLoadStatus(). '"'; },
<         'inf_field'   => "an_load_status",
<         'inf_default' => "none",
---
> 		'perl' => sub { return $monitorStats->aNLoadStatus(); },
156,157d141
<         'inf_field'   => "an_load_time",
<         'inf_default' => "0",
165,166d148
<         'inf_field'   => "enrichment_pending_count",
<         'inf_default' => "0",
174,175d155
<         'inf_field'   => "enrichment_avg_request_time",
<         'inf_default' => "0",
183,184d162
<         'inf_field'   => "enrichment_max_request_time",
<         'inf_default' => "0",
193,194d170
<         'inf_field'   => "step_1_copy_supplier_table_time",
<         'inf_default' => "0",
203,204d178
<         'inf_field'   => "step_2_supplier_pre_req_idx_time",
<         'inf_default' => "0",
213,214d186
<         'inf_field'   => "step_3_supplier_insert_time",
<         'inf_default' => "0",
222,223d193
<         'inf_field'   => "step_4_supplier_insert_cnt",
<         'inf_default' => "0",
232,233d201
<         'inf_field'   => "step_5_supplier_upd_time",
<         'inf_default' => "0",
241,242d208
<         'inf_field'   => "step_6_supplier_upd_cnt",
<         'inf_default' => "0",
251,252d216
<         'inf_field'   => "step_7_engine_idx_time",
<         'inf_default' => "0",
261,262d224
<         'inf_field'   => "step_8_order_engine_idx_time",
<         'inf_default' => "0",
271,272d232
<         'inf_field'   => "step_9_order_engine_idx_time",
<         'inf_default' => "0",
281,282d240
<         'inf_field'   => "step_10_vendor_tbl_idx_time",
<         'inf_default' => "0",
291,292d248
<         'inf_field'   => "step_11_gso_supplier_merge_time",
<         'inf_default' => "0",
301,302d256
<         'inf_field'   => "step_12_gso_supplier_parent_names_sync_time",
<         'inf_default' => "0",
311,312d264
<         'inf_field'   => "step_13_swap_master_tbl_time",
<         'inf_default' => "0",
321,322d272
<         'inf_field'   => "step_14_swap_master_tbl_idx_time",
<         'inf_default' => "0",
326c276
<     $queries{'influx_details'} = { measurement => 'sdb_sdb_activity'};
---
> 
filename:./lib/ariba/Ops/DatacenterController.pm
filename:./lib/ariba/Ops/Startup/Hadoop.pm
filename:./lib/ariba/Ops/Startup/Monitoring.pm
filename:./bin/all-diskstats-watcher
84c84
<                                                                     info => "answer eq 'rw'",
---
>                                                                     info => "answer = rw",
87,90d86
<                                                                     inf_field => "mountStatus",
<                                                                     inf_tags => "datacenter=\"$datacenter\",hostname=\"$hostname\",mountPoint=\"$mountedArrayRef->[0]($mountedArrayRef->[1])\"",
<                                                                     group_by => "$datacenter",
<                                                                     inf_default => 0,
95,96d90
< 
<         queries{"infux_details"} = {measurement => "add_diskstats_watcher"};
101c95,97
<         $queryManager->processQueries($debug, $email, $sendEmail, $sendPage, $monserver);
---
>         $queryManager->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage, $monserver);
> 	$queryManager->recomputeStatus();
> 	$queryManager->save();
filename:./bin/an/daily-order-status
17c17
< my $LOCKFILE = '/tmp/an-stratus-daily-order-status';
---
> my $LOCKFILE = '/tmp/an-daily-order-status';
68c68
< 				schema_community as community,
---
> 				schema_community, 
87c87
<        	     schema_community as community,
---
>        	     schema_community,
109d108
<     $queries{influx_details} = { measurement => "an_daily_order_status" };
122c121
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/legal-queues
75d74
< 
77,79c76
<         foreach my $rec ( @results ){
< 
<             my $owner = $rec->{'OWNER'};
---
>         foreach my $owner ( @results ){
90c87
<                    select /* + INDEX($owner.legal_artifact_q IND_1F10AE86_17279066) */ count(id) as queue_cnt from $owner.legal_artifact_q where status=4; 
---
>                    select /* + INDEX($owner.legal_artifact_q IND_1F10AE86_17279066) */ count(id) from $owner.legal_artifact_q where status=4; 
96,97d92
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="legal artifact queue"),
<                 group_by => qq($owner,$hostname,$instance,"legal artifact queue"),
110c105
<                    select /*+ INDEX($owner.legal_artifact_q IND_1F10AE86_17279066) */ id as id, item as item, decode(status, 1, 'Queued', 2, 'Processing', 'Unknown' || status)as status, round((1420559474 - (status_changed/1000))/3600) stuck_time from $owner.legal_artifact_q where status in (1, 2) and 1420559474 - (status_changed/1000) > 3600
---
>                    select /*+ INDEX($owner.legal_artifact_q IND_1F10AE86_17279066) */ id, item, decode(status, 1, 'Queued', 2, 'Processing', 'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time from $owner.legal_artifact_q where status in (1, 2) and 1420559474 - (status_changed/1000) > 3600
116,117d110
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="legal artifact queue",subtype="more than 1 hour"),
<                 group_by => qq($owner,$hostname,$instance,"legal artifact queue","more than 1 hour"),
130c123
<                     SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_CD3323B5)*/ count(id) as length
---
>                     SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_CD3323B5)*/ count(id) 
138,139d130
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="legal disp queue"),
<                 group_by => qq($owner,$hostname,$instance,"legal disp queue"),
152c143
<                     SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_B1A4A7A0)*/ count(id) as failed_items_cnt
---
>                     SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_B1A4A7A0)*/ count(id)
160,161d150
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="legal disp queue"),
<                 group_by => qq($owner,$hostname,$instance,"legal disp queue"),
174,175c163,164
<                    SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_B1A4A7A0)*/ id as id, item as item, decode(status, 1, 'New', 
<                               2, 'Processing', 'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time 
---
>                    SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_B1A4A7A0)*/ id, item, decode(status, 1, 'New', 
>                               2, 'Processing', 'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time 
184,185d172
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="legal disp queue",subtype="more than 1 hour"),
<                 group_by => qq($owner,$hostname,$instance,"legal disp queue","more than 1 hour"),
199,200c186,187
<                     SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_B1A4A7A0)*/ id as id, item as item, decode(status, 1, 'New',
<                               2, 'Processing', 'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time
---
>                     SELECT /*+ INDEX($owner.legal_disp_queue IND_1F7A44AF_B1A4A7A0)*/ id, item, decode(status, 1, 'New',
>                               2, 'Processing', 'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time
209,210d195
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="legal disp queue",subtype="more than 2 hour"),
<                 group_by => qq($owner,$hostname,$instance,"legal disp queue","more than 2 hour"),
223c208
<                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_CD3323B5)*/ count(id) as length  FROM $owner.document_disp_q WHERE status in (1, 2);
---
>                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_CD3323B5)*/ count(id)  FROM $owner.document_disp_q WHERE status in (1, 2);
229,230d213
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc disp queue"),
<                 group_by => qq($owner,$hostname,$instance,"doc disp queue"),
243c226
<                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_CD3323B5)*/ count(id) as failed_items_cnt FROM $owner.document_disp_q WHERE status=4;
---
>                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_CD3323B5)*/ count(id) FROM $owner.document_disp_q WHERE status=4;
249,250d231
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc disp queue"),
<                 group_by => qq($owner,$hostname,$instance,"doc disp queue")
263,264c244,245
<                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_B1A4A7A0)*/ id as id, item as items, decode(status, 1,
<                         'New',  2, 'Processing', 'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time  
---
>                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_B1A4A7A0)*/ id, item, decode(status, 1,
>                         'New',  2, 'Processing', 'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time  
272,273d252
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc disp queue",subtype="more than 10 mins"),
<                 group_by => qq($owner,$hostname,$instance,"doc disp queue","more than 10 mins")
286,287c265,266
<                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_B1A4A7A0)*/ id as id, item as item, decode(status, 1,
<                         'New', 2, 'Processing',    'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time 
---
>                     SELECT /*+ INDEX($owner.document_disp_q IND_AEA66A_B1A4A7A0)*/ id, item, decode(status, 1,
>                         'New', 2, 'Processing',    'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time 
296,297d274
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc disp queue",subtype="more than 2 hours"),
<                 group_by => qq($owner,$hostname,$instance,"doc disp queue","more than 2 hours")
310c287
<                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_CD3323B5)*/ count(id) as length
---
>                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_CD3323B5)*/ count(id)
317,318d293
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc out disp queue"),
<                 group_by => qq($owner,$hostname,$instance,"doc out disp queue")
331c306
<                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_CD3323B5)*/ count(id) as failed_items_cnt
---
>                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_CD3323B5)*/ count(id)
338,339d312
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc out disp queue"),
<                 group_by => qq($owner,$hostname,$instance,"doc out disp queue")
352,353c325,326
<                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_B1A4A7A0)*/ id as id, item as item, decode(status, 1,
<                         'New',  2, 'Processing',  'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time 
---
>                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_B1A4A7A0)*/ id, item, decode(status, 1,
>                         'New',  2, 'Processing',  'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time 
362,363d334
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc out disp queue",subtype="more than 10 mins"),
<                 group_by => qq($owner,$hostname,$instance,"doc out disp queue","more than 10 mins")
376,377c347,348
<                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_B1A4A7A0)*/ id as id, item as item, decode(status, 1,
<                         'New', 2, 'Processing', 'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time
---
>                     SELECT /*+ INDEX($owner.doc_out_disp_q IND_357A851C_B1A4A7A0)*/ id, item, decode(status, 1,
>                         'New', 2, 'Processing', 'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time
386,387d356
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc out disp queue",subtype="more than 2 hours"),
<                 group_by => qq($owner,$hostname,$instance,"doc out disp queue","more than 2 hours")
400c369
<                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_CD3323B5) */ count(id) as length
---
>                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_CD3323B5) */ count(id)
407,408d375
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc sched queue"),
<                 group_by => qq($owner,$hostname,$instance,"doc sched queue"),
421c388
<                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_CD3323B5)*/ count(id) as failed_items_cnt
---
>                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_CD3323B5)*/ count(id)
428,429d394
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc sched queue"),
<                 group_by => qq($owner,$hostname,$instance,"doc sched queue"),
442,443c407,408
<                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_B1A4A7A0)*/ id as id, item as item, decode(status, 1,
<                         'New',  2, 'Processing',  'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time
---
>                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_B1A4A7A0)*/ id, item, decode(status, 1,
>                         'New',  2, 'Processing',  'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time
452,453d416
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc sched queue",subtype="more than 10 mins"),
<                 group_by => qq($owner,$hostname,$instance,"doc sched queue","more than 10 mins"),
466,467c429,430
<                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_B1A4A7A0)*/ id as id, item as item, decode(status, 1,
<                         'New', 2, 'Processing', 'Unknown' || status) as status, round((1420559474 - (status_changed/1000))/3600) stuck_time
---
>                     SELECT /*+ INDEX($owner.document_sched_q IND_427F3D96_B1A4A7A0)*/ id, item, decode(status, 1,
>                         'New', 2, 'Processing', 'Unknown' || status), round((1420559474 - (status_changed/1000))/3600) stuck_time
476,477d438
<                 inf_tags => qq(sid="$owner",host="$hostname",instance="$instance",type="doc sched queue",subtype="more than 2 hours"),
<                 group_by => qq($owner,$hostname,$instance,"doc sched queue","more than 2 hours"),
487d447
<             $queries{influx_details} = {measurement => 'an_legal_queues'};
filename:./bin/an/misc-status
22d21
<     $queries->{"influx_details"} = { 'measurement' => "an_misc_status"};
39c38
< 		sql		=> "select value as value from configuration where name = 'WalkupCatalogEnabled'",
---
> 		sql		=> "select value from configuration where name = 'WalkupCatalogEnabled'",
50,53c49,52
< 			SELECT /*+ ORDERED use_nl(p o pr r) */ as ordered
< 			        to_char(p.created_on, 'YYYY-MM-DD HH24:MI:SS') as create_on
< 			        o.name as name,
< 			        p.user_id as user_id
---
> 			SELECT /*+ ORDERED use_nl(p o pr r) */
> 			        to_char(p.created_on, 'YYYY-MM-DD HH24:MI:SS'),
> 			        o.name,
> 			        p.user_id
92c91
< 				SELECT count(*) as count FROM idl_ana_log WHERE
---
> 				SELECT count(*) FROM idl_ana_log WHERE
102c101
< 				SELECT count(*) as idl_ana_log_cnt FROM idl_ana_log WHERE
---
> 				SELECT count(*) FROM idl_ana_log WHERE
114c113
< 				select count(*) as table_stats_cnt_$level from 
---
> 				select count(*) from 
132c131
< 				select count(*) index_stats_cnt_$level
---
> 				select count(*)
156c155
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/misc-status-account
56c56
< 				select count(1) as count
---
> 				select count(1) 
69c69
<     $queries->{influx_details} = {measurement => 'an_misc_status_account'};
---
> 
77c77
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/misc-status-account-deprecated
14,50d13
< sub main
< {
<     my $debug     = 0;
<     my $sendEmail = 0;
<     my $sendPage  = 0;
< 
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-d/o) {$debug     = 1;}
<         if ($arg =~ /^-e/o) {$sendEmail = 1;}
<         if ($arg =~ /^-p/o) {$sendPage  = 1;}
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $an = ariba::rc::InstalledProduct->new("an", $me->service());
< 
<     my $queries = {};
< 
<     $queries->{"Orgs in deprecating status for more than 3 hours"} = {
<         format                       => "org ANID %s since %s\n",
<         recordMaxResults             => 200,
<         recordItem                   => "numrows",
<         info                         => "1",
<         severity                     => "2",
<         note                         => "On warn open an S2 CR, downgrade this query for a week, and close this ticket.",
<         warn                         => "numrows > 0",
<         ticketOnWarnOpenAfterMinutes => "1",
<         sql                          => qq`
<                 SELECT o.ANID as an_id, o.dbupdated as db_updated
<                 FROM   org o
<                 WHERE   o.status='Deprecating' AND
<                         o.dbupdated < sysdate - 3/24
<             `
<                                                                      };
< 
<     my $email = $me->default('notify.email');
<     $queries->{influx_details} = {measurement => 'an_misc_status_account_deprecated'};
52c15,54
<     my $qm = ariba::monitor::QueryManager->newWithDetails("misc-status", "an", $me->service, $me->customer(), $queries);
---
> sub main{
> 	my $debug = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 
> 	while(my $arg=shift(@ARGV)){
> 		if($arg =~ /^-d/o){ $debug = 1; }
> 		if($arg =~ /^-e/o){ $sendEmail = 1; };
> 		if($arg =~ /^-p/o){ $sendPage = 1; };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $an = ariba::rc::InstalledProduct->new("an", $me->service());
> 
> 
> 	my $queries = {};
> 
> 	$queries->{"Orgs in deprecating status for more than 3 hours"} = {
> 		format => "org ANID %s since %s\n",
> 		recordMaxResults => 200,
> 		recordItem      =>      "numrows",
> 		info => "1",
> 		severity => "2",
> 		note => "On warn open an S2 CR, downgrade this query for a week, and close this ticket.",
> 		warn => "numrows > 0",
> 		ticketOnWarnOpenAfterMinutes => "1",
> 		sql             => qq`
> 				SELECT o.ANID, o.dbupdated
> 				FROM   org o
> 				WHERE   o.status='Deprecating' AND
> 						o.dbupdated < sysdate - 3/24
> 			`
> 	};
> 
> 
> 	my $email = $me->default('notify.email');
> 
> 	my $qm = ariba::monitor::QueryManager->newWithDetails(
> 		"misc-status", "an", $me->service, $me->customer(), $queries
> 	);
54,55c56,57
<     $qm->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($an));
<     ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $qm);
---
> 	$qm->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($an));
>         ariba::Ops::ProductAPIExtensions::setCommunitiesSQLConnectInfoOnQueryManager($an, $qm);
57c59
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
61a64,65
> 
> 
filename:./bin/an/queue-status
filename:./bin/an/schedule-task-failure
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
99c99
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
106,107d105
<         inf_tags => qq(type="Failed SMI Usage Task"),
<         group_by => 'Failed SMI Usage Task'
115c113
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status , dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
122,123d119
<         inf_tags => qq(type="Failed SMI Usage Status Task"),
<         group_by => 'Failed SMI Usage Status Task'
131c127
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
138,139d133
<         inf_tags => qq(type="Failed SMI Invoice Generator Task"),
<         group_by => 'Failed SMI Invoice Generator Task' ,
147c141
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
154,155d147
<         inf_tags => qq(type="Failed SMI Billing Task"),
<         group_by => 'Failed SMI Billing Task',
163c155
<         sql => q`SELECT destination0 destination,schedule_time as schedule_time, status as status , dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
170,171d161
<         inf_tags => qq(type="Failed SMI Mark Renewal Task"),
<         group_by => 'Failed SMI Mark Renewal Task',
179c169
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
186,187d175
<         inf_tags => qq(type="failed SMI Charging Task"),
<         group_by => "failed SMI Charging Task"
195c183
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
202,203d189
<         inf_tags => qq(type="Failed SMI Enforcement Task"),
<         group_by => 'Failed SMI Enforcement Task',
211c197
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
218,219d203
<         inf_tags => qq(type="Failed PSFT Invoice Detail Report"),
<         group_by => 'Failed PSFT Invoice Detail Report',
227c211
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
234,235d217
<         inf_tags => qq(type="Failed Invoiced Customer Report"),
<         group_by => "Failed Invoiced Customer Report"
243c225
<         sql => q`SELECT destination0 as destination,schedule_time as schedule_time, status as status, dispatcher as dispatcher
---
>         sql => q`SELECT destination0,schedule_time, status, dispatcher
250,251d231
<         inf_tags => qq(type="Failed PSFT Relationship Report"),
<         group_by => "Failed PSFT Relationship Report"
254c234
<     $queries{influx_details} = { measurement=> 'an_schedule_task_failure'};
---
> 
258c238
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
264d243
< 
filename:./bin/an/scheduled-tasks
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
74a75
> 	my $migrationQueries = {};
152,156c153,156
< 				st.name as name,
< 				stdq.id as id,
< 				$statusColumn as status,
< 				$statusChangedHoursColumn as status_changed_hours,
<                 'stuck in processing' as type
---
> 				st.name,
> 				stdq.id,
> 				$statusColumn,
> 				$statusChangedHoursColumn
178,179c178
< 					((sysdate - st.next_run) * 24 * 60) as "minutes_ran",
<                      "archive over time" as type
---
> 					((sysdate - st.next_run) * 24 * 60) as "minutes ran"
201d199
<     $q->{influx_details} = { measurement => 'an_scheduled_tasks' };		
211c209
< 
---
> 		
213a212,218
> 	if (%$migrationQueries) {
> 		$q = ariba::monitor::QueryManager->newWithDetails('migration-status', $product->name(), $service, $customer, $migrationQueries);
> 		$q->setSQLConnectInfo(ariba::Ops::ProductAPIExtensions::connectInfoForOracleClient($product));
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
> 	}
> 
> 	exit 0;
filename:./bin/arches/arches-node-health
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/arches/arches-node-health#5 $
---
> # $Id: //ariba/services/monitor/bin/arches/arches-node-health#6 $
17,19c17,18
< sub usage
< {
<     my $error = shift;
---
> sub usage {
>     my $error = shift; 
22c21
< Usage: $0 [-e|-p|-d|-h]
---
> Usage: $0 [-e|-p|-d|-h] [-prod prodname]
27a27
>     -prod     arches product name.
33c33
<     exit ();
---
>     exit();
36,37c36
< sub debug
< {
---
> sub debug {
41,42c40
< sub main
< {
---
> sub main {
44c42,43
<     my $sendPage  = 0;
---
>     my $sendPage = 0;
>     my $prodname = "arches";
46,51c45,50
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p$/o) {$sendPage  = 1; next;}
---
>     while (my $arg = shift) {
>         if ($arg =~ /^-h$/o) { usage();         next; }
>         if ($arg =~ /^-d$/o) { $debug++;        next; }
>         if ($arg =~ /^-e$/o) { $sendEmail = 1;  next; }
>         if ($arg =~ /^-p$/o) { $sendPage = 1;   next; }
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
55a55,56
>     usage("arches product name not specified") unless $prodname;
> 
57,58c58,59
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
65,66c66
<     foreach my $cluster ($arches->allClusters())
<     {
---
>     foreach my $cluster ( $arches->allClusters() ) {
69c69
<         my @instances = grep {$_->appName() ne 'ZooKeeper'} $arches->appInstancesInCluster($cluster);
---
>         my @instances = grep { $_->appName() ne 'ZooKeeper' } $arches->appInstancesInCluster($cluster);
72,74c72
<         foreach my $app (@instances)
<         {
<             my $instance_name = $app->instanceName();
---
>         foreach my $app (@instances) {
76,89c74,84
<                 crit           => 'answer !~ /iamok/ && previousAnswer !~ /iamok/',
<                 warn           => 'answer !~ /iamok/',
<                 uiHint         => 'ruok status',
<                 perl           => sub {return ruokNodeStatus($app);},
<                 outageSchedule => $outage,
<                 description    => 'Checks the node for issues.  iamok means "I am ok" and the node is healthy and fully initialized, otherwise it is not.',
<                 correctiveActions => [
<                                       Ops  => 'Check kr log for details of the corruption and escalate to Engineering',
<                                       Engr => 'Look at kr logs for details of the corruption.',
<                                      ],
<                 inf_field       => "status",
<                 inf_default     => "none",
<                 inf_tags        => qq(instance_name="$instance_name",type="ruok_status"),
<                 group_by        => $instance_name
---
>                 crit            => 'answer !~ /iamok/ && previousAnswer !~ /iamok/',
>                 warn            => 'answer !~ /iamok/',
>                 uiHint          => 'ruok status',
>                 perl            => sub { return ruokNodeStatus($app); },
>                 outageSchedule  => $outage,
>                 description => 'Checks the node for issues.  iamok means "I am ok" and the node is
>                     healthy and fully initialized, otherwise it is not.',
>                 correctiveActions   => [
>                     Ops => 'Check kr log for details of the corruption and escalate to Engineering',
>                     Engr => 'Look at kr logs for details of the corruption.',
>                 ],
94c89
<         $queries{'influx_details'} = { measurement => 'arches_node_health'};
---
> 
100,102c95,96
< sub ruokNodeStatus
< {
<     my $app   = shift;
---
> sub ruokNodeStatus {
>     my $app = shift; 
105c99
<     my $statusUrl = $app->archesNodeRuokUrl();
---
>     my $statusUrl = $app->archesNodeRuokUrl(); 
113c107
< 
---
>     
filename:./bin/arches/index-manager
1,2c1,2
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
27a28
>     -prod     arches product name.
40,41d40
< $| = 1;
< 
45a45
>     my $prodname = "arches";
52a53
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
56a58,59
>     usage("arches product name not specified") unless $prodname;
> 
58,59c61,62
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
78,79c81
<                                      warn => 900, 
<                                      name => 'Average Publishing Job Processing Time(sec)',
---
>                                      warn => 900, name => 'Average Publishing Job Processing Time(sec)',
114,115d115
<                         inf_field   => $metric,
<                         inf_default => "none",
139,140d138
<                     inf_field => "long_running_jobs",
<                     inf_default => "none",
154,155d151
<                     inf_field => "processing_error_jobs",
<                     inf_default => "none",
162,163c158
<         $dailyQueries{'influx_details'} = {measurement => 'arches_index_mgr', tags => qq(cluster="$cluster")};
<         $queries{'influx_details'} = {measurement => 'arches_index_mgr', tags => qq(cluster="$cluster")};
---
> 
167c162
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
203,204c198
<     #return join(";", @jobs);
<     return scalar(@jobs);
---
>     return join("\n", @jobs);
210,211d203
< 
< 
filename:./bin/arches/nrt-metrics-status
1,2c1,2
< #!/usr/local/bin/perl
< # $Id: //ariba/services/monitor/bin/arches/nrt-metrics-status#2 $
---
> #!/usr/local/bin/perl -w
> # $Id: //ariba/services/monitor/bin/arches/nrt-metrics-status#3 $
23,36c23,29
<     "unconfirmedJobMetric" => "unconfirmed_job_metric", 
<     "requestProcessingMetric" => "request_processing_metric",         
<     "luceneDocCount" => "lucene_doc_count",
<     "percent90Time"  => "90th_percentile_time",
<     "unconfirmedJobCount" => "unconfirmed_job_count",
<     "averageTime" => "average_time",
<     "count" => "count",
<     "failureCount" => "failure_count",
<     "percent90TimeSearchCore" => "percent_90_timesearch_core",
<     "averageTimeSearchCore" => "average_timesearch_core",
<     "longRunningJobsCount" => "longrunning_jobs_count",
<     "longRunningJobsLogMarker" => "longrunning_job_marker",
<     "requestProcessedMetricLastWindow" => "request_processed_metric_last_window",
<     "requestProcessedMetric" => "request_processed_metric",
---
>     "unconfirmedJobMetric" => "Unconfirmed Job Metric", 
>     "requestProcessingMetric" => "Request Processing Metric",         
>     "luceneDocCount" => "Lucene Doc Count",
>     "percent90Time"  => "90th Percentile Time",
>     "unconfirmedJobCount" => "Unconfirmed Job Count",
>     "averageTime" => "Average Time",
>     "count" => "Count",
66c59
< Usage: $0 [-daily] [-e|-p|-d|-h]
---
> Usage: $0 [-daily] [-e|-p|-d|-h] [-prod prodname]
72a66
>     -prod     arches product name.
88a83
>     my $prodname = "arches";
95a91
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
99a96,97
>     usage("arches product name not specified") unless $prodname;
> 
101,102c99,100
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
131d128
< 
154a152
> 
166c164
<                             
---
>                              
175,178d172
<                                 inf_field      => "$pin",
<                                 inf_default    => ( $pin eq "longrunning_job_marker" ) ? "none" : 0,
<                                 inf_tags       => qq(zone="$zone",shard="$shard",type="$pinfo"),
<                                 group_by       => qq($zone,$shard,$pinfo),
192d185
<             $queries{'influx_details'} = { measurement => 'arches_nrt_metrics'};
194c187
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/arches/queue-message-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/arches/queue-message-status#5 $
---
> # $Id: //ariba/services/monitor/bin/arches/queue-message-status#6 $
23c23
< Usage: $0 [-e|-p|-d|-h]
---
> Usage: $0 [-e|-p|-d|-h] [-prod prodname]
28a29
>     -prod     arches product name.
39a41
>     my $prodname = "arches";
45a48
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
49a53,54
>     usage("arches product name not specified") unless $prodname;
> 
51,52c56,57
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
75a81
> 
87,88d92
<             inf_field   => "total_queue_message",
<             inf_default => 0,
94c98
<     $queries{'influx_details'} = { measurement => 'arches_health_check'};
---
> 
96c100
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/arches/search-index
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/arches/search-index#16 $
---
> # $Id: //ariba/services/monitor/bin/arches/search-index#18 $
20c20
< Usage: $0 [-e|-p|-d|-h]
---
> Usage: $0 [-e|-p|-d|-h] [-prod prodname]
25a26
>     -prod     arches product name.
40a42
>     my $prodname = "arches";
46a49
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
50a54,55
>     usage("arches product name not specified") unless $prodname;
> 
52,53c57,58
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
170,173d174
<                         inf_field       => "avg_time",
<                         inf_default     => 0,
<                         inf_tags        => qq(adapter="$adapter",type="$type",instance_name="$appNameIndex"),
<                         group_by        => qq($adapter,$type,$appNameIndex),
189,192d189
<                         inf_field       => "ninety_percentile_time",
<                         inf_default     => 0,
<                         inf_tags        => qq(adapter="$adapter",type="$type",instance_name="$appNameIndex"),
<                         group_by        => qq($adapter,$type,$appNameIndex),
197d193
<         $queriesResponse{'influx_details'} = { measurement => 'arches_search_metrics'};
199c195
<         $qmStatus->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qmStatus->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
220,223d215
<                 inf_field       => "status",
<                 inf_default     => "none",
<                 inf_tags        => qq(instance_name="$appNameSearch",type="search_index_status"),
<                 group_by        => $appNameSearch,
226,227c218
<         
<         $queries{'influx_details'} = { measurement => 'arches_node_health'};
---
> 
229c220
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/arches/shard-status
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
7c7
< #
---
> #       
28,29c28
< sub usage
< {
---
> sub usage {
33c32
< Usage: $0 [-e|-p|-d|-h]
---
> Usage: $0 [-e|-p|-d|-h] [-prod prodname]
40a40
>     -prod      arches product name.
46c46
<     exit ();
---
>     exit();
49,50c49
< sub main
< {
---
> sub main {
54c53,54
<     my $shardSummary = 1;
---
>     my $shardSummary;
>     my $prodname = "arches";
56,71c56,71
<     my $eighteenGigs = 18 * 1024 * 1024;
<     my $fifteenGigs  = 15 * 1024 * 1024;
<     my $fourteenGigs = 14 * 1024 * 1024;
<     my $twelveGigs   = 12 * 1024 * 1024;
<     my $tenGigs      = 10 * 1024 * 1024;    # 10485760
<     my $eightGigs    = 8 * 1024 * 1024;     # 8388608
<     my $sixGigs      = 6 * 1024 * 1024;     # 6291456
< 
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-tenantmap$/o) {$tenantmap    = 1; next;}
<         if ($arg =~ /^-summary$/o)   {$shardSummary = 1; next;}    # For aggregated shards usage by zones
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p$/o) {$sendPage  = 1; next;}
---
>     my $eighteenGigs   = 18 * 1024 * 1024; 
>     my $fifteenGigs   = 15 * 1024 * 1024; 
>     my $fourteenGigs   = 14 * 1024 * 1024; 
>     my $twelveGigs   = 12 * 1024 * 1024; 
>     my $tenGigs   = 10 * 1024 * 1024; # 10485760
>     my $eightGigs =  8 * 1024 * 1024; # 8388608
>     my $sixGigs   =  6 * 1024 * 1024; # 6291456
> 
>     while (my $arg = shift) {
>         if ($arg =~ /^-tenantmap$/o) { $tenantmap = 1; next; }
>         if ($arg =~ /^-summary$/o) { $shardSummary = 1; next; } # For aggregated shards usage by zones
>         if ($arg =~ /^-h$/o) { usage();         next; }
>         if ($arg =~ /^-d$/o) { $debug++;        next; }
>         if ($arg =~ /^-e$/o) { $sendEmail = 1;  next; }
>         if ($arg =~ /^-p$/o) { $sendPage = 1;   next; }
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
73c73
<         usage("Invalid argument: $arg");
---
>         usage( "Invalid argument: $arg" );
75a76,77
>     usage("arches product name not specified") unless $prodname;
> 
77,78c79,80
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service() );
80,81c82
<     foreach my $cluster ($arches->allClusters())
<     {
---
>     foreach my $cluster ( $arches->allClusters() ) {
84,92d84
<         my %ss_summary_queries;
<         my %ss_info_queries;
<         my %ss_disk_size_queries;
<         my %ss_total_shard_size;
< 
<         if ($shardSummary)
<         {
<             my $url        = $arches->default('VendedUrls.FrontDoorTopLevel');
<             my $summaryUrl = $url . "/Arches/api/shardstatus/summary";
94,185c86,156
<             print "Checking Summary url: $summaryUrl\n" if $debug;
< 
<             my $data = gatherData($summaryUrl);
< 
<             ## sample XML returned from gatherData:
<             ##<shardStatusSummaries>
<             ##    <shardStatusSummary>
<             ##        <currentSize>932424710</currentSize>
<             ##        <flag>green</flag>
<             ##        <numOfShards>5</numOfShards>
<             ##        <percentFull>2</percentFull>
<             ##        <zone>z1</zone>
<             ##    </shardStatusSummary>
<             ##    <shardStatusSummary>
<             ##        <currentSize>0</currentSize>
<             ##        <flag>green</flag>
<             ##        <numOfShards>5</numOfShards>
<             ##        <percentFull>0</percentFull>
<             ##        <zone>z2</zone>
<             ##    </shardStatusSummary>
<             ##</shardStatusSummaries>
<             ## Gets turned in this data structure by XML::Simple::XMLin
<             ##$VAR1 = {
<             ##'z1' => {
<             ##        'numOfShards' => '5',
<             ##        'percentFull' => '2',
<             ##        'flag' => 'green',
<             ##        'currentSize' => '932454757'
<             ##        },
<             ##'z2' => {
<             ##        'numOfShards' => '5',
<             ##        'percentFull' => '0',
<             ##        'flag' => 'green',
<             ##        'currentSize' => '179264424'
<             ##        }
<             ## };
< 
<             my $shardZoneSummary = shardSummaryInfo($data);
< 
<             foreach my $zone (keys %{$shardZoneSummary})
<             {
<                 foreach my $zoneInfo (keys %{$shardZoneSummary->{$zone}})
<                 {
<                     my $warn = ($shardZoneSummary->{$zone}->{'flag'} =~ /yellow/) ? 1 : 0;
<                     my $crit = ($shardZoneSummary->{$zone}->{'flag'} =~ /red/)    ? 1 : 0;
<                     next if ($zoneInfo =~ /flag/);
<                     if ($zoneInfo =~ /currentSize/)
<                     {
<                         $ss_summary_queries{"$zone-Sum of All Shards Size"} = {
<                                                                                warn             => $warn,
<                                                                                crit             => $crit,
<                                                                                format           => "%d KB\n",
<                                                                                recordMaxResults => 180,
<                                                                                recordDataType   => "gauge",
<                                                                                graphRecorded    => 1,
<                                                                                perl             => sub {return $shardZoneSummary->{$zone}->{$zoneInfo} / 1024;},
<                                                                                uiHint           => "Shard Status Summary/$zone",
<                                                                                inf_field        => "sum_of_all_shards_size",
<                                                                                inf_default      => 0,
<                                                                                inf_tags         => qq(zone="$zone"),
<                                                                                group_by         => $zone,
<                                                                               };
<                     }
<                     elsif ($zoneInfo =~ /percentFull/)
<                     {
<                         $ss_summary_queries{"$zone-Percentage occupied by All Shards "} = {
<                                                                                            warn             => $warn,
<                                                                                            crit             => $crit,
<                                                                                            format           => "%.0f%%\n",
<                                                                                            recordMaxResults => 180,
<                                                                                            recordDataType   => "gauge",
<                                                                                            graphRecorded    => 1,
<                                                                                            perl             => sub {return $shardZoneSummary->{$zone}->{$zoneInfo};},
<                                                                                            uiHint           => "Shard Status Summary/$zone",
<                                                                                            inf_field        => "percent_occupied_by_all_shards",
<                                                                                            inf_default      => 0,
<                                                                                            inf_tags         => qq(zone="$zone"),
<                                                                                            group_by         => $zone,
<                                                                                           };
<                     }
<                     else
<                     {
<                         $ss_summary_queries{"$zone-$zoneInfo "} = {
<                                                                    perl             => sub {return $shardZoneSummary->{$zone}->{$zoneInfo};},
<                                                                    recordMaxResults => 180,
<                                                                    recordDataType   => "gauge",
<                                                                    graphRecorded    => 1,
<                                                                    uiHint           => "Shard Status Summary/$zone",
<                                                                    inf_field        => "$zoneInfo",
<                                                                    inf_tags         => qq(zone="$zone"),
<                                                                    group_by         => $zone,
<                                                                   };
---
>     if ($shardSummary) {
>            my $url = $arches->default('VendedUrls.FrontDoorTopLevel');
>            my $summaryUrl = $url . "/Arches/api/shardstatus/summary";
> 
>            print "Checking Summary url: $summaryUrl\n" if $debug;
> 
>            my $data = gatherData($summaryUrl);
> 
>            ## sample XML returned from gatherData:
>            ##<shardStatusSummaries>
>            ##    <shardStatusSummary>
>            ##        <currentSize>932424710</currentSize>
>            ##        <flag>green</flag>
>            ##        <numOfShards>5</numOfShards>
>            ##        <percentFull>2</percentFull>
>            ##        <zone>z1</zone>
>            ##    </shardStatusSummary>
>            ##    <shardStatusSummary>
>            ##        <currentSize>0</currentSize>
>            ##        <flag>green</flag>
>            ##        <numOfShards>5</numOfShards>
>            ##        <percentFull>0</percentFull>
>            ##        <zone>z2</zone>
>            ##    </shardStatusSummary>
>            ##</shardStatusSummaries>
>            ## Gets turned in this data structure by XML::Simple::XMLin
>            ##$VAR1 = {
>            ##'z1' => {
>            ##        'numOfShards' => '5',
>            ##        'percentFull' => '2',
>            ##        'flag' => 'green',
>            ##        'currentSize' => '932454757'
>            ##        },
>            ##'z2' => {
>            ##        'numOfShards' => '5',
>            ##        'percentFull' => '0',
>            ##        'flag' => 'green',
>            ##        'currentSize' => '179264424'
>            ##        }
>            ## };
> 
>            my $shardZoneSummary = shardSummaryInfo($data);
> 
>            foreach my $zone ( keys %{$shardZoneSummary} ) {
>                foreach my $zoneInfo (keys %{ $shardZoneSummary->{$zone} }) {
>                    my $warn =  ($shardZoneSummary->{$zone}->{'flag'} =~ /yellow/) ? 1 : 0 ;
>                    my $crit =  ($shardZoneSummary->{$zone}->{'flag'} =~ /red/) ? 1 : 0;
>                    next if ($zoneInfo =~ /flag/);
>                    if ($zoneInfo =~ /currentSize/){
>                           $queries{"$zone-Sum of All Shards Size"} = {
>                                warn           =>  $warn,
>                                crit           =>  $crit,
>                                format         =>  "%d KB\n",
>                                recordMaxResults => 180,
>                                recordDataType    => "gauge",
>                                graphRecorded     => 1,
>                                perl           =>  sub { return $shardZoneSummary->{$zone}->{$zoneInfo}/1024; },
>                                uiHint         =>  "Shard Status Summary/$zone",
>                          };
>                    }
>                    elsif ($zoneInfo =~ /percentFull/){
>                           $queries{"$zone-Percentage occupied by All Shards "} = {
>                                warn           =>  $warn,
>                                crit           =>  $crit,
>                                format         =>  "%.0f%%\n",
>                                recordMaxResults => 180,
>                                recordDataType    => "gauge",
>                                graphRecorded     => 1,
>                                perl           =>  sub { return $shardZoneSummary->{$zone}->{$zoneInfo}; },
>                                uiHint         =>  "Shard Status Summary/$zone",
>                          };
186a158,166
>                    else {
>                           $queries{"$zone-$zoneInfo "} = {
>                                perl           =>  sub { return $shardZoneSummary->{$zone}->{$zoneInfo}; },
>                                recordMaxResults => 180,
>                                recordDataType    => "gauge",
>                                graphRecorded     => 1,
>                                uiHint         =>  "Shard Status Summary/$zone",
>                          };
>                    }
191,193c171,172
<         elsif ($tenantmap)
<         {
<             my $url          = $arches->default('VendedUrls.FrontDoorTopLevel');
---
>         elsif ($tenantmap) {
>             my $url = $arches->default('VendedUrls.FrontDoorTopLevel');
202,204c181,183
<                 warn                         => "defined(answer) && answer ne 'OK'",
<                 severity                     => 2,
<                 perl                         => sub {return $result;},
---
>                 warn        => "defined(answer) && answer ne 'OK'",
>                 severity    => 2,
>                 perl        => sub { return $result; },
206,208c185,187
<                 ticketDueInDays              => 1,
<                 ticketOwner                  => 'unassigned-prodops',
<                 description                  => qq`Monitor whether all the shards pointed to by a tenant
---
>                 ticketDueInDays => 1,
>                 ticketOwner => 'unassigned-prodops',
>                 description => qq`Monitor whether all the shards pointed to by a tenant
213c192
<                     Ops         => qq`Open an S2 CR to assign to Engineering/Platform to investigate the cause.`,
---
>                     Ops => qq`Open an S2 CR to assign to Engineering/Platform to investigate the cause.`,
226c205,206
<         }
---
>         } else {
>             my $shardStatusCollected = 0;
228c208,209
<         my $shardStatusCollected = 0;
---
>             my @instances = $arches->appInstancesInCluster($cluster);
>         
230c211,218
<         my @instances = $arches->appInstancesInCluster($cluster);
---
>             my $total_shard_size = 0;
>             INST:
>             foreach my $instance ( @instances ) {
>                 unless ( $instance->appName() =~ m/searchcore/i ){
>                     print "** Skipping role ", $instance->serverRoles(), " **\n" if $debug;
>                     next INST;
>                 }
>                 my $url;
232,241c220,221
<         my $total_shard_size = 0;
<       INST:
<         foreach my $instance (@instances)
<         {
<             unless ($instance->appName() =~ m/searchcore/i)
<             {
<                 print "** Skipping role ", $instance->serverRoles(), " **\n" if $debug;
<                 next INST;
<             }
<             my $url;
---
>                 unless ($shardStatusCollected) {
>                     $url = $instance->shardStatusURL();
243,328c223
<             unless ($shardStatusCollected)
<             {
<                 $url = $instance->shardStatusURL();
< 
<                 print "URL for Shard Status: '$url'\n" if $debug;
< 
<                 my $data = gatherData($url);
< 
<                 ## sample XML returned from gatherData:
<                 ## <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<                 ## <shardStatusDatas>
<                 ##     <shardStatusData>
<                 ##         <currentSize>9257097539</currentSize>
<                 ##         <name>S_SearchCore3140002</name>
<                 ##         <percentFull>88</percentFull>
<                 ##     </shardStatusData>
<                 ##     <shardStatusData>
<                 ##         <currentSize>9683752896</currentSize>
<                 ##         <name>S_SearchCore3240003</name>
<                 ##         <percentFull>92</percentFull>
<                 ##     </shardStatusData>
<                 ## </shardStatusDatas>
<                 ## Gets turned in this data structure by XML::Simple::XMLin:
<                 ## $VAR1 = {
<                 ##    "shardStatusData" => {
<                 ##        "S_SearchCore3240003" => {
<                 ##            "percentFull" => 88,
<                 ##            "currentSize" => 9257097539
<                 ##        },
<                 ##        "S_SearchCore3140002" => {
<                 ##            "percentFull" => 92,
<                 ##            "currentSize" => 9683752896
<                 ##        }
<                 ##    }
<                 ## };
< 
<                 my $xs = XML::Simple->new();
<                 my $xml = eval {$xs->XMLin($data)};
< 
<                 while (my ($key, $value) = each %{$xml->{'shardStatusData'}})
<                 {
<                     $shardStatusCollected = 1;
< 
<                     $ss_info_queries{"$key Usage"} = {
<                         recordMaxResults => 36000,
<                         recordDataType   => "gauge",
<                         graphRecorded    => 1,
<                         format           => "%.0f%%\n",
<                         uiHint           => 'ShardInfo Usage',
<                         info             => 'answer < 187',
<                         warn             => 'answer >= 187',     # Setting warn at 105 % 8 GB i.e. 15 GB
<                         crit             => 'answer > 225',      # Setting Crit at 125 % of 8GB i.e. 18 GB
<                         correctiveActions => [
<                                               Ops      => 'Warn: Open S2 CR for engineering, assigned to Platform. Crit: Open S1 CR for engineering, assigned to Platform.',
<                                               Engineer => 'Warn: Investigate the distribution of index and maybe trigger SystemRebuild for load balancing. Crit: Investigate whether SystemRebuild will help. Check with OPS whether disk needs cleanup, or add more space or increase the limits.',
<                                              ],
<                         description => 'Provides information about how much a Shard is Consumed (Percent Disk Space Used)',
<                         perl        => sub {getPctFull($xml, $key);},
<                         inf_field   => "usage",
<                         inf_default => 0,
<                         inf_tags    => qq(key="$key"),
<                         group_by    => $key,
<                                                      };
< 
<                     $ss_info_queries{"$key Current Size"} = {
<                         recordMaxResults => 36000,
<                         recordDataType   => "gauge",
<                         graphRecorded    => 1,
<                         format           => "%d KB\n",
<                         uiHint           => 'ShardInfo Size',
<                         info             => "answer < $fifteenGigs",
<                         warn             => "answer > $fifteenGigs",     # Setting warn 15 GB
<                         crit             => "answer > $eighteenGigs",    # Setting Crit at 18 GB
<                         correctiveActions => [
<                                               Ops      => 'Warn: Open S2 CR for engineering, assigned to Platform. Crit: Open S1 CR for engineering, assigned to Platform.',
<                                               Engineer => 'Warn: Investigate the distribution of index and maybe trigger SystemRebuild for load balancing. Crit: Investigate whether SystemRebuild will help. Check with OPS whether disk needs cleanup, or add more space or increase the limits.',
<                                              ],
<                         description => 'Provides information about how much a Shard is Consumed (Disk Space Usage)',
<                         perl        => sub {getSize($xml, $key);},
<                         inf_field   => "current_size",
<                         inf_default => 0,
<                         inf_tags    => qq(key="$key"),
<                         group_by    => $key,
<                                                             };
<                 }
<             }
---
>                     print "URL for Shard Status: '$url'\n" if $debug;
330,331c225
<             $url = $instance->shardSizeURL();
<             print "URL for Shard Size: '$url'\n" if $debug;
---
>                     my $data = gatherData( $url );
333,334c227,295
<             $total_shard_size += getResult($url);
<             my $instance_name = $instance->instanceName();
---
>                     ## sample XML returned from gatherData:
>                     ## <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
>                     ## <shardStatusDatas>
>                     ##     <shardStatusData>
>                     ##         <currentSize>9257097539</currentSize>
>                     ##         <name>S_SearchCore3140002</name>
>                     ##         <percentFull>88</percentFull>
>                     ##     </shardStatusData>
>                     ##     <shardStatusData>
>                     ##         <currentSize>9683752896</currentSize>
>                     ##         <name>S_SearchCore3240003</name>
>                     ##         <percentFull>92</percentFull>
>                     ##     </shardStatusData>
>                     ## </shardStatusDatas>
>                     ## Gets turned in this data structure by XML::Simple::XMLin:
>                     ## $VAR1 = {
>                     ##    "shardStatusData" => {
>                     ##        "S_SearchCore3240003" => {
>                     ##            "percentFull" => 88,
>                     ##            "currentSize" => 9257097539
>                     ##        },
>                     ##        "S_SearchCore3140002" => {
>                     ##            "percentFull" => 92,
>                     ##            "currentSize" => 9683752896
>                     ##        }
>                     ##    }
>                     ## };
> 
>                     my $xs  = XML::Simple->new();
>                     my $xml = eval { $xs->XMLin( $data ) };
> 
>                     while ( my ( $key, $value ) = each %{ $xml->{ 'shardStatusData' } } ){
>                         $shardStatusCollected = 1;
> 
>                         $queries{"$key Usage"} = {
>                             recordMaxResults  => 36000,
>                             recordDataType    => "gauge",
>                             graphRecorded     => 1,
>                             format  => "%.0f%%\n",
>                             uiHint  => 'ShardInfo Usage',
>                             info    => 'answer < 187',
>                             warn    => 'answer >= 187', # Setting warn at 105 % 8 GB i.e. 15 GB
>                             crit    => 'answer > 225', # Setting Crit at 125 % of 8GB i.e. 18 GB
>                             correctiveActions => [
>                                 Ops => 'Warn: Open S2 CR for engineering, assigned to Platform. Crit: Open S1 CR for engineering, assigned to Platform.',
>                                 Engineer => 'Warn: Investigate the distribution of index and maybe trigger SystemRebuild for load balancing. Crit: Investigate whether SystemRebuild will help. Check with OPS whether disk needs cleanup, or add more space or increase the limits.',
>                             ],
>                             description => 'Provides information about how much a Shard is Consumed (Percent Disk Space Used)',
>                             perl        => sub { getPctFull( $xml, $key ); },
>                         };
> 
>                             $queries{"$key Current Size"} = {
>                             recordMaxResults  => 36000,
>                             recordDataType    => "gauge",
>                             graphRecorded     => 1,
>                             format  => "%d KB\n",
>                             uiHint  => 'ShardInfo Size',
>                             info    => "answer < $fifteenGigs",
>                             warn    => "answer > $fifteenGigs", # Setting warn 15 GB
>                             crit    => "answer > $eighteenGigs",   # Setting Crit at 18 GB
>                             correctiveActions => [
>                                 Ops => 'Warn: Open S2 CR for engineering, assigned to Platform. Crit: Open S1 CR for engineering, assigned to Platform.',
>                                 Engineer => 'Warn: Investigate the distribution of index and maybe trigger SystemRebuild for load balancing. Crit: Investigate whether SystemRebuild will help. Check with OPS whether disk needs cleanup, or add more space or increase the limits.',
>                             ],
>                             description => 'Provides information about how much a Shard is Consumed (Disk Space Usage)',
>                             perl        => sub { getSize( $xml, $key ); },
>                         };
>                     }
>                 }
336,360c297,298
<             $ss_disk_size_queries{$instance->instanceName() . " Shard Size"} = {
<                 recordMaxResults             => 36000,
<                 recordDataType               => "gauge",
<                 graphRecorded                => 1,
<                 warn                         => "answer > $fifteenGigs",                                                    # Setting warn 15 GB
<                 crit                         => "answer > $eighteenGigs",                                                   # Setting Crit at 18 GB
<                 perl                         => sub {return getResult($url);},
<                 format                       => "%d KB\n",
<                 uiHint                       => 'Shard Size on Disk',
<                 ticketOnWarnOpenAfterMinutes => 5,
<                 ticketDueInDays              => 1,
<                 ticketOwner                  => 'unassigned-prodops',
<                 severity                     => 1,
<                 description                  => 'Monitoring whether size of the physical shard on disk is within limits',
<                 correctiveActions            => [
<                     Ops =>
< 'Warn: Open an S2 CR to assign to Engineering/Platform to investigate the cause.<BR><BR>Crit: Open an S1 CR to assign to Engineering/Platform. Also, OPS has to check with Engineering whether:<BR> 1. SystemRebuild is required if this is just a problem with load distribution.<BR> 2. Make sure that the Arches scheduled task to purge old shards has been running properly.<BR> 3. There is a need to add more search nodes to the topology, in case we are running short on disk space.<BR>',
<                 ],
<                 inf_field => "shard_size_on_disk",
<                 inf_default => 0,
<                 inf_tags  => qq(instance="$instance_name"),
<                 group_by  => $instance_name,
<                                                                                };
<         }
<         print "Total summary shard size for all nodes ,$total_shard_size \n" if ($debug);
---
>                 $url = $instance->shardSizeURL();
>                 print "URL for Shard Size: '$url'\n" if $debug;
362,371c300
<         $ss_total_shard_size{"Summary Of Shard Size On Disk"} = {
<                                                                   recordMaxResults => 36000,
<                                                                   recordDataType   => "gauge",
<                                                                   graphRecorded    => 1,
<                                                                   perl             => sub {return $total_shard_size;},
<                                                                   format           => "%d KB\n",
<                                                                   description      => 'Summary of Shard Size on Disk',
<                                                                   inf_field        => "total_shard_size",
<                                                                   inf_default      => 0,
<                                                                  };
---
>                 $total_shard_size += getResult( $url );
372a302,332
>                 $queries{ $instance->instanceName() . " Shard Size"} = { 
>                     recordMaxResults => 36000,
>                     recordDataType   => "gauge",
>                     graphRecorded     => 1,
>                     warn    => "answer > $fifteenGigs", # Setting warn 15 GB
>                     crit    => "answer > $eighteenGigs",   # Setting Crit at 18 GB
>                     perl    => sub { return getResult( $url ); },
>                     format  => "%d KB\n",
>                     uiHint  => 'Shard Size on Disk',
>                     ticketOnWarnOpenAfterMinutes    => 5, 
>                     ticketDueInDays => 1,
>                     ticketOwner => 'unassigned-prodops',
>                     severity    => 1,
>                     description => 'Monitoring whether size of the physical shard on disk is within limits',
>                     correctiveActions => [
>                         Ops => 'Warn: Open an S2 CR to assign to Engineering/Platform to investigate the cause.<BR><BR>Crit: Open an S1 CR to assign to Engineering/Platform. Also, OPS has to check with Engineering whether:<BR> 1. SystemRebuild is required if this is just a problem with load distribution.<BR> 2. Make sure that the Arches scheduled task to purge old shards has been running properly.<BR> 3. There is a need to add more search nodes to the topology, in case we are running short on disk space.<BR>',
>                     ],
>                 };
>             }
>             print "Total summary shard size for all nodes ,$total_shard_size \n" if($debug);
>             
>             $queries{"Summary Of Shard Size On Disk"} = {
>                 recordMaxResults => 36000,
>                 recordDataType   => "gauge",
>                 graphRecorded     => 1,
>                 perl    => sub { return $total_shard_size; },
>                 format  => "%d KB\n",
>                 description => 'Summary of Shard Size on Disk',
>             };
> 
>         }
391,394c351,353
<         $ss_summary_queries{'influx_details'}   = {measurement => "arches_shardstatus_summary", tags => qq(cluster=$cluster) };
<         $ss_info_queries{'influx_details'}      = {measurement => "arches_shardstatus_info", tags => qq(cluster=$cluster) };
<         $ss_disk_size_queries{'influx_details'} = {measurement => "arches_shardstatus_disksize", tags => qq(cluster=$cluster) };
<         $ss_total_shard_size{'influx_details'}  = {measurement => "arches_shardstatus_total_shard_size",tags => qq(cluster=$cluster) };
---
>         my $qm = ariba::monitor::QueryManager->newWithDetails($expando, $arches->name(), $arches->service(), $arches->customer(), $cluster, \%queries);
>         # And this should now cause the 3 "expando" names above to all report under one common expando, same as before.
>         $qm->setUiManager ("shard-status");
396d354
<         my $qm = ariba::monitor::QueryManager->newWithDetails($expando, $arches->name(), $arches->service(), $arches->customer(), $cluster, \%ss_summary_queries);
398,408c356
< 
<         my $qm2 = ariba::monitor::QueryManager->newWithDetails($expando, $arches->name(), $arches->service(), $arches->customer(), $cluster, \%ss_info_queries);
<         $qm2->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         my $qm3 = ariba::monitor::QueryManager->newWithDetails($expando, $arches->name(), $arches->service(), $arches->customer(), $cluster, \%ss_disk_size_queries);
<         $qm3->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         my $qm4 = ariba::monitor::QueryManager->newWithDetails($expando, $arches->name(), $arches->service(), $arches->customer(), $cluster, \%ss_total_shard_size);
<         $qm4->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<     }
---
>      }
411,412c359
< sub gatherData
< {
---
> sub gatherData{
415c362
<     my $stat = ariba::monitor::Url->new($url);
---
>     my $stat = ariba::monitor::Url->new( $url );
424,425c371
< sub getPctFull
< {
---
> sub getPctFull{
429c375
<     return $xml->{'shardStatusData'}->{$ident}->{'percentFull'};
---
>     return $xml->{ 'shardStatusData' }->{ $ident }->{ 'percentFull' };
432,433c378
< sub getSize
< {
---
> sub getSize{
437c382
<     return ($xml->{'shardStatusData'}->{$ident}->{'currentSize'} / 1024);
---
>     return ($xml->{ 'shardStatusData' }->{ $ident }->{ 'currentSize' } / 1024);
442,445c387,389
< sub getResult
< {
<     my $url  = shift;
<     my $stat = ariba::monitor::Url->new($url);
---
> sub getResult{
>     my $url = shift;
>     my $stat = ariba::monitor::Url->new( $url );
450,451c394
< 
<     #    print "** \n$html\n**\n";
---
> #    print "** \n$html\n**\n";
455,456c398
< sub shardSummaryInfo
< {
---
> sub shardSummaryInfo {
459c401
<     my $error;
---
>     my $error ;
462c404
<     $stats = eval {XMLin($statsXml, KeyAttr => {shardStatusSummary => 'zone'}, forcearray => ['shardStatusSummary']);};
---
>     $stats = eval { XMLin( $statsXml , KeyAttr => { shardStatusSummary => 'zone'}, forcearray => ['shardStatusSummary']); };
464c406
<     print $error, if ($error && $debug);
---
>     print $error, if ( $error && $debug );
466,468c408,409
<     while (my ($xml, $zoneSummary) = each %{$stats})
<     {
<         print "DEBUG: ZONE SUMMARY\n" . Dumper($zoneSummary) . "\n", if $debug;
---
>     while (my ($xml, $zoneSummary) = each %{ $stats } ) {
>         print "DEBUG: ZONE SUMMARY\n" . Dumper ($zoneSummary). "\n", if $debug;
476d416
< 
filename:./bin/arches/system-rebuild
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/arches/system-rebuild#10 $
---
> # $Id: //ariba/services/monitor/bin/arches/system-rebuild#11 $
23c23
< Usage: $0 [-e|-p|-d|-h]
---
> Usage: $0 [-e|-p|-d|-h] [-prod prodname]
28a29
>     -prod     arches product name.
39a41
>     my $prodname = "arches";
45a48
>         if ($arg =~ /^-prod$/o) { $prodname = shift;   next; }
49a53,54
>     usage("arches product name not specified") unless $prodname;
> 
51,52c56,57
<     exit unless (ariba::rc::InstalledProduct->isInstalled('arches', $me->service()));
<     my $arches = ariba::rc::InstalledProduct->new('arches', $me->service());
---
>     exit unless (ariba::rc::InstalledProduct->isInstalled($prodname, $me->service()));
>     my $arches = ariba::rc::InstalledProduct->new($prodname, $me->service());
84,86d88
<                    inf_field => "status",
<                    inf_tags  => qq(system="$qManager"),
<                    group_by  => $qManager,
93d94
<            $queries{'influx_details'} = { measurement => 'arches_system_reshard',tags => qq(cluster=$cluster)};
filename:./bin/auc/auc-comm-creation-monitoring
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
97,98d96
<                     inf_field           => "timed_out",
<                     inf_default         => 0,
112,113d109
<                     inf_field           => "failed",
<                     inf_default         => 0,
126,127d121
<                     inf_field           => "succeeded",
<                     inf_default         => 0,
140,141d133
<                     inf_field           => "total",
<                     inf_default         => 0,
147c139
<     $queries{'influx_details'} = { measurement => 'community_creation'};
---
> 
149c141
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/boe/boe-status
3a4
> use warnings;
120,133c121,131
<     $queries{"$url"} = {
<                         crit              => "answer >= $crit and previousAnswer >= $crit",
<                         warn              => "answer >= $warn",
<                         info              => "answer >= $info",
<                         perl              => sub {return $status},
<                         description       => $description,
<                         note              => $result,
<                         correctiveActions => [
<                                               Ops => $action,
<                                              ],
<                         inf_field         => "code",
<                         inf_tags          => qq(url="$url"),
<                         group_by          => $url,
<                        };
---
>     $queries {"$url"} = {
>                             crit              => "answer >= $crit and previousAnswer >= $crit",
>                             warn              => "answer >= $warn",
>                             info              => "answer >= $info",
>                             perl              => sub {return $status},
>                             description       => $description,
>                             note              => $result,
>                             correctiveActions => [
>                                                     Ops => $action,
>                                                  ],
>                         };
139,140c137,140
<     $queries{'influx_details'} = { 'measurement' => 'boe_boestatus' };
<     my $q = ariba::monitor::QueryManager->newWithDetails("business-objects-status", $name, $service, $customer, $cluster, \%queries);
---
>     my $q;
>     $q = ariba::monitor::QueryManager->newWithDetails (
>                 "business-objects-status", $name, $service, $customer, $cluster, \%queries);
> 
filename:./bin/bpm/invoice
13c13
< use ariba::Ops::ProductAPIExtensions;
---
> use ariba::Ops::ProductAPIExtensions; 
16d15
< use Data::Dumper;
20,22c19,20
< sub usage
< {
<     my $error = shift;
---
> sub usage {
>     my $error = shift; 
36c34
<     exit ();
---
>     exit();
39,40c37
< sub main
< {
---
> sub main {
42c39
<     my $sendPage  = 0;
---
>     my $sendPage = 0;
44,49c41,45
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-h/o) {usage();  next;}
<         if ($arg =~ /^-d/o) {$debug++; next;}
<         if ($arg =~ /^-e/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p/o) {$sendPage  = 1; next;}
---
>     while (my $arg = shift) {
>         if ($arg =~ /^-h/o) { usage();          next; }
>         if ($arg =~ /^-d/o) { $debug++;         next; }
>         if ($arg =~ /^-e/o) { $sendEmail = 1;   next; }
>         if ($arg =~ /^-p/o) { $sendPage = 1;    next; }
57a54
>     my %queries2;
59,62c56,58
<     if (ariba::rc::InstalledProduct->isInstalled('an', $me->service()))
<     {
<         my $an = ariba::rc::InstalledProduct->new('an', $me->service());
<         my @communities = grep {$_ % 2 != 0} $an->communityIdsForProduct();
---
>     if (ariba::rc::InstalledProduct->isInstalled('an', $me->service())) {
>         my $an = ariba::rc::InstalledProduct->new('an', $me->service()); 
>         my @communities = grep { $_ % 2 != 0 } $an->communityIdsForProduct();
64,75c60,64
<         my $processedPayloadIds = {};
< 
<         foreach my $community (@communities)
<         {
<             my $params = {BusinessObject => 'InvoiceDetailRequest', MetricType => 'ERPTransmitFailure'};
<             my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
<             my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
<             my @invoice_detail_req = ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
< 
<             $queries{"Invoices not retrieved from AN by ERP for an community $community"} = {
<                 info => 1,
< 
---
>         my $processedPayloadIds = {}; 
>             
>         foreach my $community (@communities) {
>             $queries{"Delivery time threshold exceeded - Invoices not retrieved from AN by ERP for an community $community"} = {
>                 info    => 1,
78,80c67,78
<                 crit              => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                 uiHint            => 'Invoices not retrieved from AN by ERP',
<                 perl              => sub {return scalar (@invoice_detail_req)},
---
>                 crit    => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>                 uiHint  => 'Invoices not retrieved from AN by ERP',
>                 perl    => sub { 
>                     my $params = { 
>                         BusinessObject => 'InvoiceDetailRequest', 
>                         MetricType => 'ERPTransmitFailure' 
>                     };
>                     my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
>                     my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
> 
>                     return ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
>                 },
82,90c80,84
<                                       Support => 'File S2 SR, contact buyer and/or supplier based on error message',
<                                       Ops     => 'No action required',
<                                      ],
<                 recordItem       => 'numrows',
<                 recordMaxResults => 40000,
<                 inf_field        => 'count',
<                 inf_default      => 0,
<                 inf_tags         => qq(type="invoices not retrieved from AN by ERP",community="$community"),
<                 group_by         => "invoice_not_retrieved_from AN,$community",
---
>                     Support => 'File S2 SR, contact buyer and/or supplier based on error message',
>                     Ops => 'No action required',
>                 ],
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
93,185c87,111
<             my $i = 1;
<             foreach my $row (@invoice_detail_req)
<             {
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"detail req $community $i"} = {
<                                                             perl        => sub {return $row},
<                                                             inf_field   => "error",
<                                                             inf_tags    => qq(type="invoices not retrieved from AN by ERP",community="$community",row_id=$i),
<                                                             inf_default => 0,
<                                                             group_by    => "invoice_not_retrieved_from AN,$community,$i",
<                                                            };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl        => sub {return $value},
<                                                  inf_field   => $field,
<                                                  inf_tags    => qq(type="invoices not retrieved from AN by ERP",community="$community",row_id=$i),
<                                                  inf_default => 0,
<                                                  group_by    => "invoice_not_retrieved_from AN,$community,$i",
<                                                 };
<                     }
<                 }
<                 $i++;
<             }
< 
<             $params = {BusinessObject => 'InvoiceDetailRequest', MetricType => 'SSPTransmitFailure'};
<             $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
<             $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
<             my @ssp_transmit_failure = ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
<             $queries{"Unable to transmit from AN to SSP Buyer for an community $community"} = {
<                                                                                                info                         => 1,
<                                                                                                warn                         => 'answer =~ /status: warn/i',
<                                                                                                crit                         => '(answer =~ /status: crit/i && previousAnswer =~ /status: crit/i) || (answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                                                                                                severity                     => 1,
<                                                                                                uiHint                       => 'Unable to transmit from AN to SSP Buyer',
<                                                                                                perl                         => sub {return scalar (@ssp_transmit_failure)},
<                                                                                                recordItem                   => 'numrows',
<                                                                                                recordMaxResults             => 40000,
<                                                                                                ticketOnWarnOpenAfterMinutes => 60,
<                                                                                                ticketDueInDays              => 'today',
<                                                                                                correctiveActions            => [
<                                                                                                                      Support => 'No action required',
<                                                                                                                      Ops     => 'File CR, follow CIRS if necessary',
<                                                                                                                     ],
<                                                                                                inf_field   => 'count',
<                                                                                                inf_default => 0,
<                                                                                                inf_tags    => qq(type="unable to transmit from AN to SSP Buyer",community="$community"),
<                                                                                                group_by    => "ssp_transmit_failure,$community",
<                                                                                               };
<             $i = 1;
<             foreach my $row (@ssp_transmit_failure)
<             {
< 
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"ssp transmit failure $community $i"} = {
<                                                                       perl        => sub {return $row},
<                                                                       inf_field   => "error",
<                                                                       inf_tags    => qq(type="unable to transmit from AN to SSP Buyer",community="$community",row_id=$i),
<                                                                       inf_default => 0,
<                                                                       group_by    => "ssp_transmit_failure,$community,$i",
<                                                                      };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl        => sub {return $value},
<                                                  inf_field   => $field,
<                                                  inf_tags    => qq(type="unable to transmit from AN to SSP Buyer",community="$community",row_id=$i),
<                                                  inf_default => 0,
<                                                  group_by    => "ssp_transmit_failure,$community,$i",
<                                                 };
<                     }
<                 }
<                 $i++;
<             }
< 
<             $params = {BusinessObject => 'InvoiceDetailRequest', MetricType => 'BuyerTransmitFailure'};
<             $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
<             $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
<             my @buyer_transmit_failure = ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
<             $queries{"Invoices not retrieved from AN by CD Buyer for an community $community"} = {
<                 info => 1,
---
>             $queries{"Delivery time threshold exceeded - Unable to transmit from AN to SSP Buyer for an community $community"} = {
>                 info    => 1,
>                 warn    => 'answer =~ /status: warn/i',
>                 crit    => '(answer =~ /status: crit/i && previousAnswer =~ /status: crit/i) || (answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>                 severity => 1,
>                 uiHint  => 'Unable to transmit from AN to SSP Buyer',
>                 perl    => sub { 
>                     my $params = { 
>                         BusinessObject => 'InvoiceDetailRequest', 
>                         MetricType => 'SSPTransmitFailure' 
>                     };
>                     my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
>                     my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
> 
>                     return ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
>                 },
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
>                 ticketOnWarnOpenAfterMinutes => 60,
>                 ticketDueInDays     => 'today',
>                 correctiveActions => [
>                     Support => 'No action required',
>                     Ops => 'File CR, follow CIRS if necessary',
>                 ],
>             };
186a113,114
>             $queries{"Delivery time threshold exceeded - Invoices not retrieved from AN by CD Buyer for an community $community"} = {
>                 info    => 1,
189,193c117,130
<                 crit              => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                 uiHint            => 'Invoices not retrieved from AN by CD Buyer',
<                 perl              => sub {scalar (@buyer_transmit_failure);},
<                 recordItem        => 'numrows',
<                 recordMaxResults  => 40000,
---
>                 crit    => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>                 uiHint  => 'Invoices not retrieved from AN by CD Buyer',
>                 perl    => sub { 
>                     my $params = { 
>                         BusinessObject => 'InvoiceDetailRequest', 
>                         MetricType => 'BuyerTransmitFailure' 
>                     };
>                     my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
>                     my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
> 
>                     return ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
>                 },
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
195,286c132,135
<                                       Support => 'File S2 SR, contact buyer and/or supplier based on error message',
<                                       Ops     => 'No action required',
<                                      ],
<                 inf_field   => 'count',
<                 inf_default => 0,
<                 inf_tags    => qq(type="Invoices not retrieved from AN by CD Buyer",community="$community"),
<                 group_by    => "inv_not_retrieved,$community",
<                                                                                                  };
<             $i = 1;
<             foreach my $row (@buyer_transmit_failure)
<             {
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"buyer transmit failure $community $i"} = {
<                                                                         perl        => sub {return $row},
<                                                                         inf_field   => "error",
<                                                                         inf_tags    => qq(type="Invoices not retrieved from AN by CD Buyer",community="$community",row_id=$i),
<                                                                         inf_default => 0,
<                                                                         group_by    => "invoice_not_retrieved_by_CD,$community,$i",
<                                                                        };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl        => sub {return $value},
<                                                  inf_field   => $field,
<                                                  inf_tags    => qq(type="Invoices not retrieved from AN by CD Buyer",community="$community",row_id=$i),
<                                                  inf_default => 0,
<                                                  group_by    => "invoices_not_retrieved_by_CD,$community,$i",
<                                                 };
<                     }
<                 }
<                 $i++;
<             }
< 
<             $params = {BusinessObject => 'InvoiceDetailRequest', MetricType => 'EDITransmitFailure'};
<             my $edi_url = ariba::monitor::Bpm::urlForANApp($an, 'EDIBusinessProcessMonitor');
<             $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($edi_url, 'default');
<             $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params);
<             my @edi_transmit_failure = ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
<             $queries{"Unable to transmit from EDI Gateway to AN"} = {
<                                                                      info                         => 1,
<                                                                      warn                         => 'answer =~ /status: warn/i',
<                                                                      severity                     => 1,
<                                                                      uiHint                       => 'Unable to transmit from EDI Gateway to AN',
<                                                                      perl                         => sub {return scalar (@edi_transmit_failure);},
<                                                                      recordItem                   => 'numrows',
<                                                                      recordMaxResults             => 40000,
<                                                                      ticketOnWarnOpenAfterMinutes => 60,
<                                                                      ticketDueInDays              => 'today',
<                                                                      correctiveActions            => [
<                                                                                            Support => 'No action required',
<                                                                                            Ops     => 'Go through the list of documents and see if these are issues with the customer document or functional issues. File CR for functional issues, follow CIRS if necessary',
<                                                                                           ],
<                                                                      inf_field   => 'count',
<                                                                      inf_default => 0,
<                                                                      inf_tags    => qq(type="Unable to transmit from EDI Gateway to AN"),
<                                                                      group_by    => "unable_transmit_from_edi",
<                                                                     };
<             $i = 1;
< 
<             foreach my $row (@edi_transmit_failure)
<             {
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"edi transmit failure $i"} = {
<                                                            perl      => sub {return $row},
<                                                            inf_field => "error",
<                                                            inf_tags  => qq(type="Unable to transmit from EDI Gateway to AN",row_id=$i),
<                                                            group_by  => "unable_transmit_from_edi",
<                                                           };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl        => sub {return $value},
<                                                  inf_field   => $field,
<                                                  inf_tags    => qq(type="Unable to transmit from EDI Gateway to AN",row_id=$i),
<                                                  inf_default => 0,
<                                                  group_by    => "unable_transmit_from_edi",
<                                                 };
<                     }
<                 }
<             }
---
>                     Support => 'File S2 SR, contact buyer and/or supplier based on error message',
>                     Ops => 'No action required',
>                 ],
>             };
287a137,162
> 
>         $queries{"Delivery time threshold exceeded - Unable to transmit from EDI Gateway to AN"} = {
>             info    => 1,
>             warn    => 'answer =~ /status: warn/i',
>             severity => 1,
>             uiHint  => 'Unable to transmit from EDI Gateway to AN',
>             perl    => sub { 
>                 my $params = { 
>                     BusinessObject => 'InvoiceDetailRequest', 
>                     MetricType => 'EDITransmitFailure' 
>                 };
>                 my $url = ariba::monitor::Bpm::urlForANApp($an, 'EDIBusinessProcessMonitor');
>                 my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, 'default');
>                 my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params);
> 
>                 return ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
>             },
>             recordItem          => 'numrows',
>             recordMaxResults    => 40000,
>             ticketOnWarnOpenAfterMinutes => 60,
>             ticketDueInDays     => 'today',
>             correctiveActions => [
>                 Support => 'No action required',
>                 Ops => 'Go through the list of documents and see if these are issues with the customer document or functional issues. File CR for functional issues, follow CIRS if necessary',
>             ],
>         };
290,292c165,166
<     if (ariba::rc::InstalledProduct->isInstalled('buyer', $me->service()))
<     {
<         my $buyer = ariba::rc::InstalledProduct->new('buyer', $me->service());
---
>     if (ariba::rc::InstalledProduct->isInstalled('buyer', $me->service())) {
>         my $buyer = ariba::rc::InstalledProduct->new('buyer', $me->service()); 
294,321c168,196
< 
<         foreach my $community (keys (%$urls))
<         {
<             my $communityUrl = {$community => $urls->{$community}};
< 
<             my $params = {BusinessObject => 'Invoice', MetricType => 'ExceededDeliveryTime'};
<             my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($communityUrl, $params);
<             my @inv_delayed_buyer = ariba::monitor::Bpm::processResultsFromResponses($responses);
<             $queries{"Invoice delayed in Buyer for unknown reason for buyer community $community"} = {
<                                                               info        => 1,
<                                                               warn        => 'answer =~ /status: warn/i',
<                                                               crit        => '(answer =~ /status: crit/i && (previousAnswer =~ /status: crit/i)) || (answer =~ /time.*out.*after/i && previousAnswer =~ /time.*out.*after/i)',
<                                                               severity    => 1,
<                                                               uiHint      => 'Invoice delayed in Buyer for unknown reason',
<                                                               perl        => sub {return scalar (@inv_delayed_buyer);},
<                                                               description => 'This metric lists any Invoices in the Buyer application that have exceeded the delivery time threshold, but are not yet available to the user, and for which we have no detailed information about the reason for the delay.',
<                                                               recordItem  => 'numrows',
<                                                               recordMaxResults             => 40000,
<                                                               ticketOnWarnOpenAfterMinutes => 60,
<                                                               ticketDueInDays              => 'today',
<                                                               correctiveActions            => [
<                                                                                     Support => 'No action required',
<                                                                                     Ops     => 'File CR, follow CIRS if necessary',
<                                                                                    ],
<                                                               inf_field   => 'count',
<                                                               inf_default => 0,
<                                                               inf_tags    => qq(type="Invoice delayed in Buyer for unknown reason",community="$community"),
<                                                               group_by    => "inv_delayed_in_buyer,$community",
---
>     
>         foreach my $community (keys(%$urls)) {
>             my $communityUrl = { $community => $urls->{$community} };
> 
>             $queries{"Delivery time threshold exceeded - Invoice delayed in Buyer for unknown reason for buyer community $community"} = {
>                 info    => 1,
>                 warn    => 'answer =~ /status: warn/i',
>                 crit    => '(answer =~ /status: crit/i && (previousAnswer =~ /status: crit/i)) || (answer =~ /time.*out.*after/i && previousAnswer =~ /time.*out.*after/i)',
>                 severity => 1,
>                 uiHint  => 'Invoice delayed in Buyer for unknown reason',
>                 perl    => sub { 
>                     #my $url = 'http://dwoods2:8050/Buyer/Main/ad/businessProcessMon/BuyerMonitorActions';
>                     my $params = { 
>                         BusinessObject => 'Invoice', 
>                         MetricType => 'ExceededDeliveryTime' 
>                     };
>                     my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($communityUrl, $params);
> 
>                     return ariba::monitor::Bpm::processResultsFromResponses($responses);
>                 },
>                 description => 'This metric lists any Invoices in the Buyer application that have exceeded the delivery time threshold, but are not yet available to the user, and for which we have no detailed information about the reason for the delay.',
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
>                 ticketOnWarnOpenAfterMinutes => 60,
>                 ticketDueInDays     => 'today',
>                 correctiveActions => [
>                     Support => 'No action required',
>                     Ops => 'File CR, follow CIRS if necessary',
>                 ],
323,350d197
<             my $i = 1;
<             foreach my $row (@inv_delayed_buyer)
<             {
< 
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"inv_delayed_buyer $i"} = {
<                                                         perl      => sub {return $row},
<                                                         inf_field => "error",
<                                                         inf_tags  => qq(type="Invoice delayed in Buyer for unknown reason",community="$community",row_id=$i),
<                                                         group_by  => "inv_delayed_in_buyer,$i",
<                                                        };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl      => sub {return $value},
<                                                  inf_field => $field,
<                                                  inf_tags  => qq(type="Invoice delayed in Buyer for unknown reason",community="$community,"row_id=$i),
<                                                  group_by  => "inv_delayed_in_buyer,$i",
<                                                 };
<                     }
<                 }
<             }
356,358c203
<     if (%queries)
<     {
<         $queries{influx_details} = {measurement => "bpm_invoice_exceeded_delivery_threshold"};
---
>     if (%queries) {
361a207,211
> 
>     if (%queries2) {
>         my $qm = ariba::monitor::QueryManager->newWithDetails('Invoice-has-exceeded-delivery-time-threshold', $tab, $me->service(), $me->customer(), \%queries2);
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
>     }
filename:./bin/bpm/purchase-order
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
13c13
< use ariba::Ops::ProductAPIExtensions;
---
> use ariba::Ops::ProductAPIExtensions; 
16d15
< use Data::Dumper;
20,22c19,20
< sub usage
< {
<     my $error = shift;
---
> sub usage {
>     my $error = shift; 
36c34
<     exit ();
---
>     exit();
39,40c37
< sub main
< {
---
> sub main {
42c39
<     my $sendPage  = 0;
---
>     my $sendPage = 0;
44,49c41,45
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-h/o) {usage();  next;}
<         if ($arg =~ /^-d/o) {$debug++; next;}
<         if ($arg =~ /^-e/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p/o) {$sendPage  = 1; next;}
---
>     while (my $arg = shift) {
>         if ($arg =~ /^-h/o) { usage();          next; }
>         if ($arg =~ /^-d/o) { $debug++;         next; }
>         if ($arg =~ /^-e/o) { $sendEmail = 1;   next; }
>         if ($arg =~ /^-p/o) { $sendPage = 1;    next; }
54c50
<     my $me  = ariba::rc::InstalledProduct->new();
---
>     my $me = ariba::rc::InstalledProduct->new();
56a53
>     my %queries2;
58,61c55,57
<     if (ariba::rc::InstalledProduct->isInstalled('an', $me->service()))
<     {
<         my $an = ariba::rc::InstalledProduct->new('an', $me->service());
<         my @communities = grep {$_ % 2 == 0} $an->communityIdsForProduct();
---
>     if (ariba::rc::InstalledProduct->isInstalled('an', $me->service())) {
>         my $an = ariba::rc::InstalledProduct->new('an', $me->service()); 
>         my @communities = grep { $_ % 2 == 0 } $an->communityIdsForProduct(); 
64,73c60,61
<         my @poResults;
< 
<         foreach my $community (@communities)
<         {
< 
<             my $params = {BusinessObject => 'PurchaseOrder', MetricType => 'CXMLTransmitFailure'};
<             my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
<             my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
<             @poResults = ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
< 
---
>         
>         foreach my $community (@communities) {
75,76c63
<                 info => 1,
< 
---
>                 info    => 1,
79,120c66,85
<                 crit              => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                 uiHint            => 'Unable to transmit from AN to Supplier over cXML Channel',
<                 perl              => sub {return scalar (@poResults);},
<                 correctiveActions => [
<                                       Support => 'Notify the supplier of the issue but Ariba can\'t do anything to fix it',
<                                       Ops     => 'No action required',
<                                      ],
<                 description      => 'This metric lists any Purchase Orders that have exceeded the delivery time threshold, and are currently waiting in AN for delivery to the Supplier over an integrated cXML channel.',
<                 recordItem       => 'numrows',
<                 recordMaxResults => 40000,
<                 inf_field        => 'count',
<                 inf_tags         => qq(type="unable to transmit from AN to Supplier over cXML Channel",community="$community"),
<                 inf_default      => 0,
<                 group_by         => "AN_Supplier_Over_cXML_Channel,$community",
<                                                                                                                                                   };
<             my $i = 1;
< 
<             foreach my $row (@poResults)
<             {
<                 my @cols = split (/\|\|/, $row);
<                 foreach my $col (@cols)
<                 {
<                     my ($field, $value) = split (/=/, $col);
<                     $queries{"$field $i"} = {
<                                              perl        => sub {return $value},
<                                              inf_field   => $field,
<                                              inf_tags    => qq(type="unable to transmit from AN to Supplier over cXML Channel",community="$community",row_id=$i),
<                                              inf_default => 0,
<                                              group_by    => "AN_Supplier_Over_cXML_Channel,$community,$i",
<                                             };
<                 }
<                 $i++;
<             }
< 
<             $params = {BusinessObject => 'PurchaseOrder', MetricType => 'EDITransmitFailure'};
<             $url = ariba::monitor::Bpm::urlForANApp($an, 'EDIBusinessProcessMonitor');
<             $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, 'default');
<             $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params);
< 
<             my @edi_transmit_failure = ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
<             $queries{"Delivery time threshold exceeded - Unable to transmit from EDI Gateway to Supplier"} = {
<                 info => 1,
---
>                 crit    => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>                 uiHint  => 'Unable to transmit from AN to Supplier over cXML Channel',
>                 perl    => sub { 
>                     my $params = { 
>                         BusinessObject => 'PurchaseOrder', 
>                         MetricType => 'CXMLTransmitFailure' 
>                     };
>                     my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, $community);
>                     my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params, 1);
> 
>                     return ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
>                 },
>                 correctiveActions   => [
>                     Support => 'Notify the supplier of the issue but Ariba can\'t do anything to fix it',
>                     Ops => 'No action required',
>                 ],
>                 description => 'This metric lists any Purchase Orders that have exceeded the delivery time threshold, and are currently waiting in AN for delivery to the Supplier over an integrated cXML channel.',
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
>             };
122,155d86
<                 #warn   => 'answer =~ /status: warn/i',
<                 #crit   => 'answer =~ /status: crit/i',
<                 crit              => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                 uiHint            => 'Unable to Transmit from EDI Gateway to Supplier',
<                 perl              => sub {return scalar (@edi_transmit_failure);},
<                 correctiveActions => [
<                                       Support => ' Go through the list of documents and see if these are issues with the customer document or functional issues. File CR for functional issues, follow CIRS if necessary',
<                                       Ops     => 'No action required',
<                                      ],
<                 description      => 'This metric lists any Purchase Orders that have exceeded the delivery time threshold, and are currently waiting in the EDI gateway for delivery to the Supplier EDI endpoint.',
<                 recordItem       => 'numrows',
<                 recordMaxResults => 40000,
<                 inf_field        => 'count',
<                 inf_tags         => qq(type="unable to transmit from EDI Gateway to Supplier",community="$community"),
<                 inf_default      => 0,
<                 group_by         => "edi_gateway_to_supplier,$community",
<                                                                                                              };
<             $i = 1;
<             foreach my $row (@edi_transmit_failure)
<             {
<                 my @cols = split (/\|\|/, $row);
<                 foreach my $col (@cols)
<                 {
<                     my ($field, $value) = split (/=/, $col);
<                     $queries{"$field $i"} = {
<                                              perl        => sub {return $value},
<                                              inf_field   => $field,
<                                              inf_tags    => qq(type="unable to transmit from EDI Gateway to Supplier",community="$community",row_id=$i),
<                                              inf_default => 0,
<                                              group_by    => "edi_gateway_to_supplier,$community,$i",
<                                             };
<                 }
<                 $i++;
<             }
156a88,113
> 
>         $queries{"Delivery time threshold exceeded - Unable to transmit from EDI Gateway to Supplier"} = {
>             info    => 1,
>             #warn   => 'answer =~ /status: warn/i',
>             #crit   => 'answer =~ /status: crit/i',
>             crit    => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>             uiHint  => 'Unable to Transmit from EDI Gateway to Supplier',
>             perl    => sub { 
>                 my $params = { 
>                     BusinessObject => 'PurchaseOrder', 
>                     MetricType => 'EDITransmitFailure' 
>                 };
>                 my $url = ariba::monitor::Bpm::urlForANApp($an, 'EDIBusinessProcessMonitor');
>                 my $urls = ariba::monitor::Bpm::communityUrlsForUrlAndCommunities($url, 'default');
>                 my $responses = ariba::monitor::Bpm::getResponsesForUrlsAndParams($urls, $params);
> 
>                 return ariba::monitor::Bpm::processResultsFromResponses($responses, $processedPayloadIds);
>             },
>             correctiveActions   => [
>                 Support => ' Go through the list of documents and see if these are issues with the customer document or functional issues. File CR for functional issues, follow CIRS if necessary',
>                 Ops => 'No action required',
>             ],
>             description => 'This metric lists any Purchase Orders that have exceeded the delivery time threshold, and are currently waiting in the EDI gateway for delivery to the Supplier EDI endpoint.',
>             recordItem          => 'numrows',
>             recordMaxResults    => 40000,
>         };
159,162c116,122
<     if (ariba::rc::InstalledProduct->isInstalled('buyer', $me->service()))
<     {
<         my $buyer = ariba::rc::InstalledProduct->new('buyer', $me->service());
<         my $params = {BusinessObject => 'DirectOrder', MetricType => 'ExceededDeliveryTime'};
---
>     if (ariba::rc::InstalledProduct->isInstalled('buyer', $me->service())) {
>         my $buyer = ariba::rc::InstalledProduct->new('buyer', $me->service()); 
> 
>         my $params = { 
>             BusinessObject => 'DirectOrder', 
>             MetricType => 'ExceededDeliveryTime' 
>         };
165,167c125,126
<         foreach my $community (keys (%$urls))
<         {
<             my $communityUrl = {$community => $urls->{$community}};
---
>         foreach my $community (keys(%$urls)) {
>             my $communityUrl = { $community => $urls->{$community} };
171d129
<             my @awaiting_ssp_to_an = ariba::monitor::Bpm::processResultsFromResponses($responsesForNon4xx);
173,191c131,148
<                                                                  info                         => 1,
<                                                                  warn                         => 'answer =~ /status: warn/i',
<                                                                  crit                         => '(answer =~ /status: crit/i  && (previousAnswer =~ /status: crit/i)) || (answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                                                                  severity                     => 1,
<                                                                  ticketOnWarnOpenAfterMinutes => 60,
<                                                                  ticketDueInDays              => 'today',
<                                                                  uiHint                       => 'Currently waiting for delivery from SSP Buyer to AN (Communication Error)',
<                                                                  perl                         => sub {return scalar (@awaiting_ssp_to_an);},
<                                                                  correctiveActions            => [
<                                                                                        Ops     => 'The problem is likely at the network transport level and Ops should investigate',
<                                                                                        Support => 'No action needed. Display as FYI',
<                                                                                       ],
<                                                                  description => 'This metric lists any Purchase Orders in the Buyer/SSP application that have exceeded the delivery time threshold due to communication errors encountered while attempting to send the Order to AN over the cXML channel.',
<                                                                  recordItem  => 'numrows',
<                                                                  recordMaxResults => 40000,
<                                                                  inf_field        => 'count',
<                                                                  inf_tags         => qq(type="awaiting ssp buyer to an communication error",community="$community"),
<                                                                  inf_default      => 0,
<                                                                  group_by         => "awaiting_ssp_to_an,$community",
---
>                 info    => 1,
>                 warn    => 'answer =~ /status: warn/i',
>                 crit    => '(answer =~ /status: crit/i  && (previousAnswer =~ /status: crit/i)) || (answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>                 severity => 1,
>                 ticketOnWarnOpenAfterMinutes => 60,
>                 ticketDueInDays     => 'today',
>                 uiHint  => 'Currently waiting for delivery from SSP Buyer to AN (Communication Error)',
>                 perl    => sub { 
> 
>                     return ariba::monitor::Bpm::processResultsFromResponses($responsesForNon4xx);
>                 },
>                 correctiveActions   => [
>                     Ops => 'The problem is likely at the network transport level and Ops should investigate', 
>                     Support => 'No action needed. Display as FYI',
>                 ],
>                 description => 'This metric lists any Purchase Orders in the Buyer/SSP application that have exceeded the delivery time threshold due to communication errors encountered while attempting to send the Order to AN over the cXML channel.',
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
193,223d149
<             my $i = 1;
<             foreach my $row (@awaiting_ssp_to_an)
<             {
< 
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"comm error $community $i"} = {
<                                                             perl        => sub {return $row},
<                                                             inf_field   => "error",
<                                                             inf_tags    => qq(type="awaiting ssp buyer to an communication error",community="$community",row_id=$i),
<                                                             inf_default => 0,
<                                                             group_by    => "awaiting_ssp_to_an,$community,$i",
<                                                            };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl        => sub {return $value},
<                                                  inf_field   => $field,
<                                                  inf_tags    => qq(type="awaiting ssp buyer to an communication error",community="$community",row_id=$i),
<                                                  inf_default => 0,
<                                                  group_by    => "awaiting_ssp_to_an,$community,$i",
<                                                 };
<                     }
<                 }
<                 $i++;
<             }
225d150
<             my @awaiting_ssp_to_an_config_issues = ariba::monitor::Bpm::processResultsFromResponses($responsesFor4xx);
227,228c152
<                 info => 1,
< 
---
>                 info    => 1,
231,233c155,157
<                 crit              => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
<                 uiHint            => 'Currently waiting for delivery from SSP Buyer to AN (Configuration Issue)',
<                 perl              => sub {return scalar (@awaiting_ssp_to_an_config_issues);},
---
>                 crit    => '(answer =~ /time.*out.*after/ && previousAnswer =~ /time.*out.*after/)',
>                 uiHint  => 'Currently waiting for delivery from SSP Buyer to AN (Configuration Issue)',
>                 perl    => sub { return ariba::monitor::Bpm::processResultsFromResponses($responsesFor4xx); },
235,276c159,166
<                 correctiveActions => [
<                                       Ops     => 'No action required',
<                                       Support => 'The problem is likely related to customer configuration problem in the application, either in SSP or AN. Once the exact nature of the problem is determined, the customer should be advised of the best corrective action.',
<                                      ],
<                 description      => 'This metric lists any Purchase Orders in the Buyer/SSP application that have exceeded the delivery time threshold due to configuration issues encountered while attempting to send the Order to AN over the cXML channel.',
<                 recordItem       => 'numrows',
<                 recordMaxResults => 40000,
<                 inf_field        => 'count',
<                 inf_tags         => qq(type="awaiting ssp buyer to an config issue",community="$community"),
<                 inf_default      => 0,
<                 group_by         => "awaiting_ssp_to_an_config_issue,$community",
<                                                                                                                                                                       };
<             $i = 1;
<             foreach my $row (@awaiting_ssp_to_an_config_issues)
<             {
<                 if ($row =~ /http request error/i)
<                 {
<                     $queries{"error config issue $community $i"} = {
<                                                                     perl        => sub {return $row},
<                                                                     inf_field   => "error",
<                                                                     inf_tags    => qq(type="awaiting ssp buyer to an config issue",community="$community",row_id=$i),
<                                                                     inf_default => 0,
<                                                                     group_by    => "awaiting_ssp_to_an_config_issue,$community,$i",
<                                                                    };
<                 }
<                 else
<                 {
<                     my @cols = split (/\|\|/, $row);
<                     foreach my $col (@cols)
<                     {
<                         my ($field, $value) = split (/=/, $col);
<                         $queries{"$field $i"} = {
<                                                  perl        => sub {return $value},
<                                                  inf_field   => $field,
<                                                  inf_tags    => qq(type="awaiting ssp buyer to an config issue",community="$community",row_id=$i),
<                                                  inf_default => 0,
<                                                  group_by    => "awaiting_ssp_to_an_config_issue,$community,$i",
<                                                 };
<                     }
<                     $i++;
<                 }
<             }
---
>                 correctiveActions   => [
>                     Ops => 'No action required', 
>                     Support => 'The problem is likely related to customer configuration problem in the application, either in SSP or AN. Once the exact nature of the problem is determined, the customer should be advised of the best corrective action.',
>                 ],
>                 description => 'This metric lists any Purchase Orders in the Buyer/SSP application that have exceeded the delivery time threshold due to configuration issues encountered while attempting to send the Order to AN over the cXML channel.',
>                 recordItem          => 'numrows',
>                 recordMaxResults    => 40000,
>             };
282,284c172
<     if (%queries)
<     {
<         $queries{influx_details} = {measurement => "bpm_po_exceeded_delivery_time"};
---
>     if (%queries) {
288a177,180
>     if (%queries2) {
>         my $qm = ariba::monitor::QueryManager->newWithDetails('PO-has-exceeded-delivery-time-threshold', $tab, $me->service(), $me->customer(), \%queries2);
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
>     }
filename:./bin/buyer/catalog-status
2a3,4
> # $Id: //ariba/services/monitor/bin/buyer/catalog-status#48 $
> #
16c18
< my $maxResults = 35040;    # one year running 4 times an hour
---
> my $maxResults = 35040; # one year running 4 times an hour
18,23c20,24
< sub main
< {
<     my $debug       = 0;
<     my $quiet       = 0;
<     my $sendEmail   = 0;
<     my $sendPage    = 0;
---
> sub main {
>     my $debug = 0;
>     my $quiet = 0;
>     my $sendEmail = 0;
>     my $sendPage = 0;
26,32c27,32
<     while (my $arg = shift (@ARGV))
<     {
<         print STDERR "parsing arg $arg\n" if $debug && !$quiet;
<         if ($arg =~ /^-d/o)    {$debug       = 1;}
<         if ($arg =~ /^-e/o)    {$sendEmail   = 1;}
<         if ($arg =~ /^-p$/o)   {$sendPage    = 1;}
<         if ($arg =~ /^-prod/o) {$productName = shift (@ARGV); next;}
---
>     while(my $arg=shift(@ARGV)){
>             print STDERR "parsing arg $arg\n" if $debug && !$quiet;
>             if ($arg =~ /^-d/o){ $debug=1; }
>             if ($arg =~ /^-e/o){ $sendEmail=1; };
>             if ($arg =~ /^-p$/o){ $sendPage=1; };
>             if ($arg =~ /^-prod/o) { $productName = shift(@ARGV); next; }
35c35
<     my $me      = ariba::rc::InstalledProduct->new();
---
>     my $me = ariba::rc::InstalledProduct->new();
38c38
<     my $email   = $me->default('notify.email');
---
>     my $email = $me->default('notify.email');
41,43c41,42
<     unless (@products)
<     {
<         exit (0);
---
>     unless (@products) {
>         exit(0);
46,47c45
<     for my $product (@products)
<     {
---
>     for my $product (@products) {
49,54c47,51
<         my $skip    = 0;
<         my %queries = ();
<         my $outage  = ariba::monitor::OutageSchedule->new('daily 22:00-02:00');
< 
<         for my $instance ($product->appInstancesInCluster($cluster))
<         {
---
>         my $skip = 0;
>         my %queries  = ();
>         my $outage = ariba::monitor::OutageSchedule->new('daily 22:00-02:00');
>     
>         for my $instance ($product->appInstancesInCluster($cluster)) {
57,58c54,55
<             $instanceName .= " " . $instance->logicalName() if $instance->logicalName();
<             my $community   = $instance->community();
---
>             $instanceName .= ", " . $instance->logicalName() if $instance->logicalName();
>             my $community = $instance->community();
65,66c62
<             if ($serverRoles =~ m|CatalogAdmin|)
<             {
---
>             if ($serverRoles =~ m|CatalogAdmin|) {
69,70c65
<             if ($serverRoles =~ m|CatalogSearch|)
<             {
---
>             if ($serverRoles =~ m|CatalogSearch|) {
73,74c68
<             if ($serverRoles =~ m|AribaUI|)
<             {
---
>             if ($serverRoles =~ m|AribaUI|) {
78,79c72
<             unless ($instanceIsAdmin || $instanceIsSearch || $instanceIsUI)
<             {
---
>             unless ($instanceIsAdmin || $instanceIsSearch || $instanceIsUI) {
84,85c77
<             if ($product->isASPProduct())
<             {
---
>             if ($product->isASPProduct()) {
87,91c79,80
<             }
<             else
<             {
<                 if ($community)
<                 {
---
>             } else {
>                 if ($community) {
93,95c82
<                 }
<                 else
<                 {
---
>                 } else {
101,102c88,89
<             my $testAdminUrl        = $instance->catalogSelfTestAdminMonitorURL();
<             my $testRegistryUrl     = $instance->catalogSelfTestRegistryMonitorURL();
---
>             my $testAdminUrl = $instance->catalogSelfTestAdminMonitorURL();
>             my $testRegistryUrl = $instance->catalogSelfTestRegistryMonitorURL();
106,107c93
<             if ($instanceIsUI)
<             {
---
>             if ($instanceIsUI) {
111c97,98
<                 my ($indexSize, $queryTime, $slowQueries, $failedQueries, $queryTally, $queryTimeQualifier);
---
>                 my ( $indexSize, $queryTime, $slowQueries, $failedQueries,
>                         $queryTally, $queryTimeQualifier );
113,115c100,102
<                 my $queryTimeInfo = "answer <= 2";
<                 my $queryTimeWarn = "answer =~ /^Error/ || answer > 2";
<                 my $queryTimeCrit = "answer !~ /^Error/ && answer > 5";
---
>                                 my $queryTimeInfo = "answer <= 2";
>                                 my $queryTimeWarn = "answer =~ /^Error/ || answer > 2";
>                                 my $queryTimeCrit = "answer !~ /^Error/ && answer > 5";
117,118c104
<                 if ($searchClientStatus->error())
<                 {
---
>                 if($searchClientStatus->error()) {
121,130c107,111
<                     chomp ($error);
<                     if ($searchClientStatus->isDown())
<                     {
<                         #$urlError = "Error: This node is currently unreachable [$error]";
<                         $urlError = -1;
<                     }
<                     else
<                     {
<                         #$urlError = "Error: $error";
<                         $urlError = -1;
---
>                     chomp($error);
>                     if( $searchClientStatus->isDown() ) {
>                         $urlError = "Error: This node is currently unreachable [$error]";
>                     } else {
>                         $urlError = "Error: $error";
133,135c114,116
<                     $indexSize     = $urlError;
<                     $queryTime     = $urlError;
<                     $slowQueries   = $urlError;
---
>                     $indexSize = $urlError;
>                     $queryTime = $urlError;
>                     $slowQueries = $urlError;
137,142c118,121
<                     $queryTally    = $urlError;
<                 }
<                 else
<                 {
<                     $indexSize     = $searchClientStatus->indexSize();
<                     $slowQueries   = $searchClientStatus->slowQueryTally();
---
>                     $queryTally = $urlError;
>                 } else {
>                     $indexSize = $searchClientStatus->indexSize();
>                     $slowQueries = $searchClientStatus->slowQueryTally();
144,147c123,125
<                     $queryTally    = $searchClientStatus->queryTally();
<                     if (defined ($searchClientStatus->averageQueryTime()))
<                     {
<                         $queryTime          = $searchClientStatus->averageQueryTime();
---
>                     $queryTally = $searchClientStatus->queryTally();
>                     if (defined($searchClientStatus->averageQueryTime())) {
>                         $queryTime = $searchClientStatus->averageQueryTime();
149,156c127,132
<                     }
<                     else
<                     {
<                         $queryTime          = $searchClientStatus->queryTime();
<                         $queryTimeQualifier = "90th_Percentile";
<                         $queryTimeInfo      = "1";
<                         $queryTimeWarn      = undef;
<                         $queryTimeCrit      = undef;
---
>                     } else {
>                         $queryTime = $searchClientStatus->queryTime();
>                         $queryTimeQualifier = "90th Percentile";
>                         $queryTimeInfo = "1";
>                         $queryTimeWarn = undef;
>                         $queryTimeCrit = undef;
161,190c137,156
<                                                                       'uiHint'           => $uiHint,
<                                                                       'info'             => "answer <= 600000",
<                                                                       'warn'             => "answer =~ /^Error/ || answer > 600000",
<                                                                       'crit'             => "answer !~ /^Error/ && answer > 800000",
<                                                                       'perl'             => sub {qq("$indexSize")},
<                                                                       'recordMaxResults' => $maxResults,
<                                                                       'recordDataType'   => 'gauge',
<                                                                       'recordItem'       => 'answer',
<                                                                       'inf_field'        => 'index_size',
<                                                                       'inf_default'      => "none",
<                                                                       'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                       'group_by'         => qq($uiHint,$instanceName),
<                                                                      };
<         if ( $queryTimeQualifier )
<         {
<                     $queries{"$instanceName Search Client $queryTimeQualifier Query Time"} = {
<                                                                                           'uiHint'           => $uiHint,
<                                                                                           'info'             => $queryTimeInfo,
<                                                                                           'warn'             => $queryTimeWarn,
<                                                                                           'crit'             => $queryTimeCrit,
<                                                                                           'perl'             => sub {$queryTime},
<                                                                                           'recordMaxResults' => $maxResults,
<                                                                                           'recordDataType'   => 'gauge',
<                                                                                           'recordItem'       => 'answer',
<                                                                                           'inf_field'        => $queryTimeQualifier,
<                                                                                   'inf_default'      => "none",
<                                                                                           'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                                           'group_by'         => qq($uiHint,$instanceName),
<                                                                                          };
<         };
---
>                     'uiHint' => $uiHint,
>                     'info' => "answer <= 600000",
>                     'warn' => "answer =~ /^Error/ || answer > 600000",
>                     'crit' => "answer !~ /^Error/ && answer > 800000",
>                     'perl' => sub { $indexSize },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
> 
>                 $queries{"$instanceName Search Client $queryTimeQualifier Query Time"} = {
>                     'uiHint' => $uiHint,
>                     'info' => $queryTimeInfo,
>                     'warn' => $queryTimeWarn,
>                     'crit' => $queryTimeCrit,
>                     'perl' => sub { $queryTime },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
198,200c164,166
<                     'info'   => 1,
<                     'warn'   => "answer =~ /^Error/ || answer > 3",
<                     'crit'   => "answer !~ /^Error/ && answer > 5",
---
>                     'info' => 1,
>                     'warn' => "answer =~ /^Error/ || answer > 3",
>                     'crit' => "answer !~ /^Error/ && answer > 5",
202,204c168,169
<                     'perl'   => sub {
<                         if ($slowQueries =~ /^Error/)
<                         {
---
>                     'perl' => sub {
>                         if ($slowQueries =~ /^Error/) {
209,210c174,175
<                         return $queryTally  if $queryTally <= 0;
<                         return ($slowQueries / $queryTally);
---
>                         return $queryTally if $queryTally <= 0;
>                         return ($slowQueries/$queryTally);
213,220c178,181
<                     'recordDataType'   => 'gauge',
<                     'recordItem'       => 'answer',
<                     'recordDataUnits'  => 'precent',
<                     'inf_field'        => "slow_queries",
<                     'inf_default'      => "none",
<                     'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                     'group_by'         => qq($uiHint,$instanceName),
<                                                                                };
---
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                     'recordDataUnits' => 'precent',
>                 };
223,235c184,192
<                                                                                        'uiHint'           => $uiHint,
<                                                                                        'info'             => 1,
<                                                                                        'warn'             => "answer =~ /^Error/ || answer > 10",
<                                                                                        'crit'             => "answer !~ /^Error/ && answer > 20",
<                                                                                        'perl'             => sub {$failedQueries},
<                                                                                        'recordMaxResults' => $maxResults,
<                                                                                        'recordDataType'   => 'gauge',
<                                                                                        'recordItem'       => 'answer',
<                                                                                        'inf_field'        => "failed_queries",
<                                                                                        'inf_default'      => "none",
<                                                                                        'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                                        'group_by'         => qq($uiHint,$instanceName),
<                                                                                       };
---
>                     'uiHint' => $uiHint,
>                     'info' => 1,
>                     'warn' => "answer =~ /^Error/ || answer > 10",
>                     'crit' => "answer !~ /^Error/ && answer > 20",
>                     'perl' => sub { $failedQueries },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
238,248c195,201
<                                                                          'uiHint'           => $uiHint,
<                                                                          'info'             => 1,
<                                                                          'perl'             => sub {$queryTally},
<                                                                          'recordMaxResults' => $maxResults,
<                                                                          'recordDataType'   => 'gauge',
<                                                                          'recordItem'       => 'answer',
<                                                                          'inf_field'        => "total_queries",
<                                                                          'inf_default'      => "none",
<                                                                          'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                          'group_by'         => qq($uiHint,$instanceName),
<                                                                         };
---
>                     'uiHint' => $uiHint,
>                     'info' => 1,
>                     'perl' => sub { $queryTally },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
252,253c205
<             if ($instanceIsAdmin)
<             {
---
>             if ($instanceIsAdmin) {
266,268c218,219
<                 if (defined ($adminStatus->state()) || defined ($adminStatus->publisherStatus()))
<                 {
<                     my ($numLogs, $waitTime, $adminHealth, $publishDuration, $lastPublishedTime, $realmsAwaitingPublish, $publishRetryCount);
---
>                 if (defined($adminStatus->state()) || defined($adminStatus->publisherStatus())) {
>                     my ( $numLogs, $waitTime, $adminHealth, $publishDuration, $lastPublishedTime, $realmsAwaitingPublish, $publishRetryCount );
270,271c221
<                     if ($adminStatus->error())
<                     {
---
>                     if($adminStatus->error()) {
273c223
<                         chomp ($error);
---
>                         chomp($error);
275,283c225,228
<                         if ($adminStatus->isDown())
<                         {
<                             #$urlError = "Error: This node is currently unreachable [$error]";
<                             $urlError = -1;
<                         }
<                         else
<                         {
<                             #$urlError = "Error: $error";
<                             $urlError = -1;
---
>                         if($adminStatus->isDown()) {
>                             $urlError = "Error: This node is currently unreachable [$error]";
>                         } else {
>                             $urlError = "Error: $error";
286,287c231,232
<                         $numLogs     = $urlError;
<                         $waitTime    = $urlError;
---
>                         $numLogs = $urlError;
>                         $waitTime = $urlError;
289,292c234,235
<                     }
<                     else
<                     {
<                         $numLogs  = $adminStatus->numLogs();
---
>                     } else {
>                         $numLogs = $adminStatus->numLogs();
295,299c238,242
<                         my $publisherStatus   = $adminStatus->state() || $adminStatus->publisherStatus();
<                         my $publisherErrors   = $adminStatus->publisherErrors();
<                         my $skippedRealms     = $adminStatus->skippedRealms();
<                         $publishDuration       = $adminStatus->publishDuration();
<                         $lastPublishedTime     = $adminStatus->lastPublishedTime();
---
>                         my $publisherStatus = $adminStatus->state() || $adminStatus->publisherStatus();
>                         my $publisherErrors = $adminStatus->publisherErrors();
>                         my $skippedRealms = $adminStatus->skippedRealms();
>                         $publishDuration = $adminStatus->publishDuration();
>                         $lastPublishedTime = $adminStatus->lastPublishedTime();
301,302c244,245
<                         $publishRetryCount     = $adminStatus->publishRetryCount();
<                         $adminHealth           = "";
---
>                         $publishRetryCount = $adminStatus->publishRetryCount();
>                         $adminHealth = "";
304,305c247
<                         if ($adminConnectivity && $adminConnectivity !~ /OK/i)
<                         {
---
>                         if ($adminConnectivity && $adminConnectivity !~ /OK/i) {
308,309c250
<                         if ($publisherErrors && $publisherErrors !~ /false/i)
<                         {
---
>                         if ($publisherErrors && $publisherErrors !~ /false/i) {
313,314c254
<                         if ($skippedRealms && $skippedRealms !~ /^\s*/)
<                         {
---
>                         if($skippedRealms && $skippedRealms !~ /^\s*/) {
317,318c257
<                         if ($publisherStatus)
<                         {
---
>                         if ($publisherStatus) {
320,326c259,262
<                             if ($publisherStatus =~ /PublishNodeDown|RebuildNodeDown|RebuildErrorRetry|CatalogSearchNodeDown/)
<                             {
<                                 $status = 'Error: ';
<                             }
<                             elsif ($publisherStatus =~ /PublisherWaitingAfterFailedAttempt/)
<                             {
<                                 $status = 'Warn: ';
---
>                             if ($publisherStatus =~ /PublishNodeDown|RebuildNodeDown|RebuildErrorRetry|CatalogSearchNodeDown/) {
>                                 $status = 'Error: '; 
>                             } elsif ($publisherStatus =~ /PublisherWaitingAfterFailedAttempt/) {
>                                 $status = 'Warn: '; 
332,334c268
<                         }
<                         else
<                         {
---
>                         } else {
341,352c275,282
<                                                               'uiHint'      => $uiHint,
<                                                               'noRowCount'  => 1,
<                                                               'info'        => "answer",
<                                                               'warn'        => "answer && (answer =~ /^Warn/i)",
<                                                               'crit'        => "!answer || (answer =~ /^Error/i && answer !~ /PublishErrorRetry/)",
<                                                               'severity'    => $severity,
<                                                               'perl'        => "return \"$adminHealth\";",
<                                                               'inf_field'   => 'admin_health',
<                                                               'inf_default' => "none",
<                                                               'inf_tags'    => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                               'group_by'    => qq($uiHint,$instanceName),
<                                                              };
---
>                         'uiHint' => $uiHint,
>                         'noRowCount' => 1,
>                         'info' => "answer",
>                         'warn' => "answer && (answer =~ /^Warn/i)",
>                         'crit' => "!answer || (answer =~ /^Error/i && answer !~ /PublishErrorRetry/)",
>                         'severity' => $severity,
>                         'perl' => "return \"$adminHealth\";",
>                     };
358,359c288,289
<                     my $durationWarn   = 7200;     # 2-hours
<                     my $durationCrit   = 10800;    # 3-hours
---
>                     my $durationWarn = 7200; # 2-hours
>                     my $durationCrit = 10800; # 3-hours
362,363c292
<                     if ($publishRebuildState =~ /RebuildInProgress/)
<                     {
---
>                     if ($publishRebuildState =~ /RebuildInProgress/) {
366,368c295,297
<                         $durationWarn   = 21600;    # 6-hours
<                         $durationCrit   = 36000;    # 10-hours
<                     }
---
>                         $durationWarn = 21600; # 6-hours
>                         $durationCrit = 36000; # 10-hours
>                     };
371,379c300,304
<                                                                       'warn'        => "answer > $retryCountWarn",
<                                                                       'crit'        => "answer > $retryCountCrit",
<                                                                       'uiHint'      => $uiHint,
<                                                                       'perl'        => "return $publishRetryCount;",
<                                                                       'inf_field'   => 'publish_retry_count',
<                                                                       'inf_default' => "none",
<                                                                       'inf_tags'    => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                       'group_by'    => qq($uiHint,$instanceName),
<                                                                      };
---
>                         'warn' => "answer > $retryCountWarn",
>                         'crit' => "answer > $retryCountCrit",
>                         'uiHint' => $uiHint,
>                         'perl' => "return $publishRetryCount;", 
>                     };
382,391c307,311
<                                                                    'warn'        => "answer > $durationWarn",
<                                                                    'crit'        => "answer > $durationCrit",
<                                                                    'uiHint'      => $uiHint,
<                                                                    'perl'        => "return $publishDuration;",
<                                                                    'inf_field'   => 'publish_duration',
<                                                                    'inf_default' => "none",
<                                                                    'inf_tags'    => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                    'group_by'    => qq($uiHint,$instanceName),
<                                                                   };
< 
---
>                         'warn' => "answer > $durationWarn",
>                         'crit' => "answer > $durationCrit",
>                         'uiHint' => $uiHint,
>                         'perl' => "return $publishDuration;",
>                     };
395,403c315,319
<                                                                     'uiHint'      => $uiHint,
<                                                                     'noRowCount'  => 1,
<                                                                     'info'        => "answer",
<                                                                     'perl'        => "return \"$lastPublishedTime\";",
<                                                                     'inf_field'   => 'last_publish_time',
<                                                                     'inf_default' => "none",
<                                                                     'inf_tags'    => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                     'group_by'    => qq($uiHint,$instanceName),
<                                                                    };
---
>                         'uiHint' => $uiHint,
>                         'noRowCount' => 1,
>                         'info' => "answer",
>                         'perl' => "return \"$lastPublishedTime\";",
>                     };
406,414c322,326
<                                                                           'uiHint'      => $uiHint,
<                                                                           'noRowCount'  => 1,
<                                                                           'info'        => "answer",
<                                                                           'perl'        => "return \"$realmsAwaitingPublish\";",
<                                                                           'inf_field'   => 'realms_awaiting_publish',
<                                                                           'inf_default' => "none",
<                                                                           'inf_tags'    => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                           'group_by'    => qq($uiHint,$instanceName),
<                                                                          };
---
>                         'uiHint' => $uiHint,
>                         'noRowCount' => 1,
>                         'info' => "answer",
>                         'perl' => "return \"$realmsAwaitingPublish\";",
>                     };
416,417c328
<                     if (defined ($numLogs))
<                     {
---
>                     if(defined($numLogs)) {
419,429c330,336
<                                                                                               'uiHint'           => $uiHint,
<                                                                                               'info'             => "1",
<                                                                                               'perl'             => $numLogs,
<                                                                                               'recordMaxResults' => $maxResults,
<                                                                                               'recordDataType'   => 'gauge',
<                                                                                               'recordItem'       => 'answer',
<                                                                                               'inf_field'        => 'admin_log_awaiting',
<                                                                                               'inf_default'      => "none",
<                                                                                               'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                                               'group_by'         => qq($uiHint,$instanceName),
<                                                                                              };
---
>                             'uiHint' => $uiHint,
>                             'info' => "1",
>                             'perl' => $numLogs,
>                             'recordMaxResults' => $maxResults,
>                             'recordDataType' => 'gauge',
>                             'recordItem' => 'answer',
>                         };
431,432c338,339
<                         my $warnWait = 3 * 60 * 60;    # 3 hours in secs
<                         my $critWait = 6 * 60 * 60;    # 6 hours in secs
---
>                         my $warnWait = 3*60*60; # 3 hours in secs
>                         my $critWait = 6*60*60; # 6 hours in secs
435,447c342,350
<                                                                                             'uiHint'           => $uiHint,
<                                                                                             'info'             => "answer <= $warnWait",
<                                                                                             'warn'             => "answer =~ /^Error/ || answer > $warnWait",
<                                                                                             'crit'             => "answer !~ /^Error/ && answer > $critWait",
<                                                                                             'perl'             => sub {$waitTime},
<                                                                                             'recordMaxResults' => $maxResults,
<                                                                                             'recordDataType'   => 'gauge',
<                                                                                             'recordItem'       => 'answer',
<                                                                                             'inf_field'        => 'admin_oldest_log_awaiting',
<                                                                                             'inf_default'      => "none",
<                                                                                             'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                                             'group_by'         => qq($uiHint,$instanceName),
<                                                                                            };
---
>                             'uiHint' => $uiHint,
>                             'info' => "answer <= $warnWait",
>                             'warn' => "answer =~ /^Error/ || answer > $warnWait",
>                             'crit' => "answer !~ /^Error/ && answer > $critWait",
>                             'perl' => sub { $waitTime },
>                             'recordMaxResults' => $maxResults,
>                             'recordDataType' => 'gauge',
>                             'recordItem' => 'answer',
>                         };
455,466c358,365
<                                                              'uiHint'      => $uiHint,
<                                                              'noRowCount'  => 1,
<                                                              'info'        => 1,
<                                                              'warn'        => "answer && answer =~ /^Warn/i",
<                                                              'crit'        => "answer && answer =~ /^Error/i",
<                                                              'perl'        => sub {main::registryHealth($registryStatus);},
<                                                              'inf_field'   => 'registry_health',
<                                                              'inf_default' => "none",
<                                                              'inf_tags'    => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                              'group_by'    => qq($uiHint,$instanceName),
<                                                             };
<             }
---
>                     'uiHint' => $uiHint,
>                     'noRowCount' => 1,
>                     'info' => 1,
>                     'warn' => "answer && answer =~ /^Warn/i",
>                     'crit' => "answer && answer =~ /^Error/i",
>                     'perl' => sub { main::registryHealth($registryStatus); },
>                 };
>             } 
468,469c367
<             if ($instanceIsSearch)
<             {
---
>             if ($instanceIsSearch) {
473c371,372
<                 my ($indexSize, $queryTime, $slowQueries, $failedQueries, $queryTally, $queryTimeQualifier);
---
>                 my ( $indexSize, $queryTime, $slowQueries, $failedQueries,
>                         $queryTally, $queryTimeQualifier );
475,477c374,376
<                 my $queryTimeInfo = "answer <= 2";
<                 my $queryTimeWarn = "answer =~ /^Error/ || answer > 2";
<                 my $queryTimeCrit = "answer !~ /^Error/ && answer > 5";
---
>                                 my $queryTimeInfo = "answer <= 2";
>                                 my $queryTimeWarn = "answer =~ /^Error/ || answer > 2";
>                                 my $queryTimeCrit = "answer !~ /^Error/ && answer > 5";
479,480c378
<                 if ($searchStatus->error())
<                 {
---
>                 if($searchStatus->error()) {
483,492c381,385
<                     chomp ($error);
<                     if ($searchStatus->isDown())
<                     {
<                         #$urlError = "Error: This node is currently unreachable [$error]";
< 			$urlError = -1;
<                     }
<                     else
<                     {
<                         #$urlError = "Error: $error";
< 			$urlError = -1;
---
>                     chomp($error);
>                     if( $searchStatus->isDown() ) {
>                         $urlError = "Error: This node is currently unreachable [$error]";
>                     } else {
>                         $urlError = "Error: $error";
495,497c388,390
<                     $indexSize     = $urlError;
<                     $queryTime     = $urlError;
<                     $slowQueries   = $urlError;
---
>                     $indexSize = $urlError;
>                     $queryTime = $urlError;
>                     $slowQueries = $urlError;
499,504c392,395
<                     $queryTally    = $urlError;
<                 }
<                 else
<                 {
<                     $indexSize     = $searchStatus->indexSize();
<                     $slowQueries   = $searchStatus->slowQueryTally();
---
>                     $queryTally = $urlError;
>                 } else {
>                     $indexSize = $searchStatus->indexSize();
>                     $slowQueries = $searchStatus->slowQueryTally();
506,509c397,399
<                     $queryTally    = $searchStatus->queryTally();
<                     if (defined ($searchStatus->averageQueryTime()))
<                     {
<                         $queryTime          = $searchStatus->averageQueryTime();
---
>                     $queryTally = $searchStatus->queryTally();
>                     if (defined($searchStatus->averageQueryTime())) {
>                         $queryTime = $searchStatus->averageQueryTime();
511,518c401,406
<                     }
<                     else
<                     {
<                         $queryTime          = $searchStatus->queryTime();
<                         $queryTimeQualifier = "90th_Percentile";
<                         $queryTimeInfo      = "1";
<                         $queryTimeWarn      = undef;
<                         $queryTimeCrit      = undef;
---
>                     } else {
>                         $queryTime = $searchStatus->queryTime();
>                         $queryTimeQualifier = "90th Percentile";
>                         $queryTimeInfo = "1";
>                         $queryTimeWarn = undef;
>                         $queryTimeCrit = undef;
523,552c411,430
<                                                                       'uiHint'           => $uiHint,
<                                                                       'info'             => "answer <= 6000000",
<                                                                       'warn'             => "answer =~ /^Error/ || answer > 6000000",
<                                                                       'crit'             => "answer !~ /^Error/ && answer > 8000000",
<                                                                       'perl'             => sub {qq("$indexSize")},
<                                                                       'recordMaxResults' => $maxResults,
<                                                                       'recordDataType'   => 'gauge',
<                                                                       'recordItem'       => 'answer',
<                                                                       'inf_field'        => 'index_size',
<                                                                       'inf_default'      => "none",
<                                                                       'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                       'group_by'         => qq($uiHint,$instanceName),
<                                                                      };
<         if ( $queryTimeQualifier )
<         {
<                     $queries{"$instanceName Search Client $queryTimeQualifier Query Time"} = {
<                                                                                           'uiHint'           => $uiHint,
<                                                                                           'info'             => $queryTimeInfo,
<                                                                                           'warn'             => $queryTimeWarn,
<                                                                                           'crit'             => $queryTimeCrit,
<                                                                                           'perl'             => sub {$queryTime},
<                                                                                           'recordMaxResults' => $maxResults,
<                                                                                           'recordDataType'   => 'gauge',
<                                                                                           'recordItem'       => 'answer',
<                                                                                           'inf_field'        => $queryTimeQualifier,
<                                                                                           'inf_default'      => "none",
<                                                                                           'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                                           'group_by'         => qq($uiHint,$instanceName),
<                                                                                          };
<         };
---
>                     'uiHint' => $uiHint,
>                     'info' => "answer <= 6000000",
>                     'warn' => "answer =~ /^Error/ || answer > 6000000",
>                     'crit' => "answer !~ /^Error/ && answer > 8000000",
>                     'perl' => sub { $indexSize },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
> 
>                 $queries{"$instanceName Search Client $queryTimeQualifier Query Time"} = {
>                     'uiHint' => $uiHint,
>                     'info' => $queryTimeInfo,
>                     'warn' => $queryTimeWarn,
>                     'crit' => $queryTimeCrit,
>                     'perl' => sub { $queryTime },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
560,562c438,440
<                     'info'   => 1,
<                     'warn'   => "answer =~ /^Error/ || answer > 10",
<                     'crit'   => "answer !~ /^Error/ && answer > 20",
---
>                     'info' => 1,
>                     'warn' => "answer =~ /^Error/ || answer > 10",
>                     'crit' => "answer !~ /^Error/ && answer > 20",
564,566c442,443
<                     'perl'   => sub {
<                         if ($slowQueries =~ /^Error/)
<                         {
---
>                     'perl' => sub {
>                         if ($slowQueries =~ /^Error/) {
571c448
<                         return ($slowQueries / $queryTally);
---
>                         return ($slowQueries/$queryTally);
574,581c451,454
<                     'recordDataType'   => 'gauge',
<                     'recordItem'       => 'answer',
<                     'recordDataUnits'  => 'precent',
<                     'inf_field'        => "slow_queries",
<                     'inf_default'      => "none",
<                     'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                     'group_by'         => qq($uiHint,$instanceName),
<                                                                                };
---
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                     'recordDataUnits' => 'precent',
>                 };
584,597c457,466
<                                                                                        'uiHint'           => $uiHint,
<                                                                                        'info'             => 1,
<                                                                                        'warn'             => "answer =~ /^Error/ || answer > 30",
<                                                                                        'crit'             => "answer !~ /^Error/ && answer > 50 && previousAnswer !~ /^Error/ && previousAnswer > 50",
<                                                                                        'perl'             => sub {$failedQueries},
<                                                                                        'recordMaxResults' => $maxResults,
<                                                                                        'recordDataType'   => 'gauge',
<                                                                                        'recordItem'       => 'answer',
<                                                                                        'outageSchedule'   => $outage,
<                                                                                        'inf_field'        => "failed_queries",
<                                                                                        'inf_default'      => "none",
<                                                                                        'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                                        'group_by'         => qq($uiHint,$instanceName),
<                                                                                       };
---
>                     'uiHint' => $uiHint,
>                     'info' => 1,
>                     'warn' => "answer =~ /^Error/ || answer > 30",
>                     'crit' => "answer !~ /^Error/ && answer > 50 && previousAnswer !~ /^Error/ && previousAnswer > 50",
>                     'perl' => sub { $failedQueries },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                     'outageSchedule' => $outage,
>                 };
600,610c469,475
<                                                                          'uiHint'           => $uiHint,
<                                                                          'info'             => 1,
<                                                                          'perl'             => sub {$queryTally},
<                                                                          'recordMaxResults' => $maxResults,
<                                                                          'recordDataType'   => 'gauge',
<                                                                          'recordItem'       => 'answer',
<                                                                          'inf_field'        => "total_queries",
<                                                                          'inf_default'      => "none",
<                                                                          'inf_tags'         => qq(instance_name="$instanceName",uiHint="$uiHint"),
<                                                                          'group_by'         => qq($uiHint,$instanceName),
<                                                                         };
---
>                     'uiHint' => $uiHint,
>                     'info' => 1,
>                     'perl' => sub { $queryTally },
>                     'recordMaxResults' => $maxResults,
>                     'recordDataType' => 'gauge',
>                     'recordItem' => 'answer',
>                 };
615,625c480,491
<         #$queries{ "search version" } = {
<         #    'format'    => "version %s, rebuild version %s, status %s",
<         #    'aql'       => "Select VersionName,RebuildVersionName,Status from SearchVersion",
<         #};
< 
<         $queries{influx_details} = {measurement => 'buyer_catalog_status'};
<         my $q = ariba::monitor::QueryManager->newWithDetails("catalog-status", $product->name(), $service, $product->customer(), \%queries);
< 
<         my $aqlConnection = ariba::Ops::AQLConnection->newFromProduct($product);
<         my $aqlClient     = ariba::Ops::AQLClient->newFromAQLConnection($aqlConnection);
<         $q->setAQLClient($aqlClient);
---
>         $queries{ "search version" } = {
>             'format'    => "version %s, rebuild version %s, status %s",
>             'aql'       => "Select VersionName,RebuildVersionName,Status from SearchVersion",
>         };
> 
>         my $q = ariba::monitor::QueryManager->newWithDetails(
>                 "catalog-status", $product->name(), $service, $product->customer(), \%queries
>         );
> 
>         my $aqlConnection = ariba::Ops::AQLConnection->newFromProduct( $product );
>         my $aqlClient = ariba::Ops::AQLClient->newFromAQLConnection( $aqlConnection );
>         $q->setAQLClient( $aqlClient );
630,631c496
< sub registryHealth
< {
---
> sub registryHealth {
636c501,502
<     chomp ($error);
---
>     chomp($error);
> 
645,655c511,515
<     if ($error)
<     {
<         if ($monUrl->isDown())
<         {
<             #push (@results, "This node is currently unreachable [$error]");
<             push (@results, -1);
<         }
<         else
<         {
<             #push (@results, "Error: $error");
<             push (@results, -1);
---
>     if ($error) {
>         if($monUrl->isDown()) {
>             push(@results, "This node is currently unreachable [$error]");
>         } else {
>             push(@results, "Error: $error");
657,660c517,518
<     }
<     else
<     {
<         push (@results, $monUrl->status());
---
>     } else {
>         push(@results, $monUrl->status());
663c521
<     return (join ("\n", @results));
---
>     return(join("\n", @results));
666,667c524
< sub fetchUrl
< {
---
> sub fetchUrl {
682,683c539
<     if ($error)
<     {
---
>     if ($error) {
686c542
<     }
---
>     } 
689c545
<     my $inError  = 0;
---
>     my $inError = 0;
691,693c547,548
<     for my $line (@results)
<     {
< 
---
>     for my $line (@results) {
>         
697,698c552
<         if ($line =~ m/Exception encountered\./)
<         {
---
>         if ( $line =~ m/Exception encountered\./ ){
703,704c557
<         if ($line eq '</Error>')
<         {
---
>         if ($line eq '</Error>') {
706,708c559
<         }
<         elsif ($line eq '<Error>')
<         {
---
>         } elsif ($line eq '<Error>') {
710,712c561
<         }
<         elsif ($inError)
<         {
---
>         } elsif ($inError) {
714,716c563
<         }
<         elsif ($line =~ m|<(\w+)>\s*(.*)\s*</(\w+)>|i)
<         {
---
>         } elsif ($line =~ m|<(\w+)>\s*(.*)\s*</(\w+)>|i) {
719,720c566,567
<             $property = lcfirst ($1);
<             $value    = $2;
---
>             $property = lcfirst($1);
>             $value = $2;
723,726c570,571
<         }
<         elsif ($line !~ m/<|>/)
<         {
<             chomp ($line);
---
>         } elsif ($line !~ m/<|>/) {
>             chomp($line);
filename:./bin/buyer/queue-status
3c3
< # $Id: //ariba/services/monitor/bin/buyer/queue-status#27 $
---
> # $Id: //ariba/services/monitor/bin/buyer/queue-status#29 $
17a18
> use dmail::LockLib;
20,129c21,140
<     my $debug = 0;
<     my $quiet = 0;
<     my $sendEmail = 0;
<     my $sendPage = 0;
<     my $productName;
< 
<     # tmid:166098
<     my $invDetailReqFailedDoc = "https://wiki.ariba.com:8443/display/ENGDPTS/How+to+handle+Buyer+CC%3AInvoiceDetailRequest+in+Failed+state";
< 
<     while(my $arg=shift(@ARGV)){
<             print STDERR "parsing arg $arg\n" if $debug && !$quiet;
<             if($arg =~ /^-d/o){ $debug=1; }
<             if($arg =~ /^-e/o){ $sendEmail=1; };
<             if($arg =~ /^-p$/o){ $sendPage=1; };
<             if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
<     my $email = $me->default('notify.email');
< 
< 
<     my @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
<     unless (@products) {
<         exit(0);
<     }
< 
<     for my $product (@products) {
< 
<         my $skip = 0;
<         my %queries  = ();
<         my %communitySeen = ();
< 
<         my %badPos = ();
<         my %missingPos = ();
<         my $numMissing = 0;
<         my $numBad = 0;
<         my $badPosOracleError;
<         my $missingPosOracleError;
<         my $badPosOutage;
<         if (grep { $productName eq $_ } ariba::rc::Globals::sharedServiceBuyerProducts() ) {
<             my $oc = ariba::Ops::OracleClient->new($product->connectInfoForOracleClient());
<             # PO's for which we don't even have a response recorded
<             # likely never even got to the ASN
<             getPos(\$oc, \%badPos, \$numBad, 0, \$badPosOracleError);
< 
<             # PO's which are still sending, but which are probably
<             # on the ASN
<             getPos(\$oc, \%missingPos, \$numMissing, 1, $missingPosOracleError);
< 
< 
<             my $anProductStatus = ariba::monitor::ProductStatus->newWithDetails("an", $product->service(), $product->customer());
< 
<             if ($anProductStatus->inPlannedDownTime()) {
<                 #my $now = DateTime->now( time_zone => 'local' );
<                 #my ($startHour, $startMinute) = ($now->hour(), $now->minute());
<                 #my $later = $today->add( minutes => 5 ); 
<                 #my ($endHour, $endMinute
< 
<                 $badPosOutage = ariba::monitor::OutageSchedule->new("daily 00:00-23:59");
<             }
<                     
<             $queries{"Orders not sent to the ASN in the last 10 days"} = {
<                 'recordMaxResults' => 60000,
<                 'recordDataType' => "gauge",
<                 'info' => 1,
<                 'warn' => "answer > 20",
<                 'crit' => "answer > 100 && previousAnswer > 100",
<                 'error' => $badPosOracleError,
<                 'outageSchedule' => $badPosOutage,
<                 'perl' => sub { return $numBad; },
<                 
<             } ;
<             $queries{"Orders in sending state with non-4xx responses in the last 10 days"} = {
<                 'recordMaxResults' => 60000,
<                 'recordDataType' => "gauge",
<                 'info' => 1,
<                 'warn' => "answer > 100",
<                 'crit' => "answer > 200",
<                 'error' => $missingPosOracleError,
<                 'outageSchedule' => $badPosOutage,
<                 'perl' => sub { return $numMissing; }
<             } ;
<         }
< 
<         for my $instance ($product->appInstancesInCluster($cluster)) {
< 
<             my $communityString = "";
<             my $community = 0;
<             my $uiHint;
< 
<             if ($product->isASPProduct()) {
<                 $uiHint = $instance->appName();
<             } else {
<                 $community = $instance->community();
<                 if ($community) {
<                     $communityString = " in community $community";
<                     $uiHint = "Community $community";
<                 } else {
<                     next;
<                 }
<             }
< 
<             next if ($communitySeen{$community});
<             $communitySeen{$community} = 1;
< 
<             my $results;
<             my $exceptionsUrl = $instance->backgroundExceptionsMonitorURL();
<             my $queueSizeUrl = $instance->documentQueueSizeMonitorURL();
---
> 	my $debug = 0;
> 	my $quiet = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	# tmid:166098
> 	my $invDetailReqFailedDoc = "https://wiki.ariba.com:8443/display/ENGDPTS/How+to+handle+Buyer+CC%3AInvoiceDetailRequest+in+Failed+state";
> 
> 	while(my $arg=shift(@ARGV)){
> 			print STDERR "parsing arg $arg\n" if $debug && !$quiet;
> 			if($arg =~ /^-d/o){ $debug=1; }
> 			if($arg =~ /^-e/o){ $sendEmail=1; };
> 			if($arg =~ /^-p$/o){ $sendPage=1; };
> 			if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 	my $email = $me->default('notify.email');
> 
> 
> 	my @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
> 	unless (@products) {
> 		exit(0);
> 	}
> 
> 	for my $product (@products) {
> 
> 		# about to query, let's grab lock (prodname + path to script)... 
> 		# otherwise move on to the next product
> 		my $lockFile = "/tmp/" . $productName . "-b-b-queue-status";
> 		my $reqTries = 5;
> 		if ( ! dmail::LockLib::requestlock($lockFile, $reqTries) ) {
> 			warn "Can't grab lock $lockFile\n";
> 			next;
> 		}
> 
> 		my $skip = 0;
> 		my %queries  = ();
> 		my %communitySeen = ();
> 
> 		my %badPos = ();
> 		my %missingPos = ();
> 		my $numMissing = 0;
> 		my $numBad = 0;
> 		my $badPosOracleError;
> 		my $missingPosOracleError;
> 		my $badPosOutage;
> 		if (grep { $productName eq $_ } ariba::rc::Globals::sharedServiceBuyerProducts() ) {
> 		
> 			my $oc = ariba::Ops::OracleClient->new($product->connectInfoForOracleClient());
> 			# PO's for which we don't even have a response recorded
> 			# likely never even got to the ASN
> 			getPos(\$oc, \%badPos, \$numBad, 0, \$badPosOracleError);
> 
> 			# PO's which are still sending, but which are probably
> 			# on the ASN
> 			getPos(\$oc, \%missingPos, \$numMissing, 1, $missingPosOracleError);
> 
> 
>         	my $anProductStatus = ariba::monitor::ProductStatus->newWithDetails("an", $product->service(), $product->customer());
> 
> 			if ($anProductStatus->inPlannedDownTime()) {
> 				#my $now = DateTime->now( time_zone => 'local' );
> 				#my ($startHour, $startMinute) = ($now->hour(), $now->minute());
> 				#my $later = $today->add( minutes => 5 ); 
> 				#my ($endHour, $endMinute
> 
> 				$badPosOutage = ariba::monitor::OutageSchedule->new("daily 00:00-23:59");
> 			}
> 					
> 			$queries{"Orders not sent to the ASN in the last 10 days"} = {
> 				'recordMaxResults' => 60000,
> 				'recordDataType' => "gauge",
> 				'info' => 1,
> 				'warn' => "answer > 20",
> 				'crit' => "answer > 100 && previousAnswer > 100",
> 				'error' => $badPosOracleError,
> 				'outageSchedule' => $badPosOutage,
> 				'perl' => sub { return $numBad; }
> 			} ;
> 			$queries{"Orders in sending state with non-4xx responses in the last 10 days"} = {
> 				'recordMaxResults' => 60000,
> 				'recordDataType' => "gauge",
> 				'info' => 1,
> 				'warn' => "answer > 100",
> 				'crit' => "answer > 200",
> 				'error' => $missingPosOracleError,
> 				'outageSchedule' => $badPosOutage,
> 				'perl' => sub { return $numMissing; }
> 			} ;
> 
> 		}
> 
> 		for my $instance ($product->appInstancesInCluster($cluster)) {
> 
> 			my $communityString = "";
> 			my $community = 0;
> 			my $uiHint;
> 
> 			if ($product->isASPProduct()) {
> 				$uiHint = $instance->appName();
> 			} else {
> 				$community = $instance->community();
> 				if ($community) {
> 					$communityString = " in community $community";
> 					$uiHint = "Community $community";
> 				} else {
> 					next;
> 				}
> 			}
> 
> 			next if ($communitySeen{$community});
> 			$communitySeen{$community} = 1;
> 
> 			my $results;
> 			my $exceptionsUrl = $instance->backgroundExceptionsMonitorURL();
> 			my $queueSizeUrl = $instance->documentQueueSizeMonitorURL();
132c143
<             my $exceptions = ariba::monitor::Url->new($exceptionsUrl);
---
> 			my $exceptions = ariba::monitor::Url->new($exceptionsUrl);
134,204c145,199
<             #
<             #16,WARN,realm_1 
<             #2,ERROR,realm_1 
<             #
<             #This is a sliding window query (default 4 hours, use
<                     #a parameter window to change) that returns the number
<             #of warnings and errors that are logged. There should
<             #be a threshold on errors of 0. A warning could happen
<             #if the  #of warnings becomes high (its usually related
<                     #to cXML failures). Right now, there is no resolution.
<             #Errors are exceptions that are unexpected
<             #and would most generally indicate a bug. 
<             #
<             my @exceptionsResults = $exceptions->request(45);
<             $queries{"Errors logged for realms" . $communityString} = {
<                 'uiHint' => $uiHint,
<                 'info' => 1,
<                 'crit' => "numrows > 0",
<                 'perl' => sub { main::typeOfExceptionsLogged(\@exceptionsResults, "Error"); },
<                 inf_field   => 'realms_errors_logged',
<                 inf_default => "none",
<                 inf_tags    => qq(community="$community"),
<                 group_by    => qq(community $community),
<             };
<             $queries{"Warnings logged for realms" . $communityString} = {
<                 'uiHint' => $uiHint,
<                 'info' => 1,
<                 'warn' => "numrows > 5",
<                 'crit' => "numrows > 20",
<                 'perl' => sub { main::typeOfExceptionsLogged(\@exceptionsResults, "Warn"); },
<                 inf_field   => 'realms_warnings_logged',
<                 inf_default => "none",
<                 inf_tags    => qq(community="$community"),
<                 group_by    => qq(community $community),
<             };
< 
<             $queries{"Orders not sent to the ASN in the last 10 days" .  $communityString} = {
<                 'recordMaxResults' => 60000,
<                 'recordDataType' => "gauge",
<                 'recordItem' => 'numrows',
<                 'uiHint' => $uiHint,
<                 'info' => 1,
<                 'warn' => "numrows > 2",
<                 'crit' => "numrows > 10",
<                 'error' => $badPosOracleError,
<                 'outageSchedule' => $badPosOutage,
<                 'perl' => sub { 
<                     return $badPos{$community};
<                 },
<                 inf_field   => 'orders_not_sent_last_10_days',
<                 inf_default => 0,
<                 inf_tags    => qq(community="$community"),
<                 group_by    => qq(community $community),
<             };
< 
<             $queries{"Orders in sending state with non-4xx responses in the last 10 days" .  $communityString} = {
<                 'recordMaxResults' => 60000,
<                 'recordDataType' => "gauge",
<                 'recordItem' => 'numrows',
<                 'uiHint' => $uiHint,
<                 'info' => 1,
<                 'error' => $missingPosOracleError,
<                 'outageSchedule' => $badPosOutage,
<                 'perl' => sub { 
<                     return $missingPos{$community};
<                 },
<                 inf_field   => 'orders_in_sending_state',
<                 inf_default => 0,
<                 inf_tags    => qq(community="$community"),
<                 group_by    => qq(community $community),
<             };
---
> 			#
> 			#16,WARN,realm_1 
> 			#2,ERROR,realm_1 
> 			#
> 			#This is a sliding window query (default 4 hours, use
> 					#a parameter window to change) that returns the number
> 			#of warnings and errors that are logged. There should
> 			#be a threshold on errors of 0. A warning could happen
> 			#if the  #of warnings becomes high (its usually related
> 					#to cXML failures). Right now, there is no resolution.
> 			#Errors are exceptions that are unexpected
> 			#and would most generally indicate a bug. 
> 			#
> 			my @exceptionsResults = $exceptions->request(45);
> 			$queries{"Errors logged for realms" . $communityString} = {
> 				'uiHint' => $uiHint,
> 				'info' => 1,
> 				'crit' => "numrows > 0",
> 				'perl' => sub { main::typeOfExceptionsLogged(\@exceptionsResults, "Error"); },
> 			};
> 			$queries{"Warnings logged for realms" . $communityString} = {
> 				'uiHint' => $uiHint,
> 				'info' => 1,
> 				'warn' => "numrows > 5",
> 				'crit' => "numrows > 20",
> 				'perl' => sub { main::typeOfExceptionsLogged(\@exceptionsResults, "Warn"); },
> 			};
> 
> 			$queries{"Orders not sent to the ASN in the last 10 days" .  $communityString} = {
> 			    'recordMaxResults' => 60000,
> 			    'recordDataType' => "gauge",
> 				'recordItem' => 'numrows',
> 				'uiHint' => $uiHint,
> 				'info' => 1,
> 				'warn' => "numrows > 2",
> 				'crit' => "numrows > 10",
> 				'error' => $badPosOracleError,
> 				'outageSchedule' => $badPosOutage,
> 				'perl' => sub { 
> 					return $badPos{$community};
> 				},
> 			};
> 
> 			$queries{"Orders in sending state with non-4xx responses in the last 10 days" .  $communityString} = {
> 			    'recordMaxResults' => 60000,
> 			    'recordDataType' => "gauge",
> 				'recordItem' => 'numrows',
> 				'uiHint' => $uiHint,
> 				'info' => 1,
> 				'error' => $missingPosOracleError,
> 				'outageSchedule' => $badPosOutage,
> 				'perl' => sub { 
> 					return $missingPos{$community};
> 				},
> 			};
206c201
<             my $queueSize = ariba::monitor::Url->new($queueSizeUrl);
---
> 			my $queueSize = ariba::monitor::Url->new($queueSizeUrl);
209,219c204,214
<             #
<             #realm_1,Queued,InvoiceStatusUpdateRequest,10 
<             #realm_1,Failed,InvoiceStatusUpdateRequest,1 
<             #
<             #Threshold should be on the Failed docs (duno what
<                     #number) and Queued (dunnoeither) When this happens,
<             #the process is the following: 
<             #When queued threshold exceeded, investigate why
<             #the system is slow (possibly nodes unresponsive).
<             #Remedy the problem. It could be high load.  
<             #
---
> 			#
> 			#realm_1,Queued,InvoiceStatusUpdateRequest,10 
> 			#realm_1,Failed,InvoiceStatusUpdateRequest,1 
> 			#
> 			#Threshold should be on the Failed docs (duno what
> 					#number) and Queued (dunnoeither) When this happens,
> 			#the process is the following: 
> 			#When queued threshold exceeded, investigate why
> 			#the system is slow (possibly nodes unresponsive).
> 			#Remedy the problem. It could be high load.  
> 			#
221c216
<             my @queueSizeResults = $queueSize->request(45);
---
> 			my @queueSizeResults = $queueSize->request(45);
237,240d231
<                                 inf_field   => 'cxml_docs_without_invoices',
<                                 inf_default => "none",
<                                 inf_tags    => qq(community="$community"),
<                                 group_by    => qq(community $community),
245,246c236,237
<             # tmid 190047
<             my $surCount = ariba::monitor::Url->new( $instance->contractSURCountURL() );
---
> 			# tmid 190047
> 			my $surCount = ariba::monitor::Url->new( $instance->contractSURCountURL() );
248,249c239,240
<             # tmid 190047
<             my @surCountResults = $surCount->request(45);
---
> 			# tmid 190047
> 			my @surCountResults = $surCount->request(45);
251,333c242,316
<             # tmid 190047
<             # Tally all Sourcing Update Requests for the current community. Sample data:
<             #<xml>
<             #  <realm id="accAcwSg">
<             #    <SourcingUpdateRequest>4</SourcingUpdateRequest>
<             #  </realm>
<             #  <realm id="xxxAcwSg">
<             #    <SourcingUpdateRequest>5</SourcingUpdateRequest>
<             #  </realm>
<             #</xml>
<             my $surCountTotal = 0;
<             for my $line (@surCountResults) {
<                 if ($line =~ /<SourcingUpdateRequest>/i) {
<                     my $value = $line;
<                     $value =~ s/^.*<SourcingUpdateRequest>//;
<                     $value=~ s/<\/SourcingUpdateRequest>.*$//;
<                     $surCountTotal =+ $value;
<                 }
<             }
< 
<             # tmid 190047
<             my $surWarn = 100;
<             my $surCrit = 150;
<             $queries{"Contract Sourcing Update Requests in sending status more than 1 hour" . $communityString} = {
<                 'uiHint' => $uiHint,
<                 'info' => "answer < $surWarn",
<                 'warn' => "answer >= $surWarn",
<                 'crit' => "answer >= $surCrit",
<                 'perl' => sub { 
<                     return $surCountTotal;
<                 },
<                 inf_field   => 'contract_sourcing_update_request_send_status',
<                 inf_default => 0,
<                 inf_tags    => qq(community="$community"),
<                 group_by    => qq(community $community),
<             };
< 
< 
<             my ($queueSizeSummaryHashRef, $queuesArrayRef, $statusArrayRef) = collateQueueSizes(\@queueSizeResults);
< 
<             for my $queue (sort(@$queuesArrayRef)) {
<                 for my $status (sort(@$statusArrayRef)) {
<                     my $crit;
<                     my $warn;
<                     my $note;
< 
<                     if ($status =~ m|failed|i) {
<                         $crit = 150;
<                         $warn = 50;
<                         # tmid:166098
<                         if ($queue =~ m|CC:InvoiceDetailRequest|i) {
<                             $note = "\n<html>See <a href=\"$invDetailReqFailedDoc\">$invDetailReqFailedDoc</a></html>";
<                         }
<                     } elsif ($status =~ m|queued|i) {
<                         $crit = 1000;
<                         $warn = 500;
<                         if ($queue =~ m|InvoiceStatusUpdateRequest|i) {
<                             $crit = 3000;
<                             $warn = 1000;
<                             $note = 'http://ops.ariba.com/documentation/SRE/processes/operational/InvoiceStatusUpdateRequest-queues.txt';
<                         }
<                     }
<                     $queries{"Documents in $queue in $status state" . $communityString} = {
<                         'recordMaxResults' => 60000,
<                         'recordDataType' => "gauge",
<                         'uiHint' => $uiHint,
<                         'info' => 1,
<                         'warn' => "defined(answer) && answer >= $warn",
<                         'crit' => "defined(answer) && answer >= $crit",
<                         'note' => $note,
<                         'perl' => sub { return $queueSizeSummaryHashRef->{$queue}{$status}; },
<                         inf_field   => $queue,
<                         inf_default => 0,
<                         inf_tags    => qq(community="$community",status="$status"),
<                         group_by    => qq(community $community, $status),
<                     };
<                 }
<             }
<         }
<         $queries{influx_details} = {measurement => "buyer_queue_status"};
<         my $q = ariba::monitor::QueryManager->newWithDetails(
<                 "queue-and-exceptions-status", $product->name(), $service, $product->customer(), \%queries
<                 );
---
> 			# tmid 190047
> 			# Tally all Sourcing Update Requests for the current community. Sample data:
> 			#<xml>
> 			#  <realm id="accAcwSg">
> 			#    <SourcingUpdateRequest>4</SourcingUpdateRequest>
> 			#  </realm>
> 			#  <realm id="xxxAcwSg">
> 			#    <SourcingUpdateRequest>5</SourcingUpdateRequest>
> 			#  </realm>
> 			#</xml>
> 			my $surCountTotal = 0;
> 			for my $line (@surCountResults) {
> 				if ($line =~ /<SourcingUpdateRequest>/i) {
> 					my $value = $line;
> 					$value =~ s/^.*<SourcingUpdateRequest>//;
> 					$value=~ s/<\/SourcingUpdateRequest>.*$//;
> 					$surCountTotal =+ $value;
> 				}
> 			}
> 
> 			# tmid 190047
> 			my $surWarn = 100;
> 			my $surCrit = 150;
> 			$queries{"Contract Sourcing Update Requests in sending status more than 1 hour" . $communityString} = {
> 				'uiHint' => $uiHint,
> 				'info' => "answer < $surWarn",
> 				'warn' => "answer >= $surWarn",
> 				'crit' => "answer >= $surCrit",
> 				'perl' => sub { 
> 					return $surCountTotal;
> 				},
> 			};
> 
> 
> 			my ($queueSizeSummaryHashRef, $queuesArrayRef, $statusArrayRef) = collateQueueSizes(\@queueSizeResults);
> 
> 			for my $queue (sort(@$queuesArrayRef)) {
> 				for my $status (sort(@$statusArrayRef)) {
> 					my $crit;
> 					my $warn;
> 					my $note;
> 
> 					if ($status =~ m|failed|i) {
> 						$crit = 150;
> 						$warn = 50;
> 						# tmid:166098
> 						if ($queue =~ m|CC:InvoiceDetailRequest|i) {
> 							$note = "\n<html>See <a href=\"$invDetailReqFailedDoc\">$invDetailReqFailedDoc</a></html>";
> 						}
> 					} elsif ($status =~ m|queued|i) {
> 						$crit = 1000;
> 						$warn = 500;
> 						if ($queue =~ m|InvoiceStatusUpdateRequest|i) {
> 							$crit = 3000;
> 							$warn = 1000;
> 							$note = 'http://ops.ariba.com/documentation/SRE/processes/operational/InvoiceStatusUpdateRequest-queues.txt';
> 						}
> 					}
> 					$queries{"Documents in $queue in $status state" . $communityString} = {
> 						'recordMaxResults' => 60000,
> 						'recordDataType' => "gauge",
> 						'uiHint' => $uiHint,
> 						'info' => 1,
> 						'warn' => "defined(answer) && answer >= $warn",
> 						'crit' => "defined(answer) && answer >= $crit",
> 						'note' => $note,
> 						'perl' => sub { return $queueSizeSummaryHashRef->{$queue}{$status}; },
> 					};
> 				}
> 			}
> 		}
> 
> 		my $q = ariba::monitor::QueryManager->newWithDetails(
> 				"queue-and-exceptions-status", $product->name(), $service, $product->customer(), \%queries
> 				);
335c318
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
337c320,322
<     }
---
> 		dmail::LockLib::releaselock($lockFile);
> 
> 	}
341,342c326,327
<     my $exceptionsArrayRef = shift;
<     my $matchType = shift;
---
> 	my $exceptionsArrayRef = shift;
> 	my $matchType = shift;
344,345c329,330
<     my $numExceptions = 0;
<     my @exceptions = ();
---
> 	my $numExceptions = 0;
> 	my @exceptions = ();
347,361c332,346
<     for my $line (@$exceptionsArrayRef) {
<         #
<         #16,WARN,realm_1 
<         #2,ERROR,realm_1 
<         #
<         my ($num, $type, $realm) = split(/,/, $line);
<         if ($num && $type =~ m|$matchType|i) {
<             $numExceptions += $num;
<             push(@exceptions, "$realm: $num");
<         }
<     }
< 
<     if ($numExceptions) {
<         unshift(@exceptions, "Total $matchType: $numExceptions");
<     }
---
> 	for my $line (@$exceptionsArrayRef) {
> 		#
> 		#16,WARN,realm_1 
> 		#2,ERROR,realm_1 
> 		#
> 		my ($num, $type, $realm) = split(/,/, $line);
> 		if ($num && $type =~ m|$matchType|i) {
> 			$numExceptions += $num;
> 			push(@exceptions, "$realm: $num");
> 		}
> 	}
> 
> 	if ($numExceptions) {
> 		unshift(@exceptions, "Total $matchType: $numExceptions");
> 	}
363c348
<     return(join(";", @exceptions));
---
> 	return(join("\n", @exceptions));
367c352
<     my $queueSizesResultArrayRef = shift;
---
> 	my $queueSizesResultArrayRef = shift;
369,386c354,371
<     my %collatedQueueSizes;
<     my %queues;
<     my %statuses;
< 
<     for my $line (@$queueSizesResultArrayRef) {
<         #
<         #realm_1,Queued,InvoiceStatusUpdateRequest,10 
<         #realm_1,Failed,InvoiceStatusUpdateRequest,1 
<         #
<         my ($realm, $status, $queue, $size) = split(/,/, $line);
< 
<         unless($collatedQueueSizes{$queue}{$status}) {
<             $collatedQueueSizes{$queue}{$status} = 0;
<         }
<         $collatedQueueSizes{$queue}{$status} += $size;
<         $queues{$queue} = 1;
<         $statuses{$status} = 1;
<     }
---
> 	my %collatedQueueSizes;
> 	my %queues;
> 	my %statuses;
> 
> 	for my $line (@$queueSizesResultArrayRef) {
> 		#
> 		#realm_1,Queued,InvoiceStatusUpdateRequest,10 
> 		#realm_1,Failed,InvoiceStatusUpdateRequest,1 
> 		#
> 		my ($realm, $status, $queue, $size) = split(/,/, $line);
> 
> 		unless($collatedQueueSizes{$queue}{$status}) {
> 			$collatedQueueSizes{$queue}{$status} = 0;
> 		}
> 		$collatedQueueSizes{$queue}{$status} += $size;
> 		$queues{$queue} = 1;
> 		$statuses{$status} = 1;
> 	}
388,389c373,374
<     my @queuesArray = keys(%queues);
<     my @statusArray = keys(%statuses);
---
> 	my @queuesArray = keys(%queues);
> 	my @statusArray = keys(%statuses);
391c376
<     return (\%collatedQueueSizes,\@queuesArray,\@statusArray) ;
---
> 	return (\%collatedQueueSizes,\@queuesArray,\@statusArray) ;
395,441c380,426
<     my $oc = shift;
<     my $pos = shift;
<     my $num = shift;
<     my $hasResponse = shift;
<     my $oracleError = shift;
< 
<     my @res = ();
< 
<     my $badPoSql = "SELECT c.communityid, Ord1.or_PartitionNumber, r.name, Ord1.or_FailureReason, Ord1.or_PurchaseOrder, to_char(Ord1.or_TimeUpdated+(SUBSTR(tz_offset(sessiontimezone),1,1)||'1')*to_dsinterval('0 '||SUBSTR(tz_offset(sessiontimezone),2,5)||':00'),'Dy DD-Mon-YYYY HH24:MI:SS'), Pur2.po_orderid, Pur2.po_payloadid
<         FROM OrderRecipientTab Ord1, PurchaseOrderTab Pur2, ApprovableTab App3, CXMLDocumentTab CXM4, realmtab r, communitytab c 
<         WHERE App3.rootId = Pur2.rootId 
<         AND r.id = Ord1.or_PartitionNumber/10 
<         AND c.realmid = r.id 
<         AND Ord1.or_PurchaseOrder = Pur2.rootId 
<         AND Ord1.or_State = 1 
<         AND Ord1.or_OrderingMethod = 'URL' 
<         AND App3.ap_StatusString = 'Ordering' 
<         AND LOWER(Ord1.or_FailureReason) NOT LIKE LOWER('%[4%') 
<         AND CXM4.cdt_EntityReference = Ord1.or_PurchaseOrder 
<         AND CXM4.cdt_DocumentAssociation IS " . 
<         ($hasResponse ? "NOT" : "") . " NULL 
<         AND CAST(SYS_EXTRACT_UTC(systimestamp) AS DATE) - Ord1.or_TimeUpdated < 10
<         AND CAST(SYS_EXTRACT_UTC(systimestamp) AS DATE) - Ord1.or_TimeUpdated > 30/(24.0*60.0)
<         AND (Ord1.or_Active = 1) 
<         AND (Ord1.or_PurgeState = 0) 
<         AND (CXM4.cdt_Active = 1) 
<         AND (CXM4.cdt_PurgeState = 0) 
<         AND (App3.ap_Active = 1) 
<         AND (App3.ap_PurgeState = 0) 
<         AND ROWNUM < 5000 ORDER BY 1,2,3,4";
<     if ($$oc->connect()) {
<         unless($$oc->executeSqlWithTimeout($badPoSql, 240, \@res)) {
<             $$oracleError = $$oc->error();
<         }
<     } else {
<         $$oracleError = $$oc->error();
<     }
<     for my $row (@res) {
<         my ($cid, $part, $name, $failure, $order, $dt, $poid, $payloadid) = split(ariba::Ops::OracleClient->colsep(),$row);
<         my $poStr = "$name $poid since $dt falilure '$failure' (realmid=$part baseid=$order payload=$payloadid)\n";
<         if ($$pos{$cid}) {
<             $$pos{$cid} .= $poStr;
<         } else {
<             $$pos{$cid} = $poStr;
<         }
<         $$num++;
<     }
---
> 	my $oc = shift;
> 	my $pos = shift;
> 	my $num = shift;
> 	my $hasResponse = shift;
> 	my $oracleError = shift;
> 
> 	my @res = ();
> 
> 	my $badPoSql = "SELECT c.communityid, Ord1.or_PartitionNumber, r.name, Ord1.or_FailureReason, Ord1.or_PurchaseOrder, to_char(Ord1.or_TimeUpdated+(SUBSTR(tz_offset(sessiontimezone),1,1)||'1')*to_dsinterval('0 '||SUBSTR(tz_offset(sessiontimezone),2,5)||':00'),'Dy DD-Mon-YYYY HH24:MI:SS'), Pur2.po_orderid, Pur2.po_payloadid
> 		FROM OrderRecipientTab Ord1, PurchaseOrderTab Pur2, ApprovableTab App3, CXMLDocumentTab CXM4, realmtab r, communitytab c 
> 		WHERE App3.rootId = Pur2.rootId 
> 		AND r.id = Ord1.or_PartitionNumber/10 
> 		AND c.realmid = r.id 
> 		AND Ord1.or_PurchaseOrder = Pur2.rootId 
> 		AND Ord1.or_State = 1 
> 		AND Ord1.or_OrderingMethod = 'URL' 
> 		AND App3.ap_StatusString = 'Ordering' 
> 		AND LOWER(Ord1.or_FailureReason) NOT LIKE LOWER('%[4%') 
> 		AND CXM4.cdt_EntityReference = Ord1.or_PurchaseOrder 
> 		AND CXM4.cdt_DocumentAssociation IS " . 
> 		($hasResponse ? "NOT" : "") . " NULL 
> 		AND CAST(SYS_EXTRACT_UTC(systimestamp) AS DATE) - Ord1.or_TimeUpdated < 10
> 		AND CAST(SYS_EXTRACT_UTC(systimestamp) AS DATE) - Ord1.or_TimeUpdated > 30/(24.0*60.0)
> 		AND (Ord1.or_Active = 1) 
> 		AND (Ord1.or_PurgeState = 0) 
> 		AND (CXM4.cdt_Active = 1) 
> 		AND (CXM4.cdt_PurgeState = 0) 
> 		AND (App3.ap_Active = 1) 
> 		AND (App3.ap_PurgeState = 0) 
> 		AND ROWNUM < 5000 ORDER BY 1,2,3,4";
> 	if ($$oc->connect()) {
> 		unless($$oc->executeSqlWithTimeout($badPoSql, 240, \@res)) {
> 			$$oracleError = $$oc->error();
> 		}
> 	} else {
> 		$$oracleError = $$oc->error();
> 	}
> 	for my $row (@res) {
> 		my ($cid, $part, $name, $failure, $order, $dt, $poid, $payloadid) = split(ariba::Ops::OracleClient->colsep(),$row);
> 		my $poStr = "$name $poid since $dt falilure '$failure' (realmid=$part baseid=$order payload=$payloadid)\n";
> 		if ($$pos{$cid}) {
> 			$$pos{$cid} .= $poStr;
> 		} else {
> 			$$pos{$cid} = $poStr;
> 		}
> 		$$num++;
> 	}
444c429
< main()
---
> main();
filename:./bin/buyer/usage-status
2a3
> # $Id: //ariba/services/monitor/bin/buyer/usage-status#4 $
19,21c20,21
< sub usage
< {
<     my $error = shift;
---
> sub usage {
> 	my $error = shift; 
23c23
<     print <<USAGE;
---
> 	print <<USAGE;
25,29c25,29
<     -prod product
<     -e    Enables sending of email for monitor query.
<     -p    Enables sending of pages for monitor query.
<     -d    Turns on debug mode. 
<     -h    Shows this help.
---
> 	-prod product
> 	-e    Enables sending of email for monitor query.
> 	-p    Enables sending of pages for monitor query.
> 	-d    Turns on debug mode. 
> 	-h    Shows this help.
33c33
<     print "(error) $error\n" if ($error);
---
> 	print "(error) $error\n" if ($error);
35c35
<     exit ();
---
> 	exit();
38,141c38,125
< sub main
< {
<     my $sendEmail = 0;
<     my $sendPage  = 0;
<     my $productName;
< 
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p$/o) {$sendPage  = 1; next;}
<         if ($arg =~ /^-prod/o) {$productName = shift (@ARGV);}
<     }
< 
<     my $me      = ariba::rc::InstalledProduct->new();
<     my $service = $me->service();
<     my $cluster = $me->currentCluster();
< 
<     unless (ariba::rc::InstalledProduct->isInstalled($productName, $service))
<     {
<         exit (0);
<     }
< 
<     my $product = ariba::rc::InstalledProduct->new($productName, $service);
< 
<     my %queries;
< 
<     my %communities = ();
<     my %allReqs     = ();
< 
<     for my $instance ($product->appInstancesInCluster($cluster))
<     {
<         my $instanceName = $instance->instanceName();
<         next unless $instance->isTomcatApp();
< 
<         if ($instance->appName() =~ /^TaskCXML/)
<         {
<             my $reqUrl;
<             my $community = $instance->community();
< 
<             unless (exists $communities{$community})
<             {
<                 $communities{$community} = '1';
<                 $reqUrl = $instance->requisitionsRealmURL();
< 
<                 print "checking url:$reqUrl\n" if $debug;
< 
<                 my ($error, $xp) = processUrl($reqUrl);
<                 my $realmStatusSet = $xp->find("//realm") unless $error;
< 
<                 unless ($error)
<                 {
<                     foreach my $node ($realmStatusSet->get_nodelist)
<                     {
<                         my $id = $node->getAttribute('id');
<                         #
<                         # Direct action only returns non-zero results so by default set all values to 0
<                         #
<                         foreach my $s (qw(Approved Composing Submitted))
<                         {
<                             $allReqs{$id}{$s} = 0;
<                         }
<                         my $reqStatusSet = $xp->find("//realm[\@id='" . $id . "']/*") unless $error;
< 
<                         foreach my $s ($reqStatusSet->get_nodelist)
<                         {
<                             my $status = $s->getName;
<                             my $value  = $s->string_value;
<                             $allReqs{$id}{$status} = $value;
<                         }
<                     }
<                 }
<             }
<         }
<     }
< 
<     my $date     = strftime("%Y-%m-%d", localtime ());
<     my $datetime = localtime ();
<     my $logFile  = "/tmp/$service/mon/realms-status-$date.csv";
< 
<     open (LOG, ">", $logFile) || die "Could not open $logFile, $!\n";
< 
<     for my $realm (keys %allReqs)
<     {
<         for my $status (keys %{$allReqs{$realm}})
<         {
<             my $results = $allReqs{$realm}{$status};
<             print LOG "$realm,$status,$results,$datetime\n";
< 
<             $queries{"Requisitions for $realm - $status"} = {
<                                                              recordDataType   => "gauge",
<                                                              recordMaxResults => 500,
<                                                              perl             => sub {return $results;},
<                                                              uiHint           => "Requistions By Realm/$realm",
<                                                              description      => "Requisitions breakup counts by realm",
<                                                              inf_field        => $status,
<                                                              inf_default      => 0,
<                                                              inf_tags         => qq(realm=$realm),
<                                                              group_by         => $realm,
<                                                             };
<         }
<     }
<     close (LOG);
---
> sub main {
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while (my $arg = shift(@ARGV)) {
> 		if ($arg =~ /^-h$/o) { usage();         next; }
> 		if ($arg =~ /^-d$/o) { $debug++;        next; }
> 		if ($arg =~ /^-e$/o) { $sendEmail = 1;  next; }
> 		if ($arg =~ /^-p$/o) { $sendPage = 1;   next; }
> 		if ($arg =~ /^-prod/o) { $productName  = shift(@ARGV); }
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $service = $me->service();
> 	my $cluster = $me->currentCluster();
> 
> 	unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
> 		exit(0);
> 	}
> 
> 	my $product = ariba::rc::InstalledProduct->new($productName, $service);
> 
> 	my %queries;
> 
> 	my %communities = ();
> 	my %allReqs = ();
> 
> 	for my $instance ($product->appInstancesInCluster($cluster)) {
> 		my $instanceName = $instance->instanceName();
> 		next unless $instance->isTomcatApp();
> 
> 		if ($instance->appName() =~ /^TaskCXML/) {
> 			my $reqUrl;
> 			my $community = $instance->community();
> 
> 			unless (exists $communities{$community}) {
> 				$communities{$community} = '1';
> 				$reqUrl = $instance->requisitionsRealmURL();
> 
> 				print "checking url:$reqUrl\n" if $debug;
> 
> 				my ($error, $xp) = processUrl($reqUrl);
> 				my $realmStatusSet = $xp->find("//realm") unless $error;
> 
> 				unless ($error) {
> 					foreach my $node ($realmStatusSet->get_nodelist) {
> 						my $id =  $node->getAttribute('id');
> 						#
> 						# Direct action only returns non-zero results so by default set all values to 0
> 						#
> 						foreach my $s (qw(Approved Composing Submitted)) {
> 							$allReqs{$id}{$s} = 0;
> 						}
> 						my $reqStatusSet = $xp->find("//realm[\@id='".$id."']/*") unless $error;
> 
> 						foreach my $s ($reqStatusSet->get_nodelist) {
> 							my $status = $s->getName;
> 							my $value = $s->string_value;
> 							$allReqs{$id}{$status} = $value;
> 						}
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	my $date = strftime("%Y-%m-%d", localtime());
> 	my $datetime = localtime();
> 	my $logFile = "/tmp/$service/mon/realms-status-$date.csv";
> 
> 	open(LOG, ">", $logFile) || die "Could not open $logFile, $!\n";
> 
> 	for my $realm ( keys %allReqs ) {
> 		for my $status( keys %{ $allReqs{$realm} } ) {
> 			my $results = $allReqs{$realm}{$status};
> 			print LOG "$realm,$status,$results,$datetime\n";
> 
> 			$queries{"Requisitions for $realm - $status"} = {
> 				recordDataType => "gauge",
> 				recordMaxResults => 500,
> 				perl    => sub { return $results; },
> 				uiHint  => "Requistions By Realm/$realm",
> 				description => "Requisitions breakup counts by realm",
> 			};
> 		}
> 	}
> 	close(LOG);
143,144c127
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = {measurement => "buyer_usage_status"};
---
> 	my $email = $me->default('notify.email');
146,147c129,130
<     my $qm = ariba::monitor::QueryManager->newWithDetails("usage-status", $product->name(), $service, $product->customer(), \%queries);
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	my $qm = ariba::monitor::QueryManager->newWithDetails("usage-status", $product->name(), $service, $product->customer(), \%queries);
> 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
153,167c136,150
< #   <realm id="p2pTeSg-28">
< #       <Composing>16</Composing>
< #       <Submitted>4</Submitted>
< #       <Approved>16</Approved>
< #   </realm>
< #   <realm id="p2pTeSg-19">
< #       <Submitted>4</Submitted>
< #       <Approved>2</Approved>
< #   </realm>
< #   <realm id="p2pTeOra">
< #       <Approved>2</Approved>
< #   </realm>
< #   <realm id="apcAippSg">
< #       <Composing>4</Composing>
< #   </realm>
---
> #	<realm id="p2pTeSg-28">
> #		<Composing>16</Composing>
> #		<Submitted>4</Submitted>
> #		<Approved>16</Approved>
> #	</realm>
> #	<realm id="p2pTeSg-19">
> #		<Submitted>4</Submitted>
> #		<Approved>2</Approved>
> #	</realm>
> #	<realm id="p2pTeOra">
> #		<Approved>2</Approved>
> #	</realm>
> #	<realm id="apcAippSg">
> #		<Composing>4</Composing>
> #	</realm>
170,201c153,156
< sub processUrl
< {
<     my $thisReqUrl = shift;
<     my $xp;
<     my $eMessage;
< 
<     my $requisitionStatus = ariba::monitor::Url->new($thisReqUrl);
<     $requisitionStatus->setUseOutOfBandErrors(1);
< 
<     if (defined $requisitionStatus->error())
<     {
<         $eMessage = "ERROR: $requisitionStatus->error()\n";
< 
<         return ($eMessage, $xp);
<     }
< 
<     my $xmlString = $requisitionStatus->request();
<     $xp = XML::XPath->new(xml => $xmlString);
< 
<     eval {
<         my $parseThis = new XML::Parser;
<         $parseThis->parse($xmlString);
<     };
< 
<     if ($@)
<     {
<         $eMessage = "ERROR: XML Parsing failed\n";
<     }
<     else
<     {
<         $eMessage = "ERROR: Invalid xml data as realm is missing: $xmlString\n" unless ($xmlString =~ m/realm/);
<     }
---
> sub processUrl {
> 	my $thisReqUrl = shift;
> 	my $xp;
> 	my $eMessage;
203c158,159
<     print "$eMessage\n" if $debug && $eMessage;
---
> 	my $requisitionStatus = ariba::monitor::Url->new($thisReqUrl);
> 	$requisitionStatus->setUseOutOfBandErrors(1);
205c161,183
<     return ($eMessage, $xp);
---
> 	if (defined $requisitionStatus->error()) {
> 		$eMessage = "ERROR: $requisitionStatus->error()\n";
> 
> 		return ($eMessage, $xp);
> 	} 
> 
> 	my $xmlString = $requisitionStatus->request();
> 	$xp = XML::XPath->new(xml => $xmlString);
> 
> 	eval {
> 		my $parseThis = new XML::Parser;
> 		$parseThis->parse($xmlString);
> 	};
> 
> 	if ($@) {
> 		$eMessage = "ERROR: XML Parsing failed\n";
> 	} else {
> 		$eMessage = "ERROR: Invalid xml data as realm is missing: $xmlString\n"  unless ($xmlString =~ m/realm/);
> 	}
> 
> 	print "$eMessage\n" if $debug && $eMessage;
> 
> 	return ($eMessage, $xp);
211d188
< 
filename:./bin/common/3par-status
95a96
>           
97c98
<             $queries{"$inservHostname: Free Space on Fibre Channel Storage in $unit"} = {  
---
>             $queries{"$inservHostname: Free Space on Fibre Channel Storage in $unit"} = {
105,108d105
<                 inf_field => "GBFreeSpaceOnFibreChannelStorage",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
125,128d121
<                 inf_field => "GBFreeSpaceOnNearLineStorage",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0,
151,154d143
<                 inf_field => "TBFCTotalRawSpace",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0,
104,108c105
<                 inf_field => "GBFreeSpaceOnFibreChannelStorage",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
123,127c121
<                 inf_field => "GBFreeSpaceOnNearLineStorage",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0,
138,141d131
<                 inf_field => "GBFreeSpaceOnFibreChannelStorage",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0,
150,153c140
<                 inf_field => "TBFCUsedRawSpace",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
162,165d148
<                 inf_field => "TBFCSpareSpace",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
174,177d156
<                 inf_field => "TBNLTotalRawSpace",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
186,189d164
<                 inf_field => "TBNLUsedRawSpace",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
198,201d172
<                 inf_field => "TBNLSpareSpace",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
217,220d187
<                 inf_field => "NLDriveRate",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
236,239d202
<                 inf_field => "FCDriveRate",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0
253c216
<                 uiHint => "$inservHostname/Policies-$interestingPolicyType",
---
>                 uiHint => "$inservHostname/Policies",
261,262c224
<                     #return join("\n", sort { $a cmp $b } @vvs);
<                     return  scalar(@vvs);
---
>                     return join("\n", sort { $a cmp $b } @vvs);
265,268d226
<                 inf_field => "VVsWithPolicyType",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname,policies=$interestingPolicyType",
<                 group_by  => "$datacenter,$inservHostname:Policies:$interestingPolicyType",
<                 inf_default => 0,
285,288d242
<                     inf_field => "SDAutoGrowLimit",
<                     inf_tags  => "datacenter=$datacenter,hostname=$inservHostname,cpg_name=$cpgName",
<                     group_by  => "$datacenter,$inservHostname,$cpgName",
<                     inf_default => 0,
297,300d250
<                     inf_field => "SDAutoGrowSize",
<                     inf_tags  => "datacenter=$datacenter,hostname=$inservHostname,cpg_name=$cpgName",
<                     group_by  => "$datacenter,$inservHostname,$cpgName",
<                     inf_default => 0,
321,324d270
<                     inf_field => "SDSpaceUsed",
<                     inf_tags  => "datacenter=$datacenter,hostname=$inservHostname,cpg_name=$cpgName",
<                     group_by  => "$datacenter,$inservHostnam,$cpgName",
<                     inf_default => 0
350,353d295
<                     inf_field => "SDAutoGrowStatus",
<                     inf_tags  => "datacenter=$datacenter,hostame=$inservHostname,cpg_name=$cpgName",
<                     group_by  => "$datacenter,$inservHostname,$cpgName",
<                     inf_default => 0
369,375c311,312
<                         #return join("\n", @results);
<                         return scalar(@results);
<                     },
<                     inf_field => "VVsAssociatedWithCpg",
<                     inf_tags  => "datacenter=$datacenter,hostname=$inservHostname,cpg_name=$cpgName",
<                     group_by  => "$datacenter,$inservHostname,$cpgName",
<                     inf_default => 0
---
>                         return join("\n", @results);
>                     }
447c384,385
<                         if ($event->message() =~ /disk has an unsupported drive type/) {
---
>             #HOA-125797 added 'Slow disk' as crit
>             if ($event->message() =~ /disk has an unsupported drive type/ || $event->message() =~ /Slow disk/ ) {
481a420
>             #      or for "Major.*SQLite DB error.*INSERT INTO hires.vvspace" to skip only INSERTS into the 'hires.vvspace' table.
483c422
<             if (join (' ', @displayEvents) !~ /MAJOR.*SQLite error.*INSERT INTO hires.vvspace/)
---
>             if (join (' ', @displayEvents) !~ /MAJOR.*SQLite.*error.*INSERT INTO hires.vvspace/)
491,496c430
<                     #perl => sub { return join("\n", @displayEvents); },
<                     perl => sub { return scalar(@displayEvents); },
<                     inf_field => "EventLogLevel",
<                     inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                     group_by  => "$datacenter,$inservHostname",
<                     inf_default => 0
---
>                     perl => sub { return join("\n", @displayEvents); },
614,618c548
<                 perl => sub { return $alertLevel; },
<                 inf_field => "alertLevel",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 inf_default => 0,
<                 group_by  => "$datacenter,$inservHostname",
---
>                 perl => sub { return join("\n", @displayAlerts); },
652,657c582
<                 #perl => sub { return join("\n", @badPorts); },
<                 perl => sub { return scalar(@badPorts); },
<                 inf_field => "invalidPortPersonasCount",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0,
---
>                 perl => sub { return join("\n", @badPorts); },
660,661d584
< 			my @diff_arr = main::wwnsDiffForInserv($nm);
< 
668,673c591
<                 #perl => sub { main::wwnsDiffForInserv($nm); },
<                 perl => sub { scalar @diff_arr ? ($diff_arr[0] =~ tr/\n//) + 1 : 0; },
<                 inf_field => "wwnsDiffvsMachineDb",
<                 inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                 group_by  => "$datacenter,$inservHostname",
<                 inf_default => 0,
---
>                 perl => sub { main::wwnsDiffForInserv($nm); },
682,684c591
<             my $actualwwnsvalues = defined $diff_arr[0] ? $diff_arr[0] : "NA";
<             $actualwwnsvalues =~ s/\n- /,/g;
<             $queries{"$inservHostname: wwns diff vs machinedb actual vals"} = {
<                  uiHint => $inservHostname,
<                  perl => sub { return $actualwwnsvalues; },
<                  inf_field => "wwnsDiffvsMachineDbActualVals",
<                  inf_tags  => "datacenter=$datacenter,hostname=$inservHostname",
<                  group_by  => "$datacenter,$inservHostname",
<                  inf_default => "NA",
<              };
679d596
< 		$queries{"influx_details"} = { 'measurement' => "3par_status"};
681c598
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/an-on-hana
15a16,29
> #use the ToolsX Time::ParseDate module because it's super flexible in taking time inputs
> use lib '/usr/local/tools/lib/perl5/site_perl/5.20.1';
> use Time::ParseDate;
> use POSIX qw(strftime);
> #We have to get rid of the ToolsX paths that we set in @INC so that
> #the Hana modules will work
> #use lib ... ends up putting more than one entry into @INC, including
> #an architecture specific path
> BEGIN {
>     while($INC[0] =~ m|/usr/local/tools/lib/perl5/site_perl/5.20.1|) {
>         shift @INC;
>     }
> }
> 
20,23c34,36
<     ticketSleepTime => 20,
< 
<     #    ticketSleepTime => 2, #testing value, so I don't have to wait around
<     globalTimeout    => 50,
---
>     ticketSleepTime => 20, 
> #    ticketSleepTime => 2, #testing value, so I don't have to wait around
>     globalTimeout => 50,
25,26c38,39
<     productName      => 'an',
<                     };
---
>     productName => 'an',
> };
30,35c43,48
<                    queryNameTemplate => 'Self Check',
<                    queryOverrides    => {
<                                       severity => 0,
<                                       uiHint   => 'Self Check',
<                                      }
<                   },
---
>         queryNameTemplate => 'Self Check',
>         queryOverrides => {
>             severity => 0,
>             uiHint => 'Self Check',
>         }
>     },
37,42c50,55
<                   infoRegex         => qr/\s+replicating\s+/is,
<                   queryNameTemplate => '$args{instanceName}\@$args{hostname} - RA Status',
<                   queryOverrides    => {
<                                      uiHint => 'Rep Agent Status',
<                                     }
<                  },
---
>         infoRegex => qr/\s+replicating\s+/is,
>         queryNameTemplate => '$args{instanceName}\@$args{hostname} - RA Status',
>         queryOverrides => {
>             uiHint => 'Rep Agent Status',
>         }
>     },
44,56c57,69
<                       infoRegex         => qr/\nsuccessful\n/is,
<                       queryNameTemplate => '$args{instanceName}\@$args{hostname} - Submit Ticket',
<                       queryOverrides    => {
<                                          uiHint => 'Rep Agent Submit Ticket',
<                                         }
<                      },
<     license_monitoring => {
<                            infoRegex         => qr/\nsuccessful\n/is,
<                            queryNameTemplate => '$args{hostname} ',
<                            queryOverrides    => {
<                                               uiHint => 'Rep Server License Monitoring',
<                                              }
<                           },
---
>         infoRegex => qr/\nsuccessful\n/is,
>         queryNameTemplate => '$args{instanceName}\@$args{hostname} - Submit Ticket',
>         queryOverrides => {
>             uiHint => 'Rep Agent Submit Ticket',
>         }
>     },
>    license_monitoring => {
>         infoRegex => qr/\nsuccessful\n/is,
>         queryNameTemplate => '$args{hostname} ',
>         queryOverrides => {
>             uiHint => 'Rep Server License Monitoring',
>         }
>     },
58,63c71,76
<                    infoRegex         => qr/--------------------/s,
<                    queryNameTemplate => '$args{instanceName}\@$args{hostname} - Disk Space',
<                    queryOverrides    => {
<                                       uiHint => 'Rep Server Disk Space',
<                                      }
<                   },
---
>         infoRegex => qr/--------------------/s,
>         queryNameTemplate => '$args{instanceName}\@$args{hostname} - Disk Space',
>         queryOverrides => {
>             uiHint => 'Rep Server Disk Space',
>         }
>     },
65,68c78,81
<         infoRegex            => qr/--------------------/s,
<         forbiddenStringField => 'dsiname',                                #the value of the 'dsiname' field must also NOT exist in the return string for us to be at info
<         queryNameTemplate    => '$args{instanceName}\@$args{hostname}',
<         CritRegex            => 'PROD_S3LIVETX',                          ##Constant for all AN Replication
---
>         infoRegex => qr/--------------------/s,
>         forbiddenStringField => 'dsiname', #the value of the 'dsiname' field must also NOT exist in the return string for us to be at info
>         queryNameTemplate => '$args{instanceName}\@$args{hostname}',
>         CritRegex => 'PROD_S3LIVETX',   ##Constant for all AN Replication
70,72c83,85
<                            uiHint => 'Rep Server Who Is Down',
<                           }
<                    },
---
>             uiHint => 'Rep Server Who Is Down',
>         }
>     },
74,84c87,97
<                         queryNameTemplate => '$args{instanceName}\@$args{hostname} - Memory',
<                         warnThreshold     => 26,
<                         critThreshold     => 30,
<                         queryOverrides    => {
<                                            uiHint            => 'Rep Agent Memory',
<                                            correctiveActions => [ Ops => 'Create Ops Ticket for Warn/Crit Assign it to DBA', ],
<                                            description => 'Rep Agent Memory for $args{hostname}',
<                                            inf_field   => "memory",
<                                            inf_default => 0,
<                                           }
<                        },
---
>         queryNameTemplate => '$args{instanceName}\@$args{hostname} - Memory',
> 	warnThreshold => 26,
> 	critThreshold => 30,
>         queryOverrides => {
>             uiHint => 'Rep Agent Memory',
>             correctiveActions => [
>                 Ops => 'Create Ops Ticket for Warn/Crit Assign it to DBA',
>             ],
>             description => 'Rep Agent Memory for $args{hostname}',
>         }
>     },
86,92c99,107
<                         queryNameTemplate => '$args{instanceName}\@$args{hostname} - Error',
<                         queryOverrides    => {
<                                            uiHint            => 'Rep Agent Error',
<                                            correctiveActions => [ Ops => 'Create Ops Ticket for Warn/Crit Assign it to DBA', ],
<                                            description => 'Rep Agent Error for $args{hostname}',
<                                           }
<                        },
---
>         queryNameTemplate => '$args{instanceName}\@$args{hostname} - Error',
>         queryOverrides => {
>             uiHint => 'Rep Agent Error',
>             correctiveActions => [
>                 Ops => 'Create Ops Ticket for Warn/Crit Assign it to DBA',
>             ],
>             description => 'Rep Agent Error for $args{hostname}',
>         }
>     },
94,96c109,111
<         requiredField     => 'cnt',                                                  #basic sanity check; make sure the SQL returns something in the 'cnt' field
<         warnLatency       => 100,                                                    #how many min of latency gives us a warning,
<         critLatency       => 240,                                                    #how many min of latency gives us a crit,
---
>         requiredField => 'cnt', #basic sanity check; make sure the SQL returns something in the 'cnt' field
>         warnLatency => 100, #how many min of latency gives us a warning,
>         critLatency => 240, #how many min of latency gives us a crit,
98,102c113,117
<         queryOverrides    => {
<                            severity => 0,
<                            uiHint   => 'Rep Server Ticket Status',
<                           }
<                      }
---
>         queryOverrides => {
>             severity => 0,
>             uiHint => 'Rep Server Ticket Status',
>         }
>     }
107,108c122
< sub usage
< {
---
> sub usage {
126c140
<     exit ();
---
>     exit();
132,134c146
< 
< sub main
< {
---
> sub main {
136c148
<     my $sendPage  = 0;
---
>     my $sendPage = 0;
139,145c151,156
<     while (my $arg = shift @programArgs)
<     {
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o) {$sendEmail = 1;                  next;}
<         if ($arg =~ /^-p$/o) {$sendPage  = 1;                  next;}
<         if ($arg =~ /^-s$/o) {$service   = shift @programArgs; next;}
---
>     while (my $arg = shift @programArgs) {
>         if ($arg =~ /^-h$/o) { usage();         next; }
>         if ($arg =~ /^-d$/o) { $debug++;        next; }
>         if ($arg =~ /^-e$/o) { $sendEmail = 1;  next; }
>         if ($arg =~ /^-p$/o) { $sendPage = 1;   next; }
>         if ($arg =~ /^-s$/o) { $service = shift @programArgs;   next; }
149,150c160
<     if ($< != 0)
<     {
---
>     if($< != 0) {
153c163
<     my $productName   = $staticConfigs->{productName};
---
>     my $productName = $staticConfigs->{productName};
159c169
<         local $SIG{ALRM} = sub {die "timed out\n";};
---
>         local $SIG{ALRM} = sub { die "timed out\n"; };
162c172
<         my @ret      = ();
---
>         my @ret = ();
164c174
<           or die "failed to find localhostname via ariba::Ops::NetworkUtils::hostname()";
---
>             or die "failed to find localhostname via ariba::Ops::NetworkUtils::hostname()";
168,171c178,184
<           unless $me->{configDir};
<         my $cluster = $me->currentCluster() or die "failed to \$me->currentCluster()";
<         my @monhosts = $me->hostsForRoleInCluster('monitor', $cluster) or die 'failed to find any monhosts';
<         die "Error reading mon host for $service ...\n" unless (scalar @monhosts);
---
>             unless $me->{configDir};
>         my $cluster = $me->currentCluster()
>             or die "failed to \$me->currentCluster()";
>         my @monhosts = $me->hostsForRoleInCluster('monitor', $cluster)
>             or die 'failed to find any monhosts';
>         die "Error reading mon host for $service ...\n"
>             unless (scalar @monhosts);
175c188,193
<         die "failed to ariba::rc::InstalledProduct->new('mon', \$service) on $hostname where \$service=$service" unless $mon->{configDir};
---
>         die "failed to ariba::rc::InstalledProduct->new('mon', \$service) on $hostname where \$service=$service"
>             unless $mon->{configDir};
> 
> #        $service = 'lq111';  ##testing
> #        my $cipherStore = ariba::rc::CipherStore->new($service)
> #            or die "failed to ariba::rc::CipherStore->new($service)";
177c195,197
<         my $hanaCredentials = eval {return getHanaCredentials($me);};
---
>         my $hanaCredentials = eval {
>             return getHanaCredentials($me);
>         };
180c200,202
<         my $allDSIConnections = eval {return getAllDSIConnections($me);};
---
>         my $allDSIConnections = eval {
>             return getAllDSIConnections($me);
>         };
183c205,207
<         my $allAgents = eval {return getAllSRSAgents($me);};
---
>         my $allAgents = eval {
>             return getAllSRSAgents($me);
>         };
186c210,212
<         my $allServers = eval {return getAllSRSServers($me);};
---
>         my $allServers = eval {
>             return getAllSRSServers($me);
>         };
189,190c215
<         if ($allAgents)
<         {
---
>         if($allAgents) {
192c217,219
<             push @ret, eval {return submitTickets($allAgents);};
---
>             push @ret, eval {
>                 return submitTickets($allAgents);
>             };
197,198c224
<         if ($allAgents)
<         {
---
>         if($allAgents) {
200c226,228
<             push @ret, eval {return all_ra_status($allAgents);};
---
>             push @ret, eval {
>                 return all_ra_status($allAgents);
>             };
204,205c232
<         if ($allServers)
<         {
---
>         if($allServers) {
207c234,236
<             push @ret, eval {return all_who_is_down($allServers, $service);};
---
>             push @ret, eval {
>                 return all_who_is_down($allServers, $service);
>             };
210,211c239
<         if ($allServers)
<         {
---
>         if($allServers) {
213c241,243
<             push @ret, eval {return all_disk_space($allServers);};
---
>             push @ret, eval {
>                 return all_disk_space($allServers);
>             };
216,217c246
<         if ($allServers)
<         {
---
>         if($allServers) {
219c248,250
<             push @ret, eval {return all_license_monitoring($allServers, $service, $hostname);};
---
>             push @ret, eval {
>                 return all_license_monitoring($allServers, $service, $hostname);
>             };
224,225c255
<         if (time - $ticketsSubmittedAt < $staticConfigs->{ticketSleepTime})
<         {
---
>         if(time - $ticketsSubmittedAt < $staticConfigs->{ticketSleepTime}) {
230,231c260
<         if ($allServers and $hanaCredentials)
<         {
---
>         if($allServers and $hanaCredentials) {
233c262,264
<             push @ret, eval {return get_rs_tickets($allServers, $hanaCredentials, $allDSIConnections);};
---
>             push @ret, eval {
>                 return get_rs_tickets($allServers, $hanaCredentials, $allDSIConnections);
>             };
242a274
> 
244,250c276,279
<     {
<         my $checkStatus = 'STATUS-info';
<         my $answers     = '';
<         if (scalar @checkWarnings)
<         {
<             foreach my $warning (@checkWarnings)
<             {
---
>     {   my $checkStatus = 'STATUS-info';
>         my $answers = '';
>         if(scalar @checkWarnings) {
>             foreach my $warning (@checkWarnings) {
256,259c285,286
<         if (scalar @checkFatals)
<         {
<             foreach my $fatal (@checkFatals)
<             {
---
>         if(scalar @checkFatals) {
>             foreach my $fatal (@checkFatals) {
265,266c292
<         push @allResults,
<           {
---
>         push @allResults, {
268,269c294,295
<             answer    => "$answers $checkStatus",
<           };
---
>             answer => "$answers $checkStatus",
>         };
272d297
< 
275,286c300,310
<                       crit              => 'answer =~ /STATUS-crit$/',
<                       warn              => 'answer =~ /STATUS-warn$/',
<                       info              => 'answer =~ /STATUS-info$/',
<                       ticketOwner       => 'unassigned-sre',
<                       severity          => 1,
<                       description       => 'undefined',
<                       correctiveActions => [Ops => 'undefined'],
<                       uiHint            => 'undefined',
<                      };
< 
<     foreach my $result (@allResults)
<     {
---
>         crit => 'answer =~ /STATUS-crit$/',
>         warn => 'answer =~ /STATUS-warn$/',
>         info => 'answer =~ /STATUS-info$/',
>         ticketOwner => 'unassigned-sre',
>         severity => 1,
>         description => 'undefined',
>         correctiveActions => [ Ops => 'undefined' ],
>         uiHint => 'undefined',
>     };
>         
>     foreach my $result (@allResults) {
292,295c316,317
<         if ($config->{queryOverrides})
<         {
<             while (my ($key, $value) = each %{$config->{queryOverrides}})
<             {
---
>         if($config->{queryOverrides}) {
>             while(my($key, $value) = each %{$config->{queryOverrides}}) {
299,301c321,324
<         my $queryName = eval {return _resolveTemplate($template, $result);};
<         if ($@)
<         {
---
>         my $queryName = eval {
>             return _resolveTemplate($template, $result);
>         };
>         if($@) {
306,308c329
<         $query->{perl} = sub {return "$answer";};
<         $query->{inf_tags} = qq(uiHint="$query->{uiHint}",host="$queryName"); 
<         $query->{group_by} = qq($query->{uiHint},$queryName);
---
>         $query->{perl} = sub { return "$answer"; };
313,317c334,341
<     $queries{influx_details} = {measurement => 'an_srs_status'};
<     my $qm = ariba::monitor::QueryManager->newWithDetails($staticConfigs->{queryManagerName}, $me->name(), $me->service(), $me->customer(), \%queries);
<     myInfo "beginning processQueries \$monhost = $monhost \$sendPage = $sendPage \$sendEmail = $sendEmail \$debug = $debug  \$staticConfigs->{queryManagerName} = $staticConfigs->{queryManagerName} \$me->name() = ", $me->name(), " \$me->service() = ", $me->service(), "\$me->customer() = ",
<       $me->customer();
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage, $monhost);
---
>     my $qm = ariba::monitor::QueryManager->newWithDetails(
>         $staticConfigs->{queryManagerName},
>         $me->name(),
>         $me->service(),
>         $me->customer(),
>         \%queries);
>     myInfo "beginning processQueriesUsingServer  \$monhost = $monhost \$sendPage = $sendPage \$sendEmail = $sendEmail \$debug = $debug  \$staticConfigs->{queryManagerName} = $staticConfigs->{queryManagerName} \$me->name() = ",$me->name(), " \$me->service() = ", $me->service(), "\$me->customer() = ",$me->customer();
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage, $monhost);
319,321c343
< 
< sub _dumpResults
< {
---
> sub _dumpResults {
323,325c345,346
<     my @out     = ();
<     while (my ($queryName, $query) = each %$queries)
<     {
---
>     my @out = ();
>     while(my($queryName, $query) = each %$queries) {
328c349
<         push @out, "Srs Status -> $uiHint -> $queryName -> $answer\n";
---
>         push @out,"Srs Status -> $uiHint -> $queryName -> $answer\n";
331c352
<     open my $fh, '>', '/tmp/stratus-an-on-hana.dump';
---
>     open my $fh, '>', '/tmp/an-on-hana.dump';
334,335c355
<     foreach my $line (@out)
<     {
---
>     foreach my $line (@out) {
343,344c363
< sub getHanaCredentials
< {
---
> sub getHanaCredentials {
347,355c366,374
<                supplier => {
<                             hostname => $me->default('HANADBs.DBSupplier.hostname'),
<                             password => $me->default('HANADBs.DBSupplier.password'),
<                            },
<                directory => {
<                              hostname => $me->default('HANADBs.DBDirectory.hostname'),
<                              password => $me->default('HANADBs.DBDirectory.password'),
<                             }
<               };
---
>         supplier => {
>             hostname => $me->default('HANADBs.DBSupplier.hostname'),
>             password => $me->default('HANADBs.DBSupplier.password'),
>         },
>         directory => {
>             hostname => $me->default('HANADBs.DBDirectory.hostname'),
>             password => $me->default('HANADBs.DBDirectory.password'),
>         }
>     };
358c377
<           if not $ret->{supplier}->{hostname};
---
>             if not $ret->{supplier}->{hostname};
360c379
<           if not $ret->{supplier}->{password};
---
>             if not $ret->{supplier}->{password};
362c381
<           if not $ret->{directory}->{hostname};
---
>             if not $ret->{directory}->{hostname};
364c383
<           if not $ret->{directory}->{password};
---
>             if not $ret->{directory}->{password};
366,367c385
<     if (my $err = $@)
<     {
---
>     if(my $err = $@) {
375,376c393
< sub getAllDSIConnections
< {
---
> sub getAllDSIConnections {
380,386c397,401
<     my $savedServerPass;
<     foreach my $baseName ('SRSServer-Dir', 'SRSServer-Sup')
<     {
<         foreach my $postfix ('', 1 .. 100)
<         {
<             my $serverName  = $baseName . $postfix;
<             my $serverPass  = $me->default("lumira.monitoring.dsiconnections.$serverName.password");
---
>     my $savedServerPass;   
>     foreach my $baseName ('SRSServer-Dir','SRSServer-Sup') {
>         foreach my $postfix ('', 1..100) {
>             my $serverName = $baseName . $postfix;
>             my $serverPass = $me->default("lumira.monitoring.dsiconnections.$serverName.password");
389,390c404,405
<             next unless $dsiusername;
< 
---
>             next unless $dsiusername; 
>             
392,399c407,414
<                                    instanceName   => $me->default("lumira.monitoring.dsiconnections.$serverName.instanceName"),
<                                    targetUserName => $me->default("lumira.monitoring.dsiconnections.$serverName.targetusername"),
<                                    srshostname    => $me->default("lumira.monitoring.dsiconnections.$serverName.srshostname"),
<                                    dsiname        => $me->default("lumira.monitoring.dsiconnections.$serverName.dsiname"),
<                                    dsiUserName    => $me->default("lumira.monitoring.dsiconnections.$serverName.dsiusername"),
<                                    dsiUserPass    => $savedServerPass,
<                                   };
< 
---
>                 instanceName => $me->default("lumira.monitoring.dsiconnections.$serverName.instanceName"),
>                 targetUserName => $me->default("lumira.monitoring.dsiconnections.$serverName.targetusername"),
>                 srshostname => $me->default("lumira.monitoring.dsiconnections.$serverName.srshostname"),
>                 dsiname => $me->default("lumira.monitoring.dsiconnections.$serverName.dsiname"),
>                 dsiUserName => $me->default("lumira.monitoring.dsiconnections.$serverName.dsiusername"),
>                 dsiUserPass => $savedServerPass,
>             };
>            
405,409c420,422
< 
< sub getAllSRSServers
< {
<     my $me         = shift;
<     my $hostname   = ariba::Ops::NetworkUtils::hostname();
---
> sub getAllSRSServers {
>     my $me = shift;
>     my $hostname = ariba::Ops::NetworkUtils::hostname();
412,415c425,426
<     foreach my $baseName ('SRSServer-Dir', 'SRSServer-Sup')
<     {
<         foreach my $postfix ('', 1 .. 100)
<         {
---
>     foreach my $baseName ('SRSServer-Dir','SRSServer-Sup') {
>         foreach my $postfix ('', 1..100) {
420,427c431,438
<                        serverName     => $serverName,
<                        serverType     => $me->default("lumira.monitoring.srsservers.$serverName.type"),
<                        instanceName   => $me->default("lumira.monitoring.srsservers.$serverName.instanceName"),
<                        targetUserName => $me->default("lumira.monitoring.srsservers.$serverName.targetusername"),
<                        srshostname    => $me->default("lumira.monitoring.srsservers.$serverName.srshostname"),
<                        dsiname        => $me->default("lumira.monitoring.srsservers.$serverName.dsiname"),
<                        dsiusername    => $me->default("lumira.monitoring.srsservers.$serverName.dsiusername"),
<                       };
---
>                 serverName => $serverName,
>                 serverType => $me->default("lumira.monitoring.srsservers.$serverName.type"),
>                 instanceName => $me->default("lumira.monitoring.srsservers.$serverName.instanceName"),
>                 targetUserName => $me->default("lumira.monitoring.srsservers.$serverName.targetusername"),
>                 srshostname => $me->default("lumira.monitoring.srsservers.$serverName.srshostname"),
>                 dsiname => $me->default("lumira.monitoring.srsservers.$serverName.dsiname"),
>                 dsiusername => $me->default("lumira.monitoring.srsservers.$serverName.dsiusername"),
>             };
429,430c440,446
<             foreach my $fieldNameRec (['serverType' => 'type'], ['instanceName' => 'instanceName'], ['targetUserName' => 'targetusername'], ['srshostname' => 'srshostname'], ['dsiname' => 'dsiname'], ['dsiusername' => 'dsiusername'])
<             {
---
>             foreach my $fieldNameRec (
>                     ['serverType' => 'type'],
>                     ['instanceName' => 'instanceName'],
>                     ['targetUserName' => 'targetusername'],
>                     ['srshostname' => 'srshostname'],
>                     ['dsiname' => 'dsiname'],
>                     ['dsiusername' => 'dsiusername']) {
432,435c448,450
<                 my $XMLPath   = $fieldNameRec->[1];
<                 die
< "getAllSRSServers: required field '$fieldName' not found in DeploymentDefaults.xml XML PATH 'lumira.monitoring.srsservers.$serverName.$XMLPath' on $hostname for \$serverName '$serverName'.  This caused me to not run three sub-checks: all_who_is_down, all_disk_space and get_rs_tickets.\n"
<                   unless $ret->{$fieldName};
---
>                 my $XMLPath = $fieldNameRec->[1];
>                 die "getAllSRSServers: required field '$fieldName' not found in DeploymentDefaults.xml XML PATH 'lumira.monitoring.srsservers.$serverName.$XMLPath' on $hostname for \$serverName '$serverName'.  This caused me to not run three sub-checks: all_who_is_down, all_disk_space and get_rs_tickets.\n"
>                     unless $ret->{$fieldName};
440,444c455,457
<     die
< "getAllSRSServers: unable to locate a password for any SRS Servers.  I looked in DeploymentDefaults.xml XML PATH lumira.monitoring.srsservers.\$serverName.password on $hostname for various values of \$serverName: 'SRSServer-Dir', 'SRSServer-SupN' for N = 1 .. 100.  This caused me to not run two sub-checks: all_who_is_down and get_rs_tickets.\n"
<       unless $savedServerPass;
<     foreach my $server (@allServers)
<     {
---
>     die "getAllSRSServers: unable to locate a password for any SRS Servers.  I looked in DeploymentDefaults.xml XML PATH lumira.monitoring.srsservers.\$serverName.password on $hostname for various values of \$serverName: 'SRSServer-Dir', 'SRSServer-SupN' for N = 1 .. 100.  This caused me to not run two sub-checks: all_who_is_down and get_rs_tickets.\n"
>         unless $savedServerPass;
>     foreach my $server (@allServers) {
449,453c462,464
< 
< sub getAllSRSAgents
< {
<     my $me        = shift;
<     my $hostname  = ariba::Ops::NetworkUtils::hostname();
---
> sub getAllSRSAgents {
>     my $me = shift;
>     my $hostname = ariba::Ops::NetworkUtils::hostname();
456,459c467,468
<     foreach my $baseName ('SRSAgent-Dir', 'SRSAgent-Sup')
<     {
<         foreach my $postfix ('', 1 .. 100)
<         {
---
>     foreach my $baseName ('SRSAgent-Dir','SRSAgent-Sup') {
>         foreach my $postfix ('', 1..100) {
464,469c473,478
<                        agentName    => $agentName,
<                        agentType    => $me->default("lumira.monitoring.srsagents.$agentName.type"),
<                        instanceName => $me->default("lumira.monitoring.srsagents.$agentName.instancename"),
<                        agentUname   => $me->default("lumira.monitoring.srsagents.$agentName.targetusername"),
<                        srshostname  => $me->default("lumira.monitoring.srsagents.$agentName.srshostname"),
<                       };
---
>                 agentName => $agentName,
>                 agentType => $me->default("lumira.monitoring.srsagents.$agentName.type"),
>                 instanceName => $me->default("lumira.monitoring.srsagents.$agentName.instancename"),
>                 agentUname => $me->default("lumira.monitoring.srsagents.$agentName.targetusername"),
>                 srshostname => $me->default("lumira.monitoring.srsagents.$agentName.srshostname"),
>             };
471,472c480,484
<             foreach my $fieldNameRec (['agentType' => 'type'], ['instanceName' => 'instancename'], ['agentUname' => 'targetusername'], ['srshostname' => 'srshostname'])
<             {
---
>             foreach my $fieldNameRec (
>                     ['agentType' => 'type'],
>                     ['instanceName' => 'instancename'],
>                     ['agentUname' => 'targetusername'],
>                     ['srshostname' => 'srshostname']) {
474c486
<                 my $XMLPath   = $fieldNameRec->[1];
---
>                 my $XMLPath = $fieldNameRec->[1];
476c488
<                   unless $ret->{$fieldName};
---
>                     unless $ret->{$fieldName};
481,485c493,495
<     die
< "getAllSRSAgents: unable to locate a password for any SRS Agents.  I looked in DeploymentDefaults.xml XML PATH lumira.monitoring.srsagents.\$agentName.password on $hostname for various values of \$agentName: 'SRSAgent-Dir', 'SRSAgent-SupN' for N = 1 .. 100.  This caused me to not run two sub-checks: all_ra_status and submitTickets.\n"
<       unless $savedAgentPass;
<     foreach my $agent (@allAgents)
<     {
---
>     die "getAllSRSAgents: unable to locate a password for any SRS Agents.  I looked in DeploymentDefaults.xml XML PATH lumira.monitoring.srsagents.\$agentName.password on $hostname for various values of \$agentName: 'SRSAgent-Dir', 'SRSAgent-SupN' for N = 1 .. 100.  This caused me to not run two sub-checks: all_ra_status and submitTickets.\n"
>         unless $savedAgentPass;
>     foreach my $agent (@allAgents) {
491,494c501,503
< sub get_rs_tickets
< {
<     my $allServers        = shift;
<     my $hanaCredentials   = shift;
---
> sub get_rs_tickets {
>     my $allServers = shift;
>     my $hanaCredentials = shift;
496,499c505,507
<     my @ret               = ();
<     my $config            = $checkSpecificConfigs->{get_rs_ticket};
<     foreach my $server (@$allServers)
<     {
---
>     my @ret = ();
>     my $config = $checkSpecificConfigs->{get_rs_ticket};
>     foreach my $server (@$allServers) {
501,507c509,515
<                     userid      => $server->{dsiusername},
<                     serverType  => $server->{serverType},
<                     hostname    => $hanaCredentials->{$server->{serverType}}->{hostname},
<                     password    => $allDSIConnections->{$server->{serverName}}->{dsiUserPass},
<                     checkName   => 'get_rs_ticket',
<                     errorString => '',
<                    );
---
>             userid => $server->{dsiusername},
>             serverType => $server->{serverType},
>             hostname => $hanaCredentials->{$server->{serverType}}->{hostname},
>             password => $allDSIConnections->{$server->{serverName}}->{dsiUserPass},
>             checkName => 'get_rs_ticket',
>             errorString => '',
>         );
510c518
<         $args{password}  = 'password';
---
>         $args{password} = 'password';
512,513c520
<         if ($@)
<         {
---
>         if($@) {
515c522
<             $args{answer}      = "error: $@ STATUS-crit";
---
>             $args{answer} = "error: $@ STATUS-crit";
517c524
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
519d525
< 
524,525c530
<         if (not $args{$config->{requiredField}})
<         {
---
>         if(not $args{$config->{requiredField}}) {
530,531c535
<         if (not $args{ticketApproximateEndToEndLatency})
<         {
---
>         if(not $args{ticketApproximateEndToEndLatency}) {
536,537c540
<         if ($args{ticketApproximateEndToEndLatency} > $config->{critLatency})
<         {
---
>         if($args{ticketApproximateEndToEndLatency} > $config->{critLatency}) {
542,543c545
<         if ($args{ticketApproximateEndToEndLatency} > $config->{warnLatency})
<         {
---
>         if($args{ticketApproximateEndToEndLatency} > $config->{warnLatency}) {
554,555c556
< sub submitTickets
< {
---
> sub submitTickets {
557,565c558,565
<     my @ret       = ();
<     my $config    = $checkSpecificConfigs->{submitTickets};
<     my $h1        = time;
<     my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
< 
<     my $h2 = sprintf ("%04d/%02d/%02d", $year + 1900, $mon + 1, $mday,);
< 
<     foreach my $agent (@$allAgents)
<     {
---
>     my @ret = ();
>     my $config = $checkSpecificConfigs->{submitTickets};
>     my $h1 = time;
>     my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime (time) ;
> 
>     my $h2 = sprintf("%04d/%02d/%02d", $year+1900, $mon+1, $mday, );
>     
>     foreach my $agent (@$allAgents) {
567,575c567,575
<                     instanceName => $agent->{instanceName},
<                     userid       => $agent->{agentUname},
<                     password     => $agent->{agentPass},
<                     hostname     => $agent->{srshostname},
<                     h1           => $h1,
<                     h2           => $h2,
<                     checkName    => 'submitTickets',
<                     errorString  => '',
<                    );
---
>             instanceName => $agent->{instanceName},
>             userid => $agent->{agentUname},
>             password => $agent->{agentPass},
>             hostname => $agent->{srshostname},
>             h1 => $h1,
>             h2 => $h2,
>             checkName => 'submitTickets',
>             errorString => '',
>         );
580c580
<         $args{password}  = 'password';
---
>         $args{password} = 'password';
582,583c582
<         if ($@)
<         {
---
>         if($@) {
585c584
<             $args{answer}      = "error: $@ STATUS-crit";
---
>             $args{answer} = "error: $@ STATUS-crit";
587c586
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
589d587
< 
591,592c589
<         if ($args{retString} =~ $config->{infoRegex})
<         {
---
>         if($args{retString} =~ $config->{infoRegex}) {
594,596c591
<         }
<         else
<         {
---
>         } else {
604,605c599
< sub all_ra_status
< {
---
> sub all_ra_status {
607,610c601,603
<     my @ret       = ();
<     my $config    = $checkSpecificConfigs->{ra_status};
<     foreach my $agent (@$allAgents)
<     {
---
>     my @ret = ();
>     my $config = $checkSpecificConfigs->{ra_status};
>     foreach my $agent (@$allAgents) {
612,618c605,611
<                     instanceName => $agent->{instanceName},
<                     userid       => $agent->{agentUname},
<                     password     => $agent->{agentPass},
<                     hostname     => $agent->{srshostname},
<                     checkName    => 'ra_status',
<                     errorString  => '',
<                    );
---
>             instanceName => $agent->{instanceName},
>             userid => $agent->{agentUname},
>             password => $agent->{agentPass},
>             hostname => $agent->{srshostname},
>             checkName => 'ra_status',
>             errorString => '',
>         );
621c614
<         $args{password}  = 'password';
---
>         $args{password} = 'password';
623,624c616
<         if ($@)
<         {
---
>         if($@) {
626c618
<             $args{answer}      = "error: $@ STATUS-crit";
---
>             $args{answer} = "error: $@ STATUS-crit";
628c620
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
630d621
< 
632,633c623
<         if ($args{retString} =~ $config->{infoRegex})
<         {
---
>         if($args{retString} =~ $config->{infoRegex}) {
635,637c625
<         }
<         else
<         {
---
>         } else {
645,646c633
< sub all_license_monitoring
< {
---
> sub all_license_monitoring {
648,652c635,639
<     my $service    = shift;
<     my $hostname   = shift;
<     my $user       = "mon$service";
<     my $cipher     = ariba::rc::CipherStore->new($service);
<     my $password   = $cipher->valueForName($user);
---
>     my $service = shift;
>     my $hostname = shift;
>     my $user = "mon$service";
>     my $cipher = ariba::rc::CipherStore->new($service);
>     my $password = $cipher->valueForName($user);
654c641
<     my @ret    = ();
---
>     my @ret = ();
656,657c643
<     foreach my $server (@$allServers)
<     {
---
>     foreach my $server (@$allServers) {
659,665c645,651
<                     userid      => $user,
<                     password    => $password,
<                     hostname    => $server->{srshostname},
<                     dsiname     => $server->{dsiname},
<                     checkName   => 'license_monitoring',
<                     errorString => '',
<                    );
---
>             userid => $user,
>             password => $password,
>             hostname => $server->{srshostname},
>             dsiname => $server->{dsiname},
>             checkName => 'license_monitoring',
>             errorString => '',
>         );
669c655
<         $args{password}  = 'password';
---
>         $args{password} = 'password';
674,675c660
<         if ($@)
<         {
---
>         if($@) {
677c662
<             $args{answer}      = "error: $@ STATUS-crit";
---
>             $args{answer} = "error: $@ STATUS-crit";
679c664
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
681d665
< 
683,689c667,669
<         if (
<             $args{retString} =~ $config->{infoRegex}
<             and
< 
<             $args{retString} =~ /Crit/
<            )
<         {
---
>         if(     $args{retString} =~ $config->{infoRegex} and
> 
>                 $args{retString} =~ /Crit/  ) {
691,693c671
<         }
<         elsif ($args{retString} =~ /Warn/)
<         {
---
>         } elsif($args{retString} =~ /Warn/ ) {
695,697c673
<         }
<         elsif ($args{retString} !~ /Warn|Crit/)
<         {
---
>         } elsif($args{retString} !~  /Warn|Crit/) {
706,707c682
< sub all_disk_space
< {
---
> sub all_disk_space {
709,712c684,686
<     my @ret        = ();
<     my $config     = $checkSpecificConfigs->{disk_space};
<     foreach my $server (@$allServers)
<     {
---
>     my @ret = ();
>     my $config = $checkSpecificConfigs->{disk_space};
>     foreach my $server (@$allServers) {
714,721c688,695
<                     instanceName => $server->{instanceName},
<                     userid       => $server->{targetUserName},
<                     password     => $server->{serverPass},
<                     hostname     => $server->{srshostname},
<                     dsiname      => $server->{dsiname},
<                     checkName    => 'disk_space',
<                     errorString  => '',
<                    );
---
>             instanceName => $server->{instanceName},
>             userid => $server->{targetUserName},
>             password => $server->{serverPass},
>             hostname => $server->{srshostname},
>             dsiname => $server->{dsiname},
>             checkName => 'disk_space',
>             errorString => '',
>         );
724c698
<         $args{password}  = 'password';
---
>         $args{password} = 'password';
727d700
<         my @content = check_disk_space($args{retString});
729,730c702
<         my $totalSpace     = 0;
<         my $totalUsedSpace = 0;
---
>         my @content = check_disk_space($args{retString});  
732,733c704,707
<         foreach my $partition (@content)
<         {
---
>         my $totalSpace = 0;
>         my $totalUsedSpace = 0;
>     
>         foreach my $partition (@content) {
739c713
<         }
---
>         }    
741,742c715
<         unless (defined $totalUsedSpace and defined $totalSpace)
<         {
---
>         unless (defined $totalUsedSpace and defined $totalSpace ){
746c719
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
749,752c722,724
<         my $disk_usage = sprintf ("%.2f", ($totalUsedSpace / $totalSpace) * 100);
< 
<         if ($@)
<         {
---
>         my $disk_usage = sprintf ("%.2f", ($totalUsedSpace/$totalSpace) * 100 );   
>       
>         if( $@ ) {
754c726
<             $args{answer}      = "error: $@ STATUS-crit";
---
>             $args{answer} = "error: $@ STATUS-crit";
756c728
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
758d729
< 
760,761c731
<         if ($disk_usage and $disk_usage < 5)
<         {
---
>         if($disk_usage and  $disk_usage < 5) {
764,766c734
<         }
<         elsif ($disk_usage and $disk_usage > 5 and $disk_usage < 10)
<         {
---
>         } elsif($disk_usage and $disk_usage > 5 and $disk_usage < 10 ) {
769,771c737
<         }
<         elsif ($disk_usage and $disk_usage > 10)
<         {
---
>         } elsif($disk_usage and $disk_usage > 10)  {
779,781c745
< 
< sub all_who_is_down
< {
---
> sub all_who_is_down {
783,787c747,750
<     my $service    = shift;
<     my @ret        = ();
<     my $config     = $checkSpecificConfigs->{who_is_down};
<     foreach my $server (@$allServers)
<     {
---
>     my $service = shift;
>     my @ret = ();
>     my $config = $checkSpecificConfigs->{who_is_down};
>     foreach my $server (@$allServers) {
789,799c752,761
<                     instanceName => $server->{instanceName},
<                     userid       => $server->{targetUserName},
<                     password     => $server->{serverPass},
<                     hostname     => $server->{srshostname},
<                     dsiname      => $server->{dsiname},
<                     checkName    => 'who_is_down',
<                     errorString  => '',
<                    );
<         my %repServer = repServerMemory($service, %args);
<         my %errorRepAgent = repAgentErrormonitor($service, %args);
< 
---
>             instanceName => $server->{instanceName},
>             userid => $server->{targetUserName},
>             password => $server->{serverPass},
>             hostname => $server->{srshostname},
>             dsiname => $server->{dsiname},
>             checkName => 'who_is_down',
>             errorString => '',
>         );
> 	my %repServer = repServerMemory($service,%args);
>         my %errorRepAgent = repAgentErrormonitor($service,%args);
803c765
<         $args{password}  = 'password';
---
>         $args{password} = 'password';
806,807c768
<         if ($@)
<         {
---
>         if($@) {
809c770
<             $args{answer}      = "error: $@ STATUS-crit";
---
>             $args{answer} = "error: $@ STATUS-crit";
811c772
<             next;    #bail out early on errors so the main logic isn't indented
---
>             next;  #bail out early on errors so the main logic isn't indented
813d773
< 
815,816c775
<         if ($args{retString} =~ qr/$config->{CritRegex}/i)
<         {
---
>         if(     $args{retString} =~ qr/$config->{CritRegex}/i ){
818,820c777
<         }
<         else
<         {
---
>         } else {
832,833c789
< sub repServerMemory
< {
---
> sub repServerMemory{
835c791
<     my %args    = @_;
---
>     my %args = @_;
838,839c794,795
<     my $user     = "mon$service";
<     my $cipher   = ariba::rc::CipherStore->new($service);
---
>     my $user = "mon$service";
>     my $cipher = ariba::rc::CipherStore->new($service);
846c802
<     my $command   = "ssh -t $host_info 'ps -elf | grep -i rax |grep futex_|grep -v grep'";
---
>     my $command = "ssh -t $host_info 'ps -elf | grep -i rax |grep futex_|grep -v grep'";
850c806
<     my $status = ariba::rc::Utils::executeRemoteCommand($command, $password, 0, undef, undef, \@output);
---
>     my $status = ariba::rc::Utils::executeRemoteCommand($command,$password,0,undef,undef,\@output);
853,854c809
<     if (!$status || $#output < 0)
<     {
---
>     if (! $status || $#output < 0 ){
859,871c814,821
<     my @line = split (' ', $output[0]);
<     my $size = sprintf ("%.2f", $line[9] / (1024 * 1024));
<     if ($size >= $config->{critThreshold})
<     {
<         $args{answer} = $size . ' GB STATUS-crit';
<     }
<     elsif ($size >= $config->{warnThreshold})
<     {
<         $args{answer} = $size . ' GB STATUS-warn';
<     }
<     else
<     {
<         $args{answer} = $size . ' GB STATUS-info';
---
>     my @line = split(' ',$output[0]);
>     my $size = sprintf("%.2f",$line[9]/(1024*1024));
>     if ( $size >= $config->{critThreshold} ){
>         $args{answer} = $size.' GB STATUS-crit';
>     }elsif ( $size >= $config->{warnThreshold} ){
>         $args{answer} = $size.' GB STATUS-warn';
>     }else {
>         $args{answer} = $size.' GB STATUS-info';
877,878c827
< sub repAgentErrormonitor
< {
---
> sub repAgentErrormonitor{
880c829
<     my %args    = @_;
---
>     my %args = @_;
883,884c832,833
<     my $user     = "mon$service";
<     my $cipher   = ariba::rc::CipherStore->new($service);
---
>     my $user = "mon$service";
>     my $cipher = ariba::rc::CipherStore->new($service);
891c840
<     my $command   = "ssh -l $host_info 'sudo su -c \"grep ^E /opt/sybase/rao/RAX*/LUNA2_*/log/LUNA2_RA[A-Z][0-9][0-9].log|grep RB_INVALID_ROLLBACK_ID\"'";
---
>     my $command = "ssh -l $host_info 'sudo su -c \"grep ^E /opt/sybase/rao/RAX*/LUNA2_*/log/LUNA2_RA[A-Z][0-9][0-9].log|grep RB_INVALID_ROLLBACK_ID\"'";
895c844
<     my $status = ariba::rc::Utils::executeRemoteCommand($command, $password, 0, undef, undef, \@output);
---
>     my $status = ariba::rc::Utils::executeRemoteCommand($command,$password,0,undef,undef,\@output);
900,903c849,851
<     my $time15Minback = strftime("%Y%m%d%H%M%S", localtime (time () - 15 * 60));
<     for my $line (@output)
<     {
<         next unless ($line);
---
>     my $time15Minback = strftime("%Y%m%d%H%M%S",localtime(time()-15*60));
>     for my $line (@output){
> 	next unless($line);
905,908c853,855
<         $errorTime =~ s/(\/|:|\s+)//g;
<         if ($errorTime > $time15Minback)
<         {
<             push (@result, $line);
---
>         $errorTime=~ s/(\/|:|\s+)//g;
>         if ($errorTime > $time15Minback){
>             push (@result,$line);
911,912c858
<     unless (@result)
<     {
---
>     unless( @result ){
917c863
<     $args{answer} = join ("\n", @result) . " STATUS-crit";
---
>     $args{answer} = join("\n",@result)." STATUS-crit";
921,924c867,869
< sub myInfo
< {
<     my $infoStr     = shift;
<     my $now         = scalar localtime;
---
> sub myInfo {
>     my $infoStr = shift;
>     my $now = scalar localtime;
928c873
<         local $SIG{ALRM} = sub {die "timed out\n";};
---
>         local $SIG{ALRM} = sub { die "timed out\n"; };
933,935c878,879
<         my $bytes = (stat ($logFileName))[7];
<         if ($bytes > 100000000)
<         {
---
>         my $bytes = (stat($logFileName))[7];
>         if($bytes > 100000000) {
943,944c887
< sub _resolveTemplate
< {
---
> sub _resolveTemplate {
946,948c889,891
<     my $args     = shift;
<     my %args     = %$args;
<     my $ret      = eval "return \"$template\"";
---
>     my $args = shift;
>     my %args = %$args;
>     my $ret = eval "return \"$template\"";
953,954d895
< sub check_disk_space
< {
956,967c897,909
<     my $data = shift;
<     my @dataString = split /\n/, $data;
<     my @content;
<     foreach my $part (@dataString)
<     {
<         $part =~ s/^\s+|\s+$//g;
<         next if ($part !~ /partition|new_partition/);
<         print "Pushing $part\n", if $debug > 1;
<         push @content, $part;
<     }
<     print "Returning CONTENT \n", Dumper @content, "\n", if $debug;
<     return @content;
---
> sub check_disk_space {
> 
>    my $data = shift;
>    my @dataString = split /\n/, $data;
>    my @content;
>    foreach my $part (@dataString) {
>       $part =~ s/^\s+|\s+$//g;
>       next if ($part !~ /partition|new_partition/);
>       print "Pushing $part\n", if $debug > 1;
>       push @content, $part;
>    }
>   print "Returning CONTENT \n", Dumper @content, "\n", if $debug;
>   return @content;
filename:./bin/common/cert-bundle-expire
110,112d109
<             inf_field => "certDaysToExpiration",
<             inf_tags => "datacenter=\"$datacenter\",CADisplayName=\"$displayName\"",
<             group_by => "$datacenter,$displayName",
<             inf_default => 0,
41d40
<     my $pn = ariba::monitor::StatusPage::fakeProductNameForDatacenter($datacenter);
54c53
<         processCertDir($cert, $anCertDir, \%queries, $datacenter);
---
>         processCertDir($cert, $anCertDir, \%queries);
60c59
<     $queries{influx_details} = {measurement => "certificate_time_until_expire"};
---
>     my $pn = ariba::monitor::StatusPage::fakeProductNameForDatacenter($datacenter);
72d70
<     my $datacenter = shift;
filename:./bin/common/cgroups-status
21c21
< my $LOCKFILE = '/tmp/stratus-cgroups-status'; 
---
> my $LOCKFILE = '/tmp/cgroups-status'; 
73c73
<         $queries{influx_details} = { measurement => 's4_cgroups_stats' };
---
> 
161,162d160
<     my ($p1,$p2) = split(/\s/,$prefix);
<     $prefix=$p1;
182,185d179
<         inf_field => "percent_packets_dropped",
<         inf_default => 0,
<         inf_tags => qq(node_name="$prefix",type="$statsKey"),
<         group_by => qq($prefix,$statsKey),
209,212d202
<         inf_field => "percent_packets_resent",
<         inf_default => 0,
<         inf_tags => qq(node_name="$prefix",type="$statsKey"),
<         group_by => qq($prefix,$statsKey),
233,236d222
<         inf_field => "percent_outbound_dropped_packets",
<         inf_default => 0,
<         inf_tags => qq(node_name="$prefix",type="$statsKey"),
<         group_by => qq($prefix,$statsKey),
316,319d301
<             inf_field => "cgroups_stats",
<             inf_default => "none",
<             inf_tags => qq(node_name="$nodeName",type="$statsKey"),
<             group_by => qq($nodeName,$statsKey),
324,326d305
<         my %inf_db_cols = ('Reliable Message Queue size outbound (fragmented packets)' => 'msg_que_outbound_size',
<                            'Reliable Packets expired' => 'packets_expired',
<                            'Reliable Packets lost from inbound queue' => 'packets_lost_from_inbound_que');
355d333
<             my $inf_field = $inf_db_cols{$cgroupsMonItem};
367,370d344
<                 inf_field => $inf_field,
<                 inf_default => 0,
<                 inf_tags  => qq(node_name="$nodeName",type="$statsKey"),
<                 group_by  => qq($nodeName,$statsKey),
filename:./bin/common/check-console-hostnames
148,151d147
<                 inf_field => "consoleServerDNSEntryStatus",
<                 inf_tags => sprintf("datacenter=\"%s\",hostname=\"%s\"", $datacenter,$machine->hostname),
<                 inf_default => 0,
<                 group_by => "$datacenter,$machine->hostname",
154,163c150,155
<  	        $queries{sprintf("%s -  Ping Status for %s", $machine->hostname,$consoleServerHost)} = {
< 	            noRowCount => 1,
< 	            info => "answer =~ /up/si",
< 	            crit => "answer !~ /up/si",
< 	            perl => "return '$ping_status'",
<                 inf_field => "pingStatus",
<                 inf_tags => sprintf("datacenter=\"%s\",hostname=\"%s\"", $datacenter,$machine->hostname),
<                 inf_default => 0,
<                 group_by => "$datacenter,$machine->hostname",
< 	        };
---
>  	              $queries{sprintf("%s -  Ping Status for %s", $machine->hostname,$consoleServerHost)} = {
> 	                noRowCount => 1,
> 	                info => "answer =~ /up/si",
> 	                crit => "answer !~ /up/si",
> 	                perl => "return '$ping_status'",
> 	             };
166c158
<         	$queries{influx_details} = {measurement => "console_hostname_check"}; 
---
>         
171c163
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/conversational-api-status
15,17c15,16
< sub usage
< {
<     my $error = shift;
---
> sub usage {
> 	my $error = shift; 
19c18
<     print <<USAGE;
---
> 	print <<USAGE;
22,26c21,25
<     -product <product> Run for a specified product
<     -e    Enables sending of email for monitor query.
<     -p    Enables sending of pages for monitor query.
<     -d    Turns on debug mode. 
<     -h    Shows this help.
---
> 	-product <product> Run for a specified product
> 	-e    Enables sending of email for monitor query.
> 	-p    Enables sending of pages for monitor query.
> 	-d    Turns on debug mode. 
> 	-h    Shows this help.
30c29
<     print "(error) $error\n" if ($error);
---
> 	print "(error) $error\n" if ($error);
32c31
<     exit ();
---
> 	exit();
35,74c34,69
< sub main
< {
<     my $sendEmail = 0;
<     my $sendPage  = 0;
<     my $productName;
< 
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o)       {$sendEmail   = 1;        next;}
<         if ($arg =~ /^-p$/o)       {$sendPage    = 1;        next;}
<         if ($arg =~ /^-product$/o) {$productName = shift (); next;}
< 
<         usage("Invalid argument: $arg");
<     }
< 
<     usage("Product required") unless $productName;
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $product = ariba::rc::InstalledProduct->new($productName, $me->service());
<     exit 0 unless $product;
< 
<     my %queries;
< 
<     $queries{'Current active Conversational API sessions'} = {
<         format   => "%d\n",
<         uiHint   => 'Conversational API',
<         warn     => 'answer > 20',
<         crit     => 'answer > 200',
<         sql      => 'SELECT NVL(CONVS_NEWSESSIONSSTARTED,0) as convs_api_sessions FROM ConvSessionStatusMonitorTab a where a.CONVS_HOURID = to_char(sysdate, \'HH24\')',
<         inf_tags => "conversational_api",
<     };
< 
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = {measurement => "current_activity"};
< 
<     my $qm = ariba::monitor::QueryManager->newWithDetails('current-activity', $product->name(), $product->service(), $product->customer(), \%queries);
<     $qm->setSQLConnectInfo($product->connectInfoForOracleClient());
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> sub main {
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while (my $arg = shift) {
> 		if ($arg =~ /^-h$/o) { usage(); 			next; }
> 		if ($arg =~ /^-d$/o) { $debug++; 		next; }
> 		if ($arg =~ /^-e$/o) { $sendEmail = 1; 	next; }
> 		if ($arg =~ /^-p$/o) { $sendPage = 1; 	next; }
> 		if ($arg =~ /^-product$/o) { $productName = shift(); next; }
> 
> 		usage("Invalid argument: $arg");
> 	}
> 
> 	usage("Product required") unless $productName;
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $product = ariba::rc::InstalledProduct->new($productName, $me->service());
> 	exit 0 unless $product;
> 
> 	my %queries;
> 
> 	$queries{'Current active Conversational API sessions'} = {
> 		format	=> "%d\n",
> 		uiHint	=> 'Conversational API',
> 		warn	=> 'answer > 20',
> 		crit	=> 'answer > 200',
> 		sql	=> 'SELECT NVL(CONVS_NEWSESSIONSSTARTED,0) FROM ConvSessionStatusMonitorTab a where a.CONVS_HOURID = to_char(sysdate, \'HH24\')',
> 	};
> 
> 	my $email = $me->default('notify.email');
> 
> 	my $qm = ariba::monitor::QueryManager->newWithDetails('current-activity', $product->name(), $product->service(), $product->customer(), \%queries);
> 	$qm->setSQLConnectInfo($product->connectInfoForOracleClient());
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
80d74
< 
filename:./bin/common/db-conn-status
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
17,18c17
< sub usage
< {
---
> sub usage {
31c30
<     print "(error) $error\n" if ($error);
---
>     print "(error) $error\n" if ( $error );
36,37c35
< sub main
< {
---
> sub main {
41,46c39,43
<     while (my $arg = shift)
<     {
<         if ($arg =~ /^-h$/o) {usage();  next;}
<         if ($arg =~ /^-d$/o) {$debug++; next;}
<         if ($arg =~ /^-e$/o) {$sendEmail = 1; next;}
<         if ($arg =~ /^-p$/o) {$sendPage  = 1; next;}
---
>     while ( my $arg = shift ) {
>         if ( $arg =~ /^-h$/o ) { usage();  next; }
>         if ( $arg =~ /^-d$/o ) { $debug++; next; }
>         if ( $arg =~ /^-e$/o ) { $sendEmail = 1; next; }
>         if ( $arg =~ /^-p$/o ) { $sendPage  = 1; next; }
48c45
<         usage("Invalid argument: $arg");
---
>         usage( "Invalid argument: $arg" );
51,54c48,51
<     my $me       = ariba::rc::InstalledProduct->new();
<     my $cluster  = $me->currentCluster();
<     my $service  = $me->service();
<     my @products = ('buyer', 's4');
---
>     my $me = ariba::rc::InstalledProduct->new();
>     my $cluster   = $me->currentCluster();
>     my $service   = $me->service();
>     my @products  = ( 'buyer', 's4' );
56,57c53
<     foreach my $product (@products)
<     {
---
>     foreach my $product ( @products ) {
59,62c55,56
<         my %summary_query = ();
<         my %details_query = ();
< 
<         my @monitorproducts = init($service, $cluster, $product);
---
>         my %queries = ();
>         my @monitorproducts = init( $service, $cluster, $product );
65,84c59,74
<         foreach my $product (@monitorproducts)
<         {
<             my ($url, $url1) = geturls($product, $me);
<             my ($instance, %dbinfo) = getdbconn_info($url);
<             if (!%dbinfo)
<             {
<                 print "No status from 1st Node: $instance, trying next node\n";
<                 ($instance, %dbinfo) = getdbconn_info($url1);
<             }
<             my $hostSID = getHostSID($product);
< 
<             $summary_query{"Connection to DB : Overall Status"} = {
<                                                                    crit   => "previousAnswer && answer && (answer ne 'OK') && (previousAnswer ne 'OK')",
<                                                                    perl   => sub {return check_database_status($instance, \%dbinfo, $hostSID);},
<                                                                    format => "%s\n",
<                                                                    uiHint => 'General/Connection to DB',
<                                                                    logURL => $url->logURL() || "",
<                                                                    inf_field => "overall_status",
<                                                                   };
< 
---
>         foreach my $product ( @monitorproducts ) {
>             my ($url, $url1) = geturls( $product, $me );
>             my ($instance, %dbinfo) = getdbconn_info( $url );
> 	    if (! %dbinfo) {
> 		print "No status from 1st Node: $instance, trying next node\n";
> 		($instance, %dbinfo) = getdbconn_info( $url1);
> 	    }
> 	    my $hostSID = getHostSID($product);
> 
>             $queries{ "Connection to DB : Overall Status" } = {
>                     crit   => "previousAnswer && answer && (answer ne 'OK') && (previousAnswer ne 'OK')",
>                     perl   => sub { return check_database_status($instance, \%dbinfo, $hostSID); },
>                     format => "%s\n",
>                     uiHint => 'General/Connection to DB',
>                     logURL => $url->logURL() || "",
>              };
86,97c76,83
<             foreach my $db (keys %dbinfo)
<             {
<                 $details_query{"Connection to DB : SID $db"} = {
<                                                                 warn      => 'answer ne "OK"',
<                                                                 perl      => sub {return $dbinfo{$db};},
<                                                                 format    => "%s\n",
<                                                                 uiHint    => 'General/Connection to DB',
<                                                                 logURL    => $url->logURL() || "",
<                                                                 inf_field => "status",
<                                                                 inf_tags  => qq(sid="$db"),
<                                                                 group_by  => $db,
<                                                                };
---
>             foreach my $db ( keys %dbinfo ) {
>                 $queries{ "Connection to DB : SID $db" } = {
>                     warn   => 'answer ne "OK"',
>                     perl   => sub { return $dbinfo{ $db }; },
>                     format => "%s\n",
>                     uiHint => 'General/Connection to DB',
>                     logURL => $url->logURL() || "",
>                 };
100,105c86,89
<             my $email = $me->default('notify.email');
<             $summary_query{"influx_details"} = {'measurement' => "front_door_db_connections_summary"};
<             $details_query{"influx_details"} = {'measurement' => "front_door_db_connections_details"};
< 
<             my $qm = ariba::monitor::QueryManager->newWithDetails('http-urls-status', $product->name(), $me->service(), $me->customer(), \%summary_query);
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             my $email = $me->default( 'notify.email' );
>             my $qm = ariba::monitor::QueryManager->newWithDetails( 'http-urls-status', $product->name(), $me->service(),
>                 $me->customer(), \%queries );
>             $qm->processQueries( $debug, $email, $sendEmail, $sendPage );
107,108d90
<             my $qm2 = ariba::monitor::QueryManager->newWithDetails('http-urls-status', $product->name(), $me->service(), $me->customer(), \%details_query);
<             $qm2->processQueries($debug, $email, $sendEmail, $sendPage);
113,114c95
< sub init
< {
---
> sub init {
118,121c99,102
<     my @products    = ariba::rc::InstalledProduct->installedProductsListInCluster($serviceName, $prodName, undef, $clusterName);
<     for my $product (@products)
<     {
<         printf ("%s called for %s%s\n", (caller)[0], $product->name(), $product->service()) if $debug;
---
>     my @products =
>       ariba::rc::InstalledProduct->installedProductsListInCluster( $serviceName, $prodName, undef, $clusterName );
>     for my $product ( @products ) {
>         printf ( "%s called for %s%s\n", ( caller )[ 0 ], $product->name(), $product->service() ) if $debug;
127,128c108
< sub geturls
< {
---
> sub geturls {
133,134c113
<     foreach my $product (@monitorproducts)
<     {
---
>     foreach my $product ( @monitorproducts ) {
138,139c117,118
<         my $timeout     = 35;                                          # time the url has to reply
<         my @instances   = $product->appInstancesInCluster($cluster);
---
>         my $timeout     = 35;                                            # time the url has to reply
>         my @instances   = $product->appInstancesInCluster( $cluster );
142,143c121
<         for my $instance (@instances)
<         {
---
>         for my $instance ( @instances ) {
145,150c123,128
<             my $monUrl = ariba::monitor::Url->new($url);
<             $monUrl->setForceSickOnConnectionError(1);
<             $monUrl->setTimeout($timeout);
<             $monUrl->setNotify($me->default('notify.email'));
<             $monUrl->setProductName($productName);
<             $monUrl->setCustomerName($customer) if $customer;
---
>             my $monUrl = ariba::monitor::Url->new( $url );
>             $monUrl->setForceSickOnConnectionError( 1 );
>             $monUrl->setTimeout( $timeout );
>             $monUrl->setNotify( $me->default( 'notify.email' ) );
>             $monUrl->setProductName( $productName );
>             $monUrl->setCustomerName( $customer ) if $customer;
153,154c131,132
<             $monUrl->setLogURL($logURL);
<             $monUrl->setUiHint("General");
---
>             $monUrl->setLogURL( $logURL );
>             $monUrl->setUiHint( "General" );
160c138
<     return shift @urls, shift @urls;
---
>     return shift @urls,shift @urls;
163,164c141
< sub getdbconn_info
< {
---
> sub getdbconn_info {
168c145
<     my $statsXml = $url->request(60);
---
>     my $statsXml = $url->request( 60 );
173,174c150
<     unless ($statsXml =~ /<Databases/)
<     {
---
>     unless ( $statsXml =~ /<Databases/ ) {
177,189c153,164
<     unless ($error)
<     {
<         eval {$stats = XMLin("$statsXml");};
<         $error = "Malformed XML: $@" if ($@);
<     }
<     $error = "Failed to parse XML: $statsXml for $instance" unless ($stats);
<     print $error, if $debug;
< 
<     while (my ($family, $database) = each %{$stats})
<     {
<         while (my ($dbname, $dbinfo) = each %$database)
<         {
<             my $status = $dbinfo->{'Status'};
---
>     unless ( $error ) {
>         eval {
>             $stats = XMLin( "$statsXml" );
>         };
>         $error = "Malformed XML: $@" if ( $@ );
>     }
>     $error = "Failed to parse XML: $statsXml for $instance" unless ( $stats );
>     print $error, if $debug ;
> 
>     while ( my ( $family, $database ) = each %{ $stats } ) {
>         while ( my ( $dbname, $dbinfo ) = each %$database ) {
>             my $status = $dbinfo->{ 'Status' };
191,192c166,167
<             my $timestamp = $dbinfo->{'Timestamp'};
<             $dbconn_status{$dbname} = $status;
---
>             my $timestamp = $dbinfo->{ 'Timestamp' };
>             $dbconn_status{ $dbname } = $status;
200,207c175,180
< sub check_database_status
< {
<     my ($url, $db_info, $hostSID) = @_;
< 
<     #if %{$db_info} returns 0/null, it will XML with below message.
<     if (!%{$db_info})
<     {
<         print "Did not find XML or Invalid XML found at $url,\n", if $debug;
---
> sub check_database_status {
>     my ($url, $db_info, $hostSID ) = @_;
>     
>     #if %{$db_info} returns 0/null, it will XML with below message.  
>     if (! %{$db_info}) {
>         print  "Did not find XML or Invalid XML found at $url,\n", if $debug;
216c189
<     print $statusStr ? "DBs down for $url:\n$statusStr" : "OK", if $debug;
---
>     print  $statusStr ? "DBs down for $url:\n$statusStr" : "OK", if $debug;
220,221c193
< sub getHostSID
< {
---
> sub getHostSID {
226,227c198
<     for my $dictKeypath ($product->defaultKeysForPrefix(quotemeta ($databasePrefix)))
<     {
---
>     for my $dictKeypath ($product->defaultKeysForPrefix(quotemeta($databasePrefix))) {
234,236c205,206
< sub getStatusStr
< {
<     my ($statusesRef, $hostSID) = @_;
---
> sub getStatusStr {
>     my ($statusesRef, $hostSID) =@_;
238c208
<     return undef unless (@$statusesRef);
---
>     return undef unless(@$statusesRef);
241,243c211,212
<     for (@$statusesRef)
<     {
<         push @retVal, $_ . ": " . $hostSID->{uc ($_)};
---
>     for(@$statusesRef){
>         push @retVal, $_.": ".$hostSID->{uc($_)};
245c214
<     return join (", ", @retVal);
---
>     return join(", " , @retVal);
248c217
< main(@ARGV);
---
> main( @ARGV );
251d219
< 
filename:./bin/common/downtimedb-status
15,16c15
< sub main
< {
---
> sub main{
18,121c17,110
<     my $debug     = 0;
<     my $sendEmail = 0;
<     my $sendPage  = 0;
< 
<     ariba::monitor::Outage->connect();
<     ariba::monitor::Outage->setDebug(0);
< 
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-d/o)
<         {
<             ariba::monitor::Outage->setDebug(1) if ($debug);
<             $debug = 1;
<         }
<         if ($arg =~ /^-e/o) {$sendEmail = 1;}
<         if ($arg =~ /^-p/o) {$sendPage  = 1;}
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
< 
<     my %queries;
< 
<     #
<     # First check to see if we have any downtimes needing annotation
<     #
<     my ($startDate, $endDate) = endPoints();
< 
<     # get localtime for today
<     my @tmpTime    = localtime ();
<     my $todayMonth = $tmpTime[4];
< 
<     # get localtime for 3 days later to check for end of month
<     # if the month values are different, then we're within 3 days of the end of the month
<     @tmpTime = localtime (time () + (60 * 60 * 24 * 3));
<     my $laterMonth = $tmpTime[4];
< 
<     my @allOutages = ariba::monitor::Outage->entriesForDateRange($startDate, $endDate);
<     my @outages    = ariba::monitor::Outage->unannotatedDowntimes(@allOutages);
<     my $answer     = scalar @outages;
<     my $text       = ariba::monitor::Outage->outageSummary(@outages);
< 
<     if ($debug)
<     {
<         print "======= No Annotation =======\n";
<         print "$text\n";
<     }
< 
<     $queries{"downtime db entries needing annotation"} = {
<                                                           perl    => sub {return $answer},
<                                                           info    => "defined(answer)",
<                                                           warn    => "!defined(answer) || answer > 10 || (answer > 0 && $todayMonth != $laterMonth)",
<                                                           crit    => 0,
<                                                           uiHint  => 'Entry Status',
<                                                           details => {
<                                                                       "list of entries needing annotation" => {
<                                                                                                                perl => sub {return $text},
<                                                                                                               }
<                                                                      },
<                                                           ticketOnWarnOpenAfterMinutes => 30,
<                                                           ticketSubmitter              => 'dept_an_ops_prod@ariba.com',
<                                                           #added by tarun 
<                                                           inf_field => "entries_needing_annotation", 
<                                                           inf_default => "none",
<                                                          };
< 
<     #
<     # Now check for bad data
<     #
<     @outages = ariba::monitor::Outage->badDownTimes(@allOutages);
<     my $badAnswer = scalar @outages;
<     my $badText   = ariba::monitor::Outage->outageSummary(@outages);
< 
<     if ($debug)
<     {
<         print "======= Missing Data =======\n";
<         print "$badText\n";
<     }
< 
<     $queries{"downtime db entries missing end points"} = {
<         perl => sub {return $badAnswer},
<         #
<         # XXX - for now, force this to be info only until we fix
<         # downtime db
<         #
<         # info => "defined(answer) && badAnswer == 0",
<         # warn => "!defined(answer) || badAnswer > 0",
<         info    => 1,
<         warn    => 0,
<         crit    => 0,
<         uiHint  => 'Entry Status',
<         details => {
<                     "list of entries missing end points" => {
<                                                              perl => sub {return $badText},
<                                                             }
<                    },
<         ticketOnWarnOpenAfterMinutes => 30,
<         ticketSubmitter              => 'dept_an_ops_prod@ariba.com',
<          inf_field => "missing_end_points",
<          inf_default => "none",
<                                                          };
<     my $email = $me->default('notify.email');
<     $queries{"influx_details"} = { 'measurement' => "mon_downtime_entry_status"}; 
<     my $q = ariba::monitor::QueryManager->newWithDetails("downtime", 'mon', $me->service(), $me->customer(), \%queries);
<     $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	my $debug=0;
> 	my $sendEmail=0;
> 	my $sendPage=0;
> 
> 	ariba::monitor::Outage->connect();
> 	ariba::monitor::Outage->setDebug(0);
> 
> 	while(my $arg=shift(@ARGV)){
> 		if($arg =~ /^-d/o){
> 			ariba::monitor::Outage->setDebug(1) if($debug);
> 			$debug=1;
> 		}
> 		if($arg =~ /^-e/o){ $sendEmail=1; };
> 		if($arg =~ /^-p/o){ $sendPage=1; };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 
> 	my %queries;
> 
> 	#
> 	# First check to see if we have any downtimes needing annotation
> 	#
> 	my ($startDate, $endDate) = endPoints();
> 
> 	# get localtime for today
> 	my @tmpTime = localtime();
> 	my $todayMonth = $tmpTime[4];
> 	# get localtime for 3 days later to check for end of month 
> 	# if the month values are different, then we're within 3 days of the end of the month
> 	@tmpTime = localtime(time() + (60 * 60 * 24 * 3));
> 	my $laterMonth = $tmpTime[4];
> 
> 	my @allOutages = ariba::monitor::Outage->entriesForDateRange($startDate, $endDate);
> 	my @outages = ariba::monitor::Outage->unannotatedDowntimes(@allOutages);
> 	my $answer = scalar @outages;
> 	my $text = ariba::monitor::Outage->outageSummary(@outages);
> 
> 	if($debug) {
> 		print "======= No Annotation =======\n";
> 		print "$text\n";
> 	}
> 
> 	$queries{"downtime db entries needing annotation"} = {
> 		perl => sub { return $answer },
> 		info => "defined(answer)",
> 		warn => "!defined(answer) || answer > 10 || (answer > 0 && $todayMonth != $laterMonth)",
> 		crit => 0,
> 		uiHint	=> 'Entry Status',
> 		details => {
> 			"list of entries needing annotation" => {
> 				perl => sub { return $text },
> 			}
> 		},
> 		ticketOnWarnOpenAfterMinutes => 30,
> 		ticketSubmitter => 'dept_an_ops_prod@ariba.com',
> 	};
> 
> 	#
> 	# Now check for bad data
> 	#
> 	@outages = ariba::monitor::Outage->badDownTimes(@allOutages);
> 	my $badAnswer = scalar @outages;
> 	my $badText = ariba::monitor::Outage->outageSummary(@outages);
> 
> 	if($debug) {
> 		print "======= Missing Data =======\n";
> 		print "$badText\n";
> 	}
> 
> 	$queries{"downtime db entries missing end points"} = {
> 		perl => sub { return $badAnswer },
> 		#
> 		# XXX - for now, force this to be info only until we fix
> 		# downtime db
> 		#
> 		# info => "defined(answer) && badAnswer == 0",
> 		# warn => "!defined(answer) || badAnswer > 0",
> 		info => 1,
> 		warn => 0,
> 		crit => 0,
> 		uiHint	=> 'Entry Status',
> 		details => {
> 			"list of entries missing end points" => {
> 				perl => sub { return $badText },
> 			}
> 		},
> 		ticketOnWarnOpenAfterMinutes => 30,
> 		ticketSubmitter => 'dept_an_ops_prod@ariba.com',
> 	};
> 
> 	my $email = $me->default('notify.email');
> 	my $q = ariba::monitor::QueryManager->newWithDetails("downtime", 'mon', $me->service(), $me->customer(), \%queries);
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
125,130c114,120
< sub endPoints
< {
<     my ($s, $min, $h, $d, $mon, $y) = localtime ();
<     my $endDate = sprintf ("%4d-%02d-%02d:%02d:%02d:%02d", $y + 1900, $mon + 1, $d, $h, $min, $s);
<     ($s, $min, $h, $d, $mon, $y) = localtime (time () - (90 * 24 * 60 * 60));
<     my $startDate = sprintf ("%4d-%02d-%02d:%02d:%02d:%02d", $y + 1900, $mon + 1, $d, $h, $min, $s);
---
> sub endPoints {
> 	my ($s, $min, $h, $d, $mon, $y) = localtime();
> 	my $endDate = sprintf("%4d-%02d-%02d:%02d:%02d:%02d",
> 			$y+1900,$mon+1,$d,$h,$min,$s);
> 	($s, $min, $h, $d, $mon, $y) = localtime(time()-(90*24*60*60));
> 	my $startDate = sprintf("%4d-%02d-%02d:%02d:%02d:%02d",
> 			$y+1900,$mon+1,$d,$h,$min,$s);
132c122
<     return ($startDate, $endDate);
---
> 	return($startDate, $endDate);
filename:./bin/common/focus-customers
83,84d82
< 			inf_field => "query_result",
<                         inf_tags => "query_name=\"$focusQuery\"",
90d87
<     $queries{influx_details} = {measurement => "focus_customers"};
filename:./bin/common/hana-multipath-status
71c71
<         print "$hana_host Status is $result\n" if $debug;
---
>         print "$hana_host Status is $result\n";
83,84d82
<             inf_field => "status",
<             inf_tags => "hana_host=\"$hana_host\"",
91,92d88
<     $queries{influx_details} = {measurement => "hana_multipath_status"};
< 
filename:./bin/common/instance-heap-usage
111,114d110
<                 inf_field => "vm_heap_usage",
<                 inf_default => 0,
<                 inf_tags  => qq(node="$uiHint",instance_id="$instanceName"),
<                 group_by  => "$uiHint,$instanceName",
132,135d127
<                      inf_field => "vm_heap_usage",
<                      inf_default => 0,
<                      inf_tags  => qq(node="$uiHint",instance_id="$instanceName"),
<                      group_by  => "$uiHint,$instanceName",
158,162c150,151
<                 inf_field => "time_since_last_restart",
<                 inf_default => 0,
<                 inf_tags  => qq(node="$uiHint",instance_id="$instanceName"),
<                 group_by  => "$uiHint,$instanceName",
<                  };
---
>             }
> 
167d155
<         $queries{"influx_details"} = { 'measurement' => "front_door_heap_instance" };
172c160
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/integration-events
19d18
< use Data::Dumper;
52,64c51,60
<     $queries{"Failed pending queue exports"} = {
<         'info' => "numrows > -1",
<         'skip' => $skip,
<         'crit' => "numrows > 0",
<         'perl' => sub { main::failedPendingQueue($product) },
<         inf_field => "failed_pending_queue",
<         inf_default => "none",
<         group_by => "one",
<     };
<     $queries{"Failed toolkit import events and other exports (prod realm)"} = {
<         'info' => "numrows > -1",
<         'crit' => "numrows >= 1",
<         'recordMaxResults' => 40000,
---
> 	$queries{"Failed pending queue exports"} = {
> 		'info' => "numrows > -1",
> 		'skip' => $skip,
> 		'crit' => "numrows > 0",
> 		'perl' => sub { main::failedPendingQueue($product) },
> 	};
> 	$queries{"Failed toolkit import events and other exports (prod realm)"} = {
> 		'info' => "numrows > -1",
> 		'crit' => "numrows >= 1",
> 		'recordMaxResults' => 40000,
66,115c62,105
<         'skip' => $skip,
<         'perl' => sub { main::failedEvents($product) },
<         inf_field => "failed_import_export",
<         inf_default => "none",
<         group_by => "one",
<     };
<     $queries{"Failed events (test realms)"} = {
<         'info' => "numrows > -1",
<         'crit' => 0, # Set in code later
<         'skip' => $skip,
<         'perl' => sub { main::failedOther($product) },
<         inf_field => "failed_events",
<         inf_default => "none",
<         group_by => "one",
<     };
<     $queries{"Failed to send events (current)"} = {
<         'info' => 'numrows > -1', 
<         'recordMaxResults'  => 40000,
<         'recordItem'        => 'numrows',
<         'format'            => "RootId %s, Created %s, Partition %s, Error %s\n",
<         'sql' => q/
<             SELECT Int1.rootId as rootid, to_char(Int1.arl_TimeCreated, 'YYYY-MM-DD HH24:MI:SS') as time_created, Int1.arl_PartitionNumber as partition_num,
<                 Int3.iei_ErrorMessage as iei_errormsg, 'current' as type
<             FROM IntegrationEventLogTab Int1, GlobalIntegrationErrorTab Rec2, 
<                 IntegrationErrorItemTab Int3 
<             WHERE Int1.arl_ErrorDetails = Rec2.rootId AND Rec2.gie_Items = Int3.lvId AND 
<                 Rec2.rootId = Int3.rootId AND Int1.arl_Status = 'Error' AND 
<                 Int3.iei_ErrorMessage LIKE 'Fault received when processing the WS exchange%Couldn''t send message.' AND 
<                 (Int1.arl_Active = 1) AND (Int1.arl_PurgeState = 0) AND (Rec2.gie_Active = 1) AND 
<                 (Rec2.gie_PurgeState = 0)
<             /,
<     };
<     $queries{"Failed to send events in last 24 hours"} = {
<         'info' => 'numrows > -1', 
<         'recordMaxResults'  => 40000,
<         'recordItem'        => 'numrows',
<         'format'            => "RootId %s, Created %s, Partition %s, Error %s\n",
<         'sql' => q/
<             SELECT Int1.rootId as rootid, to_char(Int1.alh_TimeCreated, 'YYYY-MM-DD HH24:MI:SS') as time_created, Int1.alh_PartitionNumber as partition_num,
<                 Int3.iei_ErrorMessage as iei_errormsg, 'last_24_hours' as type
<             FROM IntegrationEventLogHistoryTab Int1, GlobalIntegrationErrorTab Rec2, 
<                 IntegrationErrorItemTab Int3 
<             WHERE Int1.alh_ErrorDetails = Rec2.rootId AND Rec2.gie_Items = Int3.lvId AND
<                 Rec2.rootId = Int3.rootId AND (Int1.alh_Status = 'Error' AND
<                 Int1.alh_TimeCreated > sysdate-1 AND
<                 Int3.iei_ErrorMessage LIKE 'Fault received when processing the WS exchange%Couldn''t send message.') AND 
<                 (Int1.alh_Active = 1) AND (Int1.alh_PurgeState = 0) AND (Rec2.gie_Active = 1) AND
<                 (Rec2.gie_PurgeState = 0)
<             /,
<     };
---
> 		'skip' => $skip,
> 		'perl' => sub { main::failedEvents($product) },
> 	};
> 	$queries{"Failed events (test realms)"} = {
> 		'info' => "numrows > -1",
> 		'crit' => 0, # Set in code later
> 		'skip' => $skip,
> 		'perl' => sub { main::failedOther($product) },
> 	};
> 	$queries{"Failed to send events (current)"} = {
> 		'info' => 'numrows > -1', 
> 		'recordMaxResults' 	=> 40000,
> 		'recordItem' 		=> 'numrows',
> 		'format'			=> "RootId %s, Created %s, Partition %s, Error %s\n",
> 		'sql' => q/
> 			SELECT Int1.rootId, to_char(Int1.arl_TimeCreated, 'YYYY-MM-DD HH24:MI:SS'), Int1.arl_PartitionNumber, 
> 				Int3.iei_ErrorMessage 
> 			FROM IntegrationEventLogTab Int1, GlobalIntegrationErrorTab Rec2, 
> 				IntegrationErrorItemTab Int3 
> 			WHERE Int1.arl_ErrorDetails = Rec2.rootId AND Rec2.gie_Items = Int3.lvId AND 
> 				Rec2.rootId = Int3.rootId AND Int1.arl_Status = 'Error' AND 
> 				Int3.iei_ErrorMessage LIKE 'Fault received when processing the WS exchange%Couldn''t send message.' AND 
> 				(Int1.arl_Active = 1) AND (Int1.arl_PurgeState = 0) AND (Rec2.gie_Active = 1) AND 
> 				(Rec2.gie_PurgeState = 0)
> 			/,
> 	};
> 	$queries{"Failed to send events in last 24 hours"} = {
> 		'info' => 'numrows > -1', 
> 		'recordMaxResults' 	=> 40000,
> 		'recordItem' 		=> 'numrows',
> 		'format'			=> "RootId %s, Created %s, Partition %s, Error %s\n",
> 		'sql' => q/
> 			SELECT Int1.rootId, to_char(Int1.alh_TimeCreated, 'YYYY-MM-DD HH24:MI:SS'), Int1.alh_PartitionNumber,
> 				Int3.iei_ErrorMessage 
> 			FROM IntegrationEventLogHistoryTab Int1, GlobalIntegrationErrorTab Rec2, 
> 				IntegrationErrorItemTab Int3 
> 			WHERE Int1.alh_ErrorDetails = Rec2.rootId AND Rec2.gie_Items = Int3.lvId AND
> 				Rec2.rootId = Int3.rootId AND (Int1.alh_Status = 'Error' AND
> 				Int1.alh_TimeCreated > sysdate-1 AND
> 				Int3.iei_ErrorMessage LIKE 'Fault received when processing the WS exchange%Couldn''t send message.') AND 
> 				(Int1.alh_Active = 1) AND (Int1.alh_PurgeState = 0) AND (Rec2.gie_Active = 1) AND
> 				(Rec2.gie_PurgeState = 0)
> 			/,
> 	};
118,119c108
<    
<     $queries{influx_details} = { measurement => "integration_events" };
---
>     
124c113
<     $q->setSQLConnectInfo($product->connectInfoForOracleClient());
---
> 	$q->setSQLConnectInfo($product->connectInfoForOracleClient());
144,145c133,134
<     "SELECT Int1.alh_AdapterName as adaptername,Int1.alh_Status as status,Int2.arl_clienttype as client_type,
<        CASE WHEN Int2.arl_lastqueuedtime IS NOT NULL OR Int2.arl_objectspending > 0 THEN 'PENDING' ELSE 'EXPORT' END as last_queuedtime
---
>     "SELECT Int1.alh_AdapterName,Int1.alh_Status,Int2.arl_clienttype,
>        CASE WHEN Int2.arl_lastqueuedtime IS NOT NULL OR Int2.arl_objectspending > 0 THEN 'PENDING' ELSE 'EXPORT' END 
150c139
<    (SELECT Int101.arl_UniqueName FROM IntegrationEventLogTab Int101 
---
>    (SELECT Int101.arl_UniqueName FROM IntegrationEventLogTab Int101
187c176,177
<             $realms{$r->{ID}} = qq($r->{NAME}\t$r->{COMMUNITYID}\t$r->{RP_REALMTYPE});
---
>             $r =~ /^(\d+)\t(.*)/;
>             $realms{$1} = $2;
223,224c213,214
<     $query->setCrit(1);
<     return ($sqlError);
---
> 	$query->setCrit(1);
> 	return ($sqlError);
236d225
< 
238,241c227
<         my $adapter = $result->{ADAPTERNAME};
<         my $status  = $result->{STATUS};
<         my $cl      = $result->{CLIENT_TYPE};
<         my $kind    = $result->{LAST_QUEUEDTIME};
---
>         my ($adapter, $status, $cl, $kind) = split("\t",$result);
277c263
<     return join(";",@bad);
---
>     return join("\n",@bad);
filename:./bin/common/machine-watcher
241,244d294
<                         inf_field     => "status",
<                         inf_tags      => qq|datacenter=$datacenter,hostname=$hostname,mdbstatus=$status|,
<                         inf_default   => "NA,
<                         group_by      => "$datacenter,$status"
270,271c317
<                 $queries{influx_details} = {measurement => "machine_watcher"};
<                 my $qm = ariba::monitor::QueryManager->newWithDetails($qmName, $pn, $me->service(), $me->customer(), \%queries);
---
>                 $qm = ariba::monitor::QueryManager->newWithDetails($qmName, $pn, $me->service(), $me->customer(), \%queries);
filename:./bin/common/mail-cert-expire
41c41
< 	processCertDir($cert, $certDir, \%queries, $hostname, $datacenter) if ($certDir);
---
> 	processCertDir($cert, $certDir, \%queries, $hostname) if ($certDir);
45,46c45
<         $queries{influx_details} = {measurement => "mail-cert-expire"};
<         my $q  = ariba::monitor::QueryManager->newWithDetails(
---
> 		my $q  = ariba::monitor::QueryManager->newWithDetails(
50c49
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
59d57
<     my $datacenter = shift;
79,81d76
<                 inf_field => "dayToExpire",
<                 inf_tags => qq|datacenter="$datacenter",hostname="$hostname",cert="$file"|,
<                 inf_default => 0,
filename:./bin/common/master-data-service-monitoring
14d13
< use Data::Dumper;
16,17c15
< sub main
< {
---
> sub main {
19,72c17,78
<     GetOptions(
<                'debug|d'        => \$debug,
<                'sendemail|e'    => \$sendEmail,
<                'sendpage|p'     => \$sendPage,
<                'product|prod=s' => \$productName,
<               );
< 
<     my $monProduct = ariba::rc::InstalledProduct->new();
<     my $product    = ariba::rc::InstalledProduct->new($productName, $monProduct->service());
<     my $cluster    = $product->currentCluster() || 'primary';
< 
<     my $adminurl   = $product->default("VendedUrls.AdminFrontDoorTopURL");
<     my @mdsactions = qw(mdsRealmLooperDelay mdsExportDataDelay mdsWorkItemsDelay mdsParentChildNotSync);
<     my $prodname   = $product->name();
<     my $service    = $product->service();
<     my $customer   = $product->customer() || undef;
<     my $email      = $product->default('notify.email');
< 
<     my %queries;
< 
<     my %queryitems = (
<         'mdsRealmLooperDelay' => {
<                                   'qname'     => 'Extract Data Realm Looper Delay ',
<                                   'inf_field' => 'extract_data_realm_looper_delay',
<                                   'description' => q(Informs about delay in Realm Looper task to Extract Data for MDS)
<                                  },
< 
<         'mdsExportDataDelay' => {
<                                  'qname'     => 'Extract Data Delay ',
<                                  'inf_field' => 'extract_data_delay',
<                                  'description' => q(Informs about the delay in processing extract data task at individual realm level.)
<                                 },
< 
<         'mdsWorkItemsDelay' => {
<                                 'qname'     => 'Long Pending Work Items ',
<                                 'inf_field' => 'long_pending_work_items',
<                                 'description' => q(Informs about the work items which are long pending at realm level)
<                                },
< 
<         'mdsParentChildNotSync' => {
<                                     'qname'     => 'Parent Child Inconsistency ',
<                                     'inf_field' => 'parent_child_inconsistency',
<                                     'description' => q(Informs when the parent and child work items are not consistent. Parent is success but there are failures in the child work items)
<                                    }
< 
<                      );
< 
<     foreach my $action (@mdsactions)
<     {
< 
<         my $uri      = $adminurl . '/' . ucfirst ($prodname) . '/Main/ad/' . $action . '/MonitorActions';
<         my $url      = ariba::monitor::Url->new($uri);
<         my $response = $url->request();
< 
---
>     GetOptions  (
>                     'debug|d'         => \$debug,
>                     'sendemail|e'     => \$sendEmail,
>                     'sendpage|p'      => \$sendPage,
>                     'product|prod=s'  => \$productName,
>                 );
> 
>     my $monProduct = ariba::rc::InstalledProduct->new ();
>     my $product = ariba::rc::InstalledProduct->new ($productName, $monProduct->service ());
>     my $cluster = $product->currentCluster () || 'primary';
> 
> 	my $adminurl = $product->default("VendedUrls.AdminFrontDoorTopURL");
> 	my @mdsactions = qw(mdsRealmLooperDelay mdsExportDataDelay mdsWorkItemsDelay mdsParentChildNotSync mdsExtractTaskNotRunning mdsPublishTaskNotRunning);
> 	my $prodname = $product->name();
> 	my $service = $product->service();
> 	my $customer = $product->customer () || undef;
> 	my $email = $product->default ('notify.email');
> 	
> 	my %queries;
> 	
> 	my %queryitems = ( 'mdsRealmLooperDelay'  =>  { 'qname' => 'Extract Data Realm Looper Delay ',
> 	                                                'action' => { 'Ops' => 'Inform Engineering team to investigate.',
> 	                     'Engr' => 'Check if the scheduler is not able to run for the realms or if there is any problem in the app to run the tasks and take corrective action based on the situation.'},
> 	                                                 'description' => q(Informs about delay in Realm Looper task to Extract Data for MDS) },
> 	
> 	                    'mdsExportDataDelay' =>   { 'qname' => 'Extract Data Delay ',
> 	                                                'action' =>  { 'Ops' => 'Inform Engineering team to investigate.',
> 	                                                  'Engr' => 'Check why the extract data is taking so much time. Reasons could be at JVM level,App level or they could be genuine like full load.'}, 
> 	                                                  'description' => q(Informs about the delay in processing extract data task at individual realm level.) },
> 	
> 	                    'mdsWorkItemsDelay' =>    { 'qname' => 'Long Pending Work Items ',
> 	                                                 'action' => {'Ops' => 'Inform Engineering team to investigate.',
> 	'Engr' => 'Check why the work items are pending for a long time. Could be that the arches status is not updated or they are blocked because of something else and take corrective action based on the situation.'},
> 	                                                  'description' => q(Informs about the work items which are long pending at realm level) },
> 	
> 	
> 	                     'mdsParentChildNotSync' => { 'qname' => 'Parent Child Inconsistency ',
> 	                                                   'action' => {'Ops' => 'Inform Engineering team to investigate.',
> 	                                                    'Engr' => 'Check why this is happening and take corrective actions, like data fix to handle the situation.'},
> 	                                              'description' => q(Informs when the parent and child work items are not consistent. Parent is success but there are failures in the child work items) },
> 
> 	                     'mdsExtractTaskNotRunning' => { 'qname' => ' Extract Task Not runnning ',
> 	                                                   'action' => {'Ops' => 'Inform Engineering team to investigate.',
> 	                                                    'Engr' => 'Check why this is happening and take corrective actions, like data fix to handle the situation.'},
> 	                                              'description' => q(Informs when the failed extract task not running) },
> 
> 	                     'mdsPublishTaskNotRunning' => { 'qname' => ' Publish Task Not runnning ',
> 	                                                   'action' => {'Ops' => 'Inform Engineering team to investigate.',
> 	                                                    'Engr' => 'Check why this is happening and take corrective actions, like data fix to handle the situation.'},
> 	                                              'description' => q(Informs when the failed publish task not running) },
> 
> 	
> 	                  );
> 	
> 	foreach my $action(@mdsactions) {
> 	   
> 		$prodname =~s/s4/Sourcing/si;
> 	    my $uri = $adminurl.'/'.ucfirst($prodname).'/Main/ad/'.$action.'/MonitorActions';
> 	    my $url = ariba::monitor::Url->new( $uri ); 
> 	    my $response = $url->request();
> 		print "$url \t $response \n" if($debug);
> 	    
74,144c80,124
<         print "url : $uri \n" if ($debug);
<         my $hoursdelay;
<         my $reccount;
<         my @rec;
<         if ($action eq 'mdsRealmLooperDelay')
<         {
<             if ($response !~ /^No result/i)
<             {
<                 $response =~ m/NO_OF_HOURS\|(.*?)\,/;
<                 $hoursdelay = $1;
<             }
<             else
<             {
<                 $hoursdelay = 0;
<             }
<             print "**hours delay is $hoursdelay\n" if ($debug);
<         }
<         else
<         {
<             if ($response !~ /^No result/i)
<             {
<                 @rec = split ("\n", $response);
<                 $reccount = scalar @rec;
<             }
<             else
<             {
<                 $reccount = 0;
<             }
<             print "**rec count is $reccount\n" if ($debug);
<         }
< 
<         next if ( $reccount && $rec[-1] eq '</html>');
< 
<         $queries{"$queryitems{$action}->{qname}"} = {
<             uiHint            => "$queryitems{$action}->{qname}",
< 
<                                                     };
< 
<         if (defined $hoursdelay)
<         {
<             $queries{"$queryitems{$action}->{qname}"}->{'perl'}        = sub {return "$hoursdelay";};
<             $queries{"$queryitems{$action}->{qname}"}->{'inf_field'}   = ($queryitems{$action}->{inf_field});
<             $queries{"$queryitems{$action}->{qname}"}->{'inf_default'} = 0;
<             $queries{"$queryitems{$action}->{qname}"}->{'warn'}        = "answer >= 2";
<             $queries{"$queryitems{$action}->{qname}"}->{'group_by'}    = "row_1";
<         }
<         elsif (defined $reccount)
<         {
<             #$queries{"$queryitems{$action}->{qname}"}->{'perl'} = sub { return "@rec"; };
<             $queries{"$queryitems{$action}->{qname}"}->{'perl'}        = sub {return "$reccount";};
<             $queries{"$queryitems{$action}->{qname}"}->{'warn'}        = "numrows >= 1";
<             $queries{"$queryitems{$action}->{qname}"}->{'inf_field'}   = ($queryitems{$action}->{inf_field});
<             $queries{"$queryitems{$action}->{qname}"}->{'inf_default'} = 0;
<             $queries{"$queryitems{$action}->{qname}"}->{'group_by'}    = "row_1";
< 
<             my $i = 0;
<             foreach my $line (@rec)
<             {
<                 $queries{"$queryitems{$action}->{qname}.$i"}->{'perl'}       = sub {return lc ($line)};
<                 $queries{"$queryitems{$action}->{qname}.$i"}->{'inf_field'}  = "details",
<                 $queries{"$queryitems{$action}->{qname}.$i"}->{'inf_tags'}   = qq(row_id=$i,type="$queryitems{$action}->{inf_field}"),
<                 $queries{"$queryitems{$action}->{qname}.$i"}->{'group_by'}   = qq($i,$queryitems{$action}->{inf_field}),
<                 $i++;
<             }
< 
<         }
<     }
< 
<     $queries{influx_details} = {measurement => 'mds_monitoring'};
<     my $qm = ariba::monitor::QueryManager->newWithDetails('MDS', $prodname, $service, $customer, \%queries);
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         print "url : $uri \n" if($debug);
> 	     my $hoursdelay;
> 	     my $reccount;
> 	     my @rec;
> 	    if ($action eq 'mdsRealmLooperDelay') {
> 	       if ($response !~ /^No result/i) {
> 	           $response =~ m/NO_OF_HOURS\|(.*?)\,/;
> 	            $hoursdelay = $1;
> 	       } else {
> 	           $hoursdelay = 0; 
> 	       }
> 	         print "**hours delay is $hoursdelay\n" if($debug);
> 	    } else {
> 	       if ($response !~ /^No result/i) {
> 	          @rec = split("\n",$response);
> 	          $reccount = scalar @rec; 
> 	       } else {
> 	          $reccount = 0;
> 	        }
> 	          print "**rec count is $reccount\n" if($debug);
> 	    }
> 	  
> 	              $queries {"$queryitems{$action}->{qname}"} =  {
> 	              correctiveActions => [Ops => "$queryitems{$action}->{action}{Ops}",  Engr => "$queryitems{$action}->{action}{Engr}"],
> 	              description => "$queryitems{$action}->{description}",
> 		      uiHint => "$queryitems{$action}->{qname}",
> 	           };
> 	          
> 	        if(defined $hoursdelay) {
> 	                 $queries{"$queryitems{$action}->{qname}"}->{'perl'} = sub { return "$hoursdelay"; };
> 	                 $queries{"$queryitems{$action}->{qname}"}->{'warn'} = "answer >= 2";
> 	        }elsif(defined $reccount) {
> 			 my @records = map {"$_\n" } @rec;
> 	                 $queries{"$queryitems{$action}->{qname}"}->{'perl'} = sub { return "@records"; };
> 	                 #$queries{"$queryitems{$action}->{qname}"}->{'perl'} = sub { return "$reccount"; };
> 	                 $queries{"$queryitems{$action}->{qname}"}->{'warn'} = "numrows >= 1";
> 	
> 	        }
> 	 
> 	 
> 	}
> 	
> 	
> 	         my $qm = ariba::monitor::QueryManager->newWithDetails('MDS', $prodname, $service, $customer, \%queries);
> 	         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/mem-watcher
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
38,40c38,40
< 	# tmid:161074
< 	my $machineStatsDoc = "https://wiki.ariba.com:8443/display/ENGDPTS/Machinestats";
< 	my $note = "\n<html>For memory issues, see <a href=\"$machineStatsDoc\">$machineStatsDoc</a></html>";
---
>     # tmid:161074
>     my $machineStatsDoc = "https://wiki.ariba.com:8443/display/ENGDPTS/Machinestats";
>     my $note = "\n<html>For memory issues, see <a href=\"$machineStatsDoc\">$machineStatsDoc</a></html>";
173,176d172
< 						inf_field => "processorMemory",
< 						inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$hostname",
189,192d184
< 						inf_field => "processorMemoryFragmentation",
< 						inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$hostname",
209,212d200
< 						inf_field => "IOMemory",
< 						inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$hostname",
225,228d212
< 						inf_field => "IOMemoryFragmentation",
< 						inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$hostname",
235c219
< 								my $warnValue = 75;
---
>                                 my $warnValue = 75;
237c221
< 								my $graphLink = $memQueryName;
---
>                                 my $graphLink = $memQueryName;
239,252c223,232
< 								if (defined ($realValue)) {
< 										$networkQueries{qq!<html><a href="$url">$hostname</a></html> mem!} = {
< 												format => "%d%%\n",
< 												showGraphLink => $graphLink,
< 												info => "answer eq '' or  answer > -1",
< 												warn => "answer eq '' or  answer > $warnValue",
< 												note => $note,
< 												perl => "$realValue",
< 												inf_field => "Memory",
< 												inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 												inf_default => 0,
< 												group_by => "$datacenter,$hostname",
< 										};
< 								}
---
>                                 if (defined ($realValue)) {
>                                         $networkQueries{qq!<html><a href="$url">$hostname</a></html> mem!} = {
>                                                 format => "%d%%\n",
>                                                 showGraphLink => $graphLink,
>                                                 info => "answer eq '' or  answer > -1",
>                                                 warn => "answer eq '' or  answer > $warnValue",
>                                                 note => $note,
>                                                 perl => "$realValue",
>                                         };
>                                 }
270,273d249
< 						inf_field => "Memory",
< 						inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$hostname",
364,375d339
< 			if (defined $queries{qq!<html><a href="$url">$hostname</a></html> mem!}) {
< 				$queries{qq!<html><a href="$url">$hostname</a></html> mem!}{inf_field} = "Memory";
< 				$queries{qq!<html><a href="$url">$hostname</a></html> mem!}{inf_tags} = qq|datacenter="$datacenter",hostname="$hostname"|;
< 				$queries{qq!<html><a href="$url">$hostname</a></html> mem!}{inf_default} = 0;
< 				$queries{qq!<html><a href="$url">$hostname</a></html> mem!}{group_by} = "$datacenter,$hostname";
< 			}
< 			if (defined $queries{qq!<html><a href="$url">$hostname</a></html> swap!}) {
< 				$queries{qq!<html><a href="$url">$hostname</a></html> swap!}{inf_field} = "Swap";
< 				$queries{qq!<html><a href="$url">$hostname</a></html> swap!}{inf_tags} = qq|datacenter="$datacenter",hostname="$hostname"|;
< 				$queries{qq!<html><a href="$url">$hostname</a></html> swap!}{inf_default} = 0;
< 				$queries{qq!<html><a href="$url">$hostname</a></html> swap!}{group_by} = "$datacenter,$hostname";
< 			}
382,383d345
< 
< 		$queries{influx_details} = {measurement => "memory"};
385c347
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
388d349
< 		$networkQueries{influx_details} = {measurement => "network_memory"};
390c351
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/netapp-cluster-status
19,20c19,20
<     my $sendEmail = 0;
<     my $sendPage  = 0;
---
> 	my $sendEmail = 0;
> 	my $sendPage  = 0;
22,26c22,26
<     while (my $arg = shift(@ARGV)) {
<         if ($arg =~ /^-e/o) { $sendEmail = 1; };
<         if ($arg =~ /^-p/o) { $sendPage  = 1; };
<         if ($arg =~ /^-d/o) { $debug     = 1; };
<     }
---
> 	while (my $arg = shift(@ARGV)) {
> 		if ($arg =~ /^-e/o) { $sendEmail = 1; };
> 		if ($arg =~ /^-p/o) { $sendPage  = 1; };
> 		if ($arg =~ /^-d/o) { $debug     = 1; };
> 	}
28,29c28,29
<     my $me    = ariba::rc::InstalledProduct->new();
<     my $email = $me->default('notify.email');
---
> 	my $me    = ariba::rc::InstalledProduct->new();
> 	my $email = $me->default('notify.email');
31c31
<     for my $dataCenter ( ariba::Ops::ProductAPIExtensions::datacentersForProducts($me) ) {
---
> 	for my $dataCenter ( ariba::Ops::ProductAPIExtensions::datacentersForProducts($me) ) {
35c35
<         my $tab = ariba::monitor::StatusPage::fakeProductNameForDatacenter($dataCenter);
---
> 		my $tab = ariba::monitor::StatusPage::fakeProductNameForDatacenter($dataCenter);
37,38c37,38
<         # only monitor primary data center 
<         next unless $tab eq ariba::monitor::StatusPage::commonProduct();
---
> 		# only monitor primary data center 
> 		next unless $tab eq ariba::monitor::StatusPage::commonProduct();
40,123c40,98
<         my %match = (
<                 status         => 'inservice',
<                 datacenter     => $dataCenter,
<                 hardwareVendor => 'netapp',
<                 );
< 
<         my @machines = ariba::Ops::Machine->machinesWithProperties(%match);
<         my %queries  = ();
< 
<         for my $machine (@machines) {
< 
<             my $host = $machine->hostname();
< 
<             $queries{"$host cluster settings"} = {
<                 info => "answer eq 'enabled'",
<                 warn => "answer ne 'enabled' && answer ne 'thisNodeDead'",
<                 crit => "answer eq 'thisNodeDead'",
<                 snmp => "$host, cfSettings.0",
<                 inf_field => "cluterSetting",
<                 inf_tags => qq|datacenter="$dataCenter",hostname="$host"|,
<                 inf_default => 0,
<                 group_by => "$dataCenter,$host",
<             };
< 
<             $queries{"$host cluster state"} = {
<                 info => "answer eq 'canTakeover'",
<                 warn => "answer eq 'takeover' || answer eq 'cannotTakeover' || answer eq 'unknown'",
<                 crit => "answer eq 'dead'",
<                 snmp => "$host, cfState.0",
<                 inf_field => "cluterState",
<                 inf_tags => qq|datacenter="$dataCenter",hostname="$host"|,
<                 inf_default => 0,
<                 group_by => "$dataCenter,$host",
<             };
< 
<             $queries{"$host cluster cannot takeover cause"} = {
<                 info => "answer eq 'ok'",
<                 warn => "answer eq 'disabledByOperator' || answer eq 'interconnectOffline' || 
<                     answer eq 'disabledByPartner' || answer eq 'unknown'",
<                 crit => "answer eq 'takeoverFailed'",
<                 snmp => "$host, cfCannotTakeoverCause.0",
<                 inf_field => "cluterTakeoverFailCause",
<                 inf_tags => qq|datacenter="$dataCenter",hostname="$host"|,
<                 inf_default => 0,
<                 group_by => "$dataCenter,$host",
<             };
< 
<             $queries{"$host cluster partner status"} = {
<                 info => "answer eq 'ok'",
<                 warn => "answer eq 'maybeDown' || answer eq 'unknown'",
<                 crit => "answer eq 'dead'",
<                 snmp => "$host, cfPartnerStatus.0",
<                 inf_field => "cluterPartnerStatus",
<                 inf_tags => qq|datacenter="$dataCenter",hostname="$host"|,
<                 inf_default => 0,
<                 group_by => "$dataCenter,$host",
<             };
< 
<             $queries{"$host cluster partner name"} = {
<                 info => "answer ne 'unknown'",
<                 crit => "answer eq 'unknown'",
<                 snmp => "$host, cfPartnerName.0",
<                 inf_field => "cluterPartnerName",
<                 inf_tags => qq|datacenter="$dataCenter",hostname="$host"|,
<                 inf_default => 0,
<                 group_by => "$dataCenter,$host",
<             };
< 
<             $queries{"$host cluster interconnect status"} = {
<                 info => "answer eq 'up'",
<                 warn => "answer eq 'partialFailure' || answer eq 'notPresent' || answer eq 'unknown'",
<                 crit => "answer eq 'down'",
<                 snmp => "$host, cfInterconnectStatus.0",
<                 inf_field => "cluterInterconnectStatus",
<                 inf_tags => qq|datacenter="$dataCenter",hostname="$host"|,
<                 inf_default => 0,
<                 group_by => "$dataCenter,$host",
<             };
<         }
< 
<         $queries{influx_details} = {measurement => "netapp-cluster-status"};
<         my $qm = ariba::monitor::QueryManager->newWithDetails(
<                 'netapp-cluster-status', $tab, $me->service(), $me->customer(), \%queries
<                 );
---
> 		my %match = (
> 				status         => 'inservice',
> 				datacenter     => $dataCenter,
> 				hardwareVendor => 'netapp',
> 				);
> 
> 		my @machines = ariba::Ops::Machine->machinesWithProperties(%match);
> 		my %queries  = ();
> 
> 		for my $machine (@machines) {
> 
> 			my $host = $machine->hostname();
> 
> 			$queries{"$host cluster settings"} = {
> 				info => "answer eq 'enabled'",
> 				warn => "answer ne 'enabled' && answer ne 'thisNodeDead'",
> 				crit => "answer eq 'thisNodeDead'",
> 				snmp => "$host, cfSettings.0",
> 			};
> 
> 			$queries{"$host cluster state"} = {
> 				info => "answer eq 'canTakeover'",
> 				warn => "answer eq 'takeover' || answer eq 'cannotTakeover' || answer eq 'unknown'",
> 				crit => "answer eq 'dead'",
> 				snmp => "$host, cfState.0",
> 			};
> 
> 			$queries{"$host cluster cannot takeover cause"} = {
> 				info => "answer eq 'ok'",
> 				warn => "answer eq 'disabledByOperator' || answer eq 'interconnectOffline' || 
> 					answer eq 'disabledByPartner' || answer eq 'unknown'",
> 				crit => "answer eq 'takeoverFailed'",
> 				snmp => "$host, cfCannotTakeoverCause.0",
> 			};
> 
> 			$queries{"$host cluster partner status"} = {
> 				info => "answer eq 'ok'",
> 				warn => "answer eq 'maybeDown' || answer eq 'unknown'",
> 				crit => "answer eq 'dead'",
> 				snmp => "$host, cfPartnerStatus.0",
> 			};
> 
> 			$queries{"$host cluster partner name"} = {
> 				info => "answer ne 'unknown'",
> 				crit => "answer eq 'unknown'",
> 				snmp => "$host, cfPartnerName.0",
> 			};
> 
> 			$queries{"$host cluster interconnect status"} = {
> 				info => "answer eq 'up'",
> 				warn => "answer eq 'partialFailure' || answer eq 'notPresent' || answer eq 'unknown'",
> 				crit => "answer eq 'down'",
> 				snmp => "$host, cfInterconnectStatus.0",
> 			};
> 		}
> 
> 		my $qm = ariba::monitor::QueryManager->newWithDetails(
> 				'netapp-cluster-status', $tab, $me->service(), $me->customer(), \%queries
> 				);
125,126c100,101
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
<     }
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
> 	}
filename:./bin/common/netapp-domain
104,107d103
<                                 inf_field => "$label",
<                                 inf_tags => "hostname=$host,instant=$instance_name1",
<                                 inf_default => 0,
<                                 group_by => "$dataCenter,$host,$instance_name1",
114d109
<     $queries{influx_details} = {measurement => "netapp-domain"};
117c112
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/netapp-latency
153,156d152
< 				inf_field => "$metric",
< 				inf_tags => qq|datacenter="$dataCenter",hostname="$host",volumeName="$volume_name"|,
< 				inf_default => 0,
< 				group_by => "$dataCenter,$host,$volume_name",
162d157
< 	$queries{influx_details} = {measurement => "netapp-latency"};
165c160
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/node-health
114c114
<                 my $status = join(";", @{$down{$community}->{$appName}});
---
>                 my $status = join("\n", @{$down{$community}->{$appName}});
131,134d130
<                                         inf_field   => "instances_down",
<                                         inf_default => "none",
<                                         inf_tags    => qq(type="$appName",community="$community"),
<                                         group_by    => qq($appName,$community),
139d134
<         $queries{influx_details} = { measurement => "node_health" };
143c138
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
148,149d142
< 
< 
filename:./bin/common/numa-status
52,55d51
<                         inf_field => "numa_policy",
<                         inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$hostname",
75,78d70
<             inf_field => "absolute_free_memory",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$node"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$node",
88,91d79
<             inf_field => "free_memory",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$node"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$node",
128,131d115
<             inf_field => "numa_hit",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$nodeName"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$nodeName",
140,143d123
<             inf_field => "numa_miss",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$nodeName"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$nodeName",
152,155d131
<             inf_field => "interleave_hit",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$nodeName"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$nodeName",
164,167d139
<             inf_field => "local_node",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$nodeName"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$nodeName",
176,179d147
<             inf_field => "other_node",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",node="$nodeName"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$nodeName",
184d151
<         $queries{influx_details} = {measurement => "redhat_db_status"};
192c159
<                 my $ret = $q->processQueries($debug, 'an_auto_sysadmin@ariba.com', 1, 0);
---
>                 my $ret = $q->processQueriesUsingServer($debug, 'an_auto_sysadmin@ariba.com', 1, 0);
filename:./bin/common/persisted-mail-queue
19,71c19,71
<     my $debug = 0;
<     my $quiet = 0;
<     my $sendEmail = 0;
<     my $sendPage = 0;
<     my $productName;
< 
<     while(my $arg=shift(@ARGV)){
<             print STDERR "parsing arg $arg\n" if $debug && !$quiet;
<             if($arg =~ /^-d/o){ $debug=1; }
<             if($arg =~ /^-e/o){ $sendEmail=1; };
<             if($arg =~ /^-p$/o){ $sendPage=1; };
<             if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
<     my $email = $me->default('notify.email');
< 
<     my @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
< 
<     unless (@products) {
<         exit(0);
<     }
< 
<     for my $product (@products) {
< 
<         my $lockfile = "/tmp/stratus-persisted-mail-queue";
<         $lockfile .= "-" . $product->name();
<         $lockfile .= "-" . $product->customer() if($product->customer());
<         if (!dmail::LockLib::requestlock($lockfile,5)) {
<             print STDERR "can't grab lock $lockfile\n";
<             next;
<         }
< 
<         my $skip = 0;
< 
<         my %queries  = ();
< 
<         my $outage;
< 
<         # remove this outage once 10s2 is released
<         # See TMID 86123
<         # $outage = ariba::monitor::OutageSchedule->new('daily 00:00-02:00');
< 
<         my $mailQueueWarn = 5000;
<         my $mailQueueCrit = 10000;
< 
<         # Different thresholds for Buyer, tmid: 181715
<         if ($productName eq 'buyer') {
<             $mailQueueWarn = 30000;
<             $mailQueueCrit = 50000;
<         }
---
> 	my $debug = 0;
> 	my $quiet = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while(my $arg=shift(@ARGV)){
> 			print STDERR "parsing arg $arg\n" if $debug && !$quiet;
> 			if($arg =~ /^-d/o){ $debug=1; }
> 			if($arg =~ /^-e/o){ $sendEmail=1; };
> 			if($arg =~ /^-p$/o){ $sendPage=1; };
> 			if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 	my $email = $me->default('notify.email');
> 
> 	my @products = ariba::rc::InstalledProduct->installedProductsList($service, $productName);
> 
> 	unless (@products) {
> 		exit(0);
> 	}
> 
> 	for my $product (@products) {
> 
> 		my $lockfile = "/tmp/persisted-mail-queue";
> 		$lockfile .= "-" . $product->name();
> 		$lockfile .= "-" . $product->customer() if($product->customer());
> 		if (!dmail::LockLib::requestlock($lockfile,5)) {
> 			print STDERR "can't grab lock $lockfile\n";
> 			next;
> 		}
> 
> 		my $skip = 0;
> 
> 		my %queries  = ();
> 
> 		my $outage;
> 
> 		# remove this outage once 10s2 is released
> 		# See TMID 86123
> 		# $outage = ariba::monitor::OutageSchedule->new('daily 00:00-02:00');
> 
> 		my $mailQueueWarn = 5000;
> 		my $mailQueueCrit = 10000;
> 
> 		# Different thresholds for Buyer, tmid: 181715
> 		if ($productName eq 'buyer') {
> 			$mailQueueWarn = 30000;
> 			$mailQueueCrit = 50000;
> 		}
86,137c86,136
<         my $persistedMailQueueSql = "SELECT COUNT(Dur1.rootId) as count FROM DurableEmailTab Dur1 WHERE (Dur1.dem_Active = 1) AND (Dur1.dem_PurgeState = 0)";
<         #FIXME
<         # remove this after everyone is on 10s1 or greater
<         my $releaseName = $product->isASPProduct() ? $product->baseReleaseName() : $product->releaseName();
<         unless ($releaseName =~ /^9/) {
<             $persistedMailQueueSql .= " AND (Dur1.dem_SentStatus = 0)";
<         }
<         
<         if (grep /^$productName$/, (ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts())) {
<             $persistedMailQueueSql .= " AND (Dur1.dem_RetryCount < 96)";
<         }
< 
<         my @schemaIds = ariba::Ops::ProductAPIExtensions::transactionSchemaIdsForProduct($product);
<         my $aggregationMethod = (scalar(@schemaIds) > 1 ? "counts" : undef);
< 
<         # tmid: 156019
<         # We want to display only number for emails that are to be sent and not composing emails.
<         $persistedMailQueueSql .= " AND (DEM_ProcessingNode IS NULL OR DEM_ProcessingNode not like 'Composing%')";
< 
<             $queries{"Persisted mail queue length"} = {
<                 'recordMaxResults' => 110000,
<                 'recordDataType' => "gauge",
<                 'aggregationMethod' => $aggregationMethod,
<                 'outageSchedule' => $outage,
<                 'info' => "!defined(answer) || answer >= 0",
<                 'warn' => "defined(answer) && answer >= $mailQueueWarn",
<                 'crit' => "defined(answer) && answer >= $mailQueueCrit && previousAnswer >= $mailQueueCrit",
<                 'timeout' => 10 * 60,
<                 'sql'  => $persistedMailQueueSql,
<                 'runForSchemaIds' => join(", ", @schemaIds),
<             };
< 
<         $queries{influx_details } = { measurement => 'persisted_mail_queue' };
<         my $q = ariba::monitor::QueryManager->newWithDetails(
<                 "persisted-mail-queue", $product->name(), $service, $product->customer(), \%queries
<         );
< 
<         #
<         # set a sane default -- if we don't have sub schemas, this needs to
<         # get set to something because...
<         #
<         my $defaultDbc=ariba::Ops::DBConnection->connectionsForProductOfDBType(
<                         $product, ariba::Ops::DBConnection::typeMain()
<         );
<         $q->setSQLConnectInfoFromDBConnection( $defaultDbc );
< 
<         #
<         # this call only sets overrides for individual schemas, and misses a
<         # default that is not numbered
<         #
<         ariba::Ops::ProductAPIExtensions::setTransactionSchemaSQLConnectInfoOnQueryManager($product, $q);
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		my $persistedMailQueueSql = "SELECT COUNT(Dur1.rootId) FROM DurableEmailTab Dur1 WHERE (Dur1.dem_Active = 1) AND (Dur1.dem_PurgeState = 0)";
> 		#FIXME
> 		# remove this after everyone is on 10s1 or greater
> 		my $releaseName = $product->isASPProduct() ? $product->baseReleaseName() : $product->releaseName();
> 		unless ($releaseName =~ /^9/) {
> 			$persistedMailQueueSql .= " AND (Dur1.dem_SentStatus = 0)";
> 		}
> 		
> 		if (grep /^$productName$/, (ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts())) {
> 			$persistedMailQueueSql .= " AND (Dur1.dem_RetryCount < 96)";
> 		}
> 
> 		my @schemaIds = ariba::Ops::ProductAPIExtensions::transactionSchemaIdsForProduct($product);
> 		my $aggregationMethod = (scalar(@schemaIds) > 1 ? "counts" : undef);
> 
> 		# tmid: 156019
> 		# We want to display only number for emails that are to be sent and not composing emails.
> 		$persistedMailQueueSql .= " AND (DEM_ProcessingNode IS NULL OR DEM_ProcessingNode not like 'Composing%')";
> 
> 		$queries{"Persisted mail queue length"} = {
> 			'recordMaxResults' => 110000,
> 			'recordDataType' => "gauge",
> 			'aggregationMethod' => $aggregationMethod,
> 			'runForSchemaIds' => join(", ", @schemaIds),
> 			'outageSchedule' => $outage,
> 			'info' => "!defined(answer) || answer >= 0",
> 			'warn' => "defined(answer) && answer >= $mailQueueWarn",
> 			'crit' => "defined(answer) && answer >= $mailQueueCrit && previousAnswer >= $mailQueueCrit",
> 			'timeout' => 10 * 60,
> 			'sql'  => $persistedMailQueueSql,
> 		};
> 
> 		my $q = ariba::monitor::QueryManager->newWithDetails(
> 				"persisted-mail-queue", $product->name(), $service, $product->customer(), \%queries
> 		);
> 
> 		#
> 		# set a sane default -- if we don't have sub schemas, this needs to
> 		# get set to something because...
> 		#
> 		my $defaultDbc=ariba::Ops::DBConnection->connectionsForProductOfDBType(
> 						$product, ariba::Ops::DBConnection::typeMain()
> 		);
> 		$q->setSQLConnectInfoFromDBConnection( $defaultDbc );
> 
> 		#
> 		# this call only sets overrides for individual schemas, and misses a
> 		# default that is not numbered
> 		#
> 		ariba::Ops::ProductAPIExtensions::setTransactionSchemaSQLConnectInfoOnQueryManager($product, $q);
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
139,140c138,139
<         dmail::LockLib::releaselock($lockfile);
<     }
---
> 		dmail::LockLib::releaselock($lockfile);
> 	}
144d142
< 
filename:./bin/common/persistent-queue
21,183c21,140
< sub main
< {
<     my $sendEmail = 0;
<     my $sendPage  = 0;
<     my $productName;
< 
<     my %queries = ();
< 
<     while (my $arg = shift (@ARGV))
<     {
<         print STDERR "parsing arg $arg\n" if $debug;
<         if ($arg =~ /^-d/o)    {$debug       = 1;}
<         if ($arg =~ /^-e/o)    {$sendEmail   = 1;}
<         if ($arg =~ /^-p$/o)   {$sendPage    = 1;}
<         if ($arg =~ /^-prod/o) {$productName = shift (@ARGV);}
<     }
< 
<     my $me      = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
< 
<     unless (ariba::rc::InstalledProduct->isInstalled($productName, $service))
<     {
<         exit (0);
<     }
< 
<     my $product = ariba::rc::InstalledProduct->new($productName, $service);
< 
<     for my $instance ($product->appInstancesWithNameInCluster("Manager", $cluster))
<     {
< 
<         my $instanceName  = $instance->instanceName();
<         my $persistentUrl = $instance->persistentQueueURL();
< 
<         print "checking node: $instanceName\n" if ($debug);
< 
<         my ($error, $xp) = processUrl($persistentUrl);
<         $error = -1 if ( $error );
< 
<         my $queueStatusSet = $xp->find('//queueStatus') unless $error;
< 
<         my $oldWarn    = 6 * 60 * 60;
<         my $oldCrit    = 12 * 60 * 60;
<         my $oldWarnIPQ = 30 * 60;
<         my $oldCritIPQ = 60 * 60;
< 
<         $queries{"dead letter status errors"} = {
<                                                  noRowCount    => 1,
<                                                  format        => "%s\n",
<                                                  warn          => "answer > 5",
<                                                  crit          => "answer > 10",
<                                                  error         => $error,
<                                                  noCritOnError => 1,
<                                                  url           => $persistentUrl,
<                                                  perl          => sub {return ($error || deadLetterStatus($xp));},
<                                                  inf_field     => "dead_letter_status",
<                                                  inf_default   => 0,
<                                                  inf_tags      => qq(type="summary"),
<                                                  group_by      => "summary",
<                                                 };
< 
<         unless ($error)
<         {
< 
<             foreach my $node ($queueStatusSet->get_nodelist)
<             {
<                 my $rcvErrors        = $node->getAttribute('rcvErrors');
<                 my $confirmErrors    = $node->getAttribute('confirmErrors');
<                 my $rollbackErrors   = $node->getAttribute('rollbackErrors');
<                 my $newCount         = $node->getAttribute('newCount');
<                 my $pendingCount     = $node->getAttribute('pendingCount');
<                 my $longPendingCount = $node->getAttribute('longPendingCount');
<                 my $oldest           = ($node->getAttribute('oldest')) / 1000;
<                 my $name             = $node->getAttribute('name');
< 
<                 if ($name =~ m/PortletFetchWork$/)
<                 {
<                     my $portletFetchWorkValue = 'normal';
<                     if (($pendingCount > 0) && ($oldest > 10 * 60))
<                     {
<                         $portletFetchWorkValue = 'super long running';
<                     }
<                     elsif (($newCount > 0) || ($pendingCount > 0))
<                     {
<                         $portletFetchWorkValue = 'long running';
<                     }
< 
<                     $queries{"$name Aysnc portlet fetch status"} = {
<                                                                     noRowCount  => 1,
<                                                                     severity    => 2,
<                                                                     format      => "%s</td><td></td><td>",
<                                                                     warn        => "answer eq 'long running'",
<                                                                     crit        => "answer eq 'super long running'",
<                                                                     uiHint      => "queue status",
<                                                                     perl        => sub {return $portletFetchWorkValue},
<                                                                     inf_field   => "aysnc_portlet_fetch_status",
<                                                                     inf_default => "none",
<                                                                     inf_tags    => qq(type="$name"),
<                                                                     group_by    => $name,
<                                                                    };
<                 }
< 
<                 my $queueStatusCount = $rcvErrors + $confirmErrors + $rollbackErrors;
< 
<                 # We don't want to crit on anything but ScheduleTasksWork, tmid: 143507
<                 # We don't want to page for ScheduleTasksWork, just Tow. tmid: 145672
<                 my $warnValue = undef;
<                 my $critValue = undef;
<                 if ($name =~ m/ScheduleTasksWork$/)
<                 {
<                     $warnValue = "answer >= 1000 or $oldest >= $oldCrit or $longPendingCount > 0";
<                 }
<                 if ($name =~ m/IPQ:/)
<                 {
<                     $warnValue = "answer >= 1000 or $oldest >= $oldWarnIPQ or $longPendingCount > 0";
<                     $critValue = "answer >= 1000 or $oldest >= $oldCritIPQ or $longPendingCount > 0";
<                 }
< 
<                 $queries{"$name errors"} = {
<                                             noRowCount                   => 1,
<                                             format                       => "%s</td><td>long pending:</td><td>$longPendingCount</td><td>oldest:</td><td>scaleTime($oldest)",
<                                             warn                         => $warnValue,
<                                             crit                         => $critValue,
<                                             ticketOnWarnOpenAfterMinutes => 1,
<                                             uiHint                       => "queue status",
<                                             correctiveActions            => [
<                                                                   Ops  => 'Open S2 CR for Engineering',
<                                                                   Engr => 'The corrective action is rollback the stuck message (which can be done via DF or by recycling the task nodes in the community named in the queue that has the problem.)',
<                                                                  ],
<                                             perl        => sub {return $queueStatusCount},
<                                             inf_field   => "errors",
<                                             inf_default => 0,
<                                             inf_tags    => qq(type="$name"),
<                                             group_by    => $name,
<                                            };
<                 $queries{"$name long_pending"} = {
<                                                   warn        => $warnValue,
<                                                   crit        => $critValue,
<                                                   perl        => sub {return $longPendingCount},
<                                                   inf_field   => "long_pending",
<                                                   inf_default => 0,
<                                                   inf_tags    => qq(type="$name"),
<                                                   group_by    => $name,
<                                                  };
<                 $queries{"$name oldest"} = {
<                                             warn        => $warnValue,
<                                             crit        => $critValue,
<                                             perl        => sub {return ($oldest);},
<                                             inf_field   => "oldest",
<                                             inf_default => 0,
<                                             inf_tags    => qq(type="$name"),
<                                             group_by    => $name,
<                                            };
<             }
<             last;
<         }
<     }
< 
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = {measurement => "persistent_queue"};
<     my $qm = ariba::monitor::QueryManager->newWithDetails("persistent-queue", $product->name(), $service, $product->customer(), \%queries);
< 
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> sub main {
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	my %queries = ();
> 
> 	while(my $arg=shift(@ARGV)) {
> 		print STDERR "parsing arg $arg\n" if $debug;
> 		if($arg =~ /^-d/o) { $debug = 1; }
> 		if($arg =~ /^-e/o) { $sendEmail = 1; };
> 		if($arg =~ /^-p$/o) { $sendPage = 1; };
> 		if($arg =~ /^-prod/o) { $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 
> 	unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
> 		exit(0);
> 	}
> 
> 	my $product = ariba::rc::InstalledProduct->new($productName, $service);
> 
> 	for my $instance ($product->appInstancesWithNameInCluster("Manager", $cluster)) {
> 
> 		my $instanceName = $instance->instanceName();
> 		my $persistentUrl = $instance->persistentQueueURL();
> 
> 		print "checking node: $instanceName\n" if ($debug);
> 
> 		my ($error, $xp) = processUrl($persistentUrl);
> 
> 		my $queueStatusSet = $xp->find('//queueStatus') unless $error;
> 
> 		my $oldWarn = 6*60*60;
> 		my $oldCrit = 12*60*60;
> 		my $oldWarnIPQ = 30*60;
> 		my $oldCritIPQ = 60*60;
> 
> 		$queries{"dead letter status errors"} = {
> 			noRowCount    => 1,
> 			format        => "%s\n",
> 			warn          => "answer > 5",
> 			crit          => "answer > 10",
> 			error         => $error,
> 			noCritOnError => 1,
> 			url           => $persistentUrl,
> 			perl       => sub { return ($error || deadLetterStatus($xp)); }
> 		};
> 
> 		unless ($error) {
> 
> 			foreach my $node ($queueStatusSet->get_nodelist) {
> 				my $rcvErrors =  $node->getAttribute('rcvErrors');
> 				my $confirmErrors = $node->getAttribute('confirmErrors');
> 				my $rollbackErrors = $node->getAttribute('rollbackErrors');
> 				my $newCount = $node->getAttribute('newCount');
> 				my $pendingCount = $node->getAttribute('pendingCount');
> 		    my $longPendingCount = $node->getAttribute('longPendingCount');
> 				my $oldest = ($node->getAttribute('oldest')) / 1000;
> 				my $name = $node->getAttribute('name');
> 
> 				if ($name =~ m/PortletFetchWork$/) {
> 					my $portletFetchWorkValue = 'normal';
> 					if (($pendingCount > 0) && ($oldest > 10*60)) {
> 						$portletFetchWorkValue = 'super long running'; 
> 					} elsif (($newCount > 0) || ($pendingCount > 0)) {
> 						$portletFetchWorkValue = 'long running';
> 					};
> 
> 					$queries{"$name Aysnc portlet fetch status"} = {
> 						noRowCount => 1,
> 						severity   => 2,
> 						format     => "%s</td><td></td><td>",
> 						warn       => "answer eq 'long running'",
> 						crit       => "answer eq 'super long running'",
> 						uiHint     => "queue status",
> 						perl       => sub { return $portletFetchWorkValue },
> 					};
> 				};
> 
> 				my $queueStatusCount = $rcvErrors + $confirmErrors + $rollbackErrors;
> 
> 				# We don't want to crit on anything but ScheduleTasksWork, tmid: 143507
> 				# We don't want to page for ScheduleTasksWork, just Tow. tmid: 145672
> 				my $warnValue = undef;
> 				my $critValue = undef;
> 				if ($name =~ m/ScheduleTasksWork$/) {
> 					$warnValue = "answer >= 1000 or $oldest >= $oldCrit or $longPendingCount > 0";
> 				}
> 				if ($name =~ m/IPQ:/) {
> 					$warnValue = "answer >= 1000 or $oldest >= $oldWarnIPQ or $longPendingCount > 0";
> 					$critValue = "answer >= 1000 or $oldest >= $oldCritIPQ or $longPendingCount > 0";
> 				}
> 
> 				$queries{"$name errors"} = {
> 					noRowCount => 1,
> 					format     => "%s</td><td>long pending:</td><td>$longPendingCount</td><td>oldest:</td><td>scaleTime($oldest)",
> 					warn       => $warnValue,
> 					crit       => $critValue,
> 					ticketOnWarnOpenAfterMinutes => 1,
> 					uiHint     => "queue status",
> 					correctiveActions => [
> 						Ops => 'Open S2 CR for Engineering',
> 						Engr => 'The corrective action is rollback the stuck message (which can be done via DF or by recycling the task nodes in the community named in the queue that has the problem.)',
> 					],
> 					perl       => sub { return $queueStatusCount },
> 				};
> 			}
> 			last;
> 		}
> 	}
> 
> 	my $email = $me->default('notify.email');
> 
> 	my $qm = ariba::monitor::QueryManager->newWithDetails(
> 		"persistent-queue", $product->name(), $service, $product->customer(), \%queries
> 	);
184a142
> 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
232,233c190
< sub processUrl
< {
---
> sub processUrl {
235,265c192,218
<     my $persistentUrl = shift;
<     my $xp;
<     my $eMessage;
< 
<     my $persistentStatus = ariba::monitor::Url->new($persistentUrl);
<     $persistentStatus->setUseOutOfBandErrors(1);
< 
<     if (defined $persistentStatus->error())
<     {
<         $eMessage = "ERROR: $persistentStatus->error()\n";
< 
<         return ($eMessage, $xp);
<     }
<     my $timeout   = 180;
<     my $xmlString = $persistentStatus->request($timeout);
<     $xp = XML::XPath->new(xml => $xmlString);
< 
<     eval {
<         my $parseThis = new XML::Parser;
<         $parseThis->parse($xmlString);
<     };
< 
<     if ($@)
<     {
<         $eMessage = "ERROR: XML Parsing failed\n";
<     }
<     else
<     {
<         $eMessage = "ERROR: Invalid xml data as queueStatus is missing: $xmlString\n"      unless ($xmlString =~ m/queueStatus/);
<         $eMessage = "ERROR: Invalid xml data as deadLetterStatus is missing: $xmlString\n" unless ($xmlString =~ m/deadLetterStatus/);
<     }
---
> 	my $persistentUrl = shift;
> 	my $xp;
> 	my $eMessage;
> 	
> 	my $persistentStatus = ariba::monitor::Url->new($persistentUrl);
> 	$persistentStatus->setUseOutOfBandErrors(1);
> 
> 	if (defined $persistentStatus->error()) {
> 		$eMessage = "ERROR: $persistentStatus->error()\n";
> 
> 		return ($eMessage, $xp);
> 	} 
>         my $timeout = 180;
> 	my $xmlString = $persistentStatus->request($timeout);
> 	$xp = XML::XPath->new(xml => $xmlString);
> 
> 	eval {
> 		my $parseThis = new XML::Parser;
> 		$parseThis->parse($xmlString);
> 	};
> 	
> 	if ($@) {
> 		$eMessage = "ERROR: XML Parsing failed\n";
> 	} else {
> 		$eMessage = "ERROR: Invalid xml data as queueStatus is missing: $xmlString\n"  unless ($xmlString =~ m/queueStatus/);
> 		$eMessage = "ERROR: Invalid xml data as deadLetterStatus is missing: $xmlString\n"  unless ($xmlString =~ m/deadLetterStatus/);
> 	}
267c220
<     print "$eMessage\n" if $debug && $eMessage;
---
> 	print "$eMessage\n" if $debug && $eMessage;
269c222
<     return ($eMessage, $xp);
---
> 	return ($eMessage, $xp);
272,273c225
< sub deadLetterStatus
< {
---
> sub deadLetterStatus {
275c227
<     my $xp = shift;
---
> 	my $xp = shift;
277,281c229,233
<     my $rcvErrors      = int ($xp->findvalue('//deadLetterStatus/@rcvErrors'));
<     my $confirmErrors  = int ($xp->findvalue('//deadLetterStatus/@confirmErrors'));
<     my $pendingCount   = int ($xp->findvalue('//deadLetterStatus/@pendingCount'));
<     my $newCount       = int ($xp->findvalue('//deadLetterStatus/@newCount'));
<     my $rollbackErrors = int ($xp->findvalue('//deadLetterStatus/@rollbackErrors'));
---
> 	my $rcvErrors = int($xp->findvalue('//deadLetterStatus/@rcvErrors'));
> 	my $confirmErrors = int($xp->findvalue('//deadLetterStatus/@confirmErrors'));
> 	my $pendingCount = int($xp->findvalue('//deadLetterStatus/@pendingCount'));
> 	my $newCount = int($xp->findvalue('//deadLetterStatus/@newCount'));
> 	my $rollbackErrors = int($xp->findvalue('//deadLetterStatus/@rollbackErrors'));
283c235
<     my $deadLetterStatusCount = $rcvErrors + $confirmErrors + $pendingCount + $newCount + $rollbackErrors;
---
> 	my $deadLetterStatusCount = $rcvErrors + $confirmErrors + $pendingCount + $newCount + $rollbackErrors;
285c237
<     return $deadLetterStatusCount;
---
> 	return $deadLetterStatusCount;
filename:./bin/common/physical-dataguard-gap-delay
6c6
< #
---
> # 
22,23c22,23
< my $debug               = 0;
< my $dataguardSQLTimeout = 6 * 60;    # in seconds. gap delay SQL takes a long time.
---
> my $debug = 0;
> my $dataguardSQLTimeout = 6 * 60; # in seconds. gap delay SQL takes a long time.
25c25
< my $me = ariba::rc::InstalledProduct->new();
---
> my $me	          = ariba::rc::InstalledProduct->new();
27,28c27,28
< my $sysUser = "sys";
< my $sysPass = $me->default("dbainfo.$sysUser.password");
---
> my $sysUser       = "sys";
> my $sysPass       = $me->default("dbainfo.$sysUser.password");
30,178c30,152
< sub main
< {
<     my $sendEmail = 0;
<     my $sendPage  = 0;
< 
<     my ($array, @productNames);
< 
<     while (my $arg = shift (@ARGV))
<     {
<         if ($arg =~ /^-prod/o) {$array     = \@productNames; next;}
<         if ($arg =~ /^-e/o)    {$sendEmail = 1;              next;}
<         if ($arg =~ /^-p/o)    {$sendPage  = 1;              next;}
<         if ($arg =~ /^-d/o) {$debug++; next;}
<         if ($arg !~ /^-/o) {push (@$array, $arg); next;}
<     }
< 
<     my @products = ();
< 
<     if (@productNames)
<     {
<         for my $productName (@productNames)
<         {
<             push (@products, ariba::rc::InstalledProduct->installedProductsList($me->service(), $productName));
<         }
<     }
< 
<     exit (0) unless (@products);
< 
<     my @dbconnections = ariba::Ops::DBConnection->connectionsFromProducts(@products);
<     #
<     # Check to see if this product is physical DR'ed at all
<     #
<     my $isDRed = 0;
<     for my $dbc (@dbconnections)
<     {
<         if ($dbc->isDR() && $dbc->isPhysicalReplication())
<         {
<             $isDRed = 1;
<             last;
<         }
<     }
< 
<     exit (0) unless ($isDRed);
< 
<     ## Run against the physical DR hosts
<     for my $dbc (ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbconnections))
<     {
< 
<         next unless ($dbc->isDR() && $dbc->isPhysicalReplication());
< 
<         my %drQueries;
<         my $virtualHost = $dbc->host();
<         my $instance    = uc ($dbc->sid());
< 
<         my $product     = $dbc->product();
<         my $productName = $product->name();
<         my $email       = $me->default('notify.email');
< 
<         my $replicationType = "Physical DataGuard";
< 
<         my ($peerDbc) = $dbc->peers();
<         if ($peerDbc)
<         {
<             my $error;
<             my $drLowSequenceSQL = 'select low_sequence# from v$archive_gap';
<             my $drLowSequenceNumber;
<             my $gapDelay;
< 
<             my @results = ();
<             my $oc = ariba::Ops::OracleClient->new($sysUser, $sysPass, $instance, $virtualHost);
<             if (!connectToOracleAndRunSQL($oc, $drLowSequenceSQL, \@results))
<             {
<                 $error ||= $oc->error() || "Error: " . $results[0];
<             }
<             else
<             {
<                 $drLowSequenceNumber = $results[0];
< 
<                 if ($drLowSequenceNumber)
<                 {
<                     my $peerLogFileSql = "select name from v\$archived_log where sequence#=$drLowSequenceNumber and dest_id=1";
<                     my $peerLogFileName;
<                     my $peerInstance    = uc ($peerDbc->sid());
<                     my $peerVirtualHost = $peerDbc->host();
<                     my $peerOc          = ariba::Ops::OracleClient->new($sysUser, $sysPass, $peerInstance, $peerVirtualHost);
<                     @results = ();
<                     if (!connectToOracleAndRunSQL($peerOc, $peerLogFileSql, \@results))
<                     {
<                         $error ||= $oc->error() || "Error: " . $results[0];
<                     }
<                     else
<                     {
<                         $peerLogFileName = $results[0];
< 
<                         if ($peerLogFileName)
<                         {
<                             my $cipherStore = ariba::rc::CipherStore->new($me->service());
<                             my $monUser     = ariba::rc::Globals::deploymentUser($me->name(), $me->service());
<                             my $monPass     = $cipherStore->valueForName($monUser);
<                             my $ssh         = ariba::rc::Utils::sshCmd();
<                             my $cmd         = "$ssh $monUser\@$peerVirtualHost stat --format '%Y' '$peerLogFileName'";
< 
<                             my @output;
<                             if (executeRemoteCommand($cmd, $monPass, 0, undef, undef, \@output))
<                             {
<                                 my $output = join ('', @output);
<                                 if ($output =~ /^\s*(\d+)\s*$/)
<                                 {
<                                     my $logFileTime = $1;
<                                     $gapDelay = time () - $logFileTime;
<                                 }
<                                 else
<                                 {
<                                     $error = "Modified time stat of '$peerLogFileName' on $peerVirtualHost returned non-numeric result: $output";
<                                 }
<                             }
<                             else
<                             {
<                                 $error = "Failed to stat '$peerLogFileName' on $peerVirtualHost: $!";
<                             }
<                         }
<                         else
<                         {
<                             $error = "Failed to find log file name with sql: $peerLogFileSql";
<                         }
<                     }
<                 }
<             }
< 
<             $drQueries{"$replicationType gap delay for [$instance] on $virtualHost"} = {
<                                                                                         info             => 1,
<                                                                                         warn             => 0,                                                      # displays error as warn
<                                                                                         error            => $error,
<                                                                                         format           => 'scaleTime(answer)',
<                                                                                         recordMaxResults => 20000,
<                                                                                         recordDataUnits  => "seconds",
<                                                                                         perl             => sub {return $error || $gapDelay;},
<                                                                                         inf_field        => "status",
<                                                                                         inf_tags         => qq(instance="$instance",virtual_host="$virtualHost"),
<                                                                                         inf_default      => "none",
<                                                                                         group_by         => qq($instance,$virtualHost),
<                                                                                        };
<         }
< 
<         $drQueries{influx_details} = {measurement => 'physical_dataguard_gap_delay'};
<         my $qm = ariba::monitor::QueryManager->newWithDetails("dataguard-status", $productName, $me->service(), undef, \%drQueries);
<         $qm->setSQLConnectInfo($sysUser, $sysPass, $instance, $virtualHost);
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
<     }
---
> sub main {
> 	my $sendEmail = 0;
> 	my $sendPage  = 0;
> 
> 	my ($array, @productNames);
> 
> 	while (my $arg = shift(@ARGV)) {
> 		if ($arg =~ /^-prod/o) { $array = \@productNames; next; };
> 		if ($arg =~ /^-e/o) { $sendEmail = 1; next; };
> 		if ($arg =~ /^-p/o) { $sendPage = 1; next; };
> 		if ($arg =~ /^-d/o) { $debug++; next; };
> 		if ($arg !~ /^-/o ) { push(@$array, $arg); next; };
> 	}
> 
> 
> 	my @products      = ();
> 
> 	if (@productNames) {
> 		for my $productName (@productNames) {
> 			push(@products, ariba::rc::InstalledProduct->installedProductsList($me->service(), $productName));
> 		}
> 	}
> 
> 	exit (0) unless(@products);
> 
> 	my @dbconnections = ariba::Ops::DBConnection->connectionsFromProducts(@products);
> 	#
> 	# Check to see if this product is physical DR'ed at all
> 	#
> 	my $isDRed = 0;
> 	for my $dbc (@dbconnections) {
> 		if ($dbc->isDR() && $dbc->isPhysicalReplication()) {
> 			$isDRed = 1;
> 			last;
> 		}
> 	}
> 
> 	exit (0) unless ($isDRed);
> 
> 	## Run against the physical DR hosts
> 	for my $dbc (ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbconnections)) {
> 
> 		next unless ($dbc->isDR() && $dbc->isPhysicalReplication());
> 
> 		my %drQueries;
> 		my $virtualHost = $dbc->host();
> 		my $instance    = uc($dbc->sid());
> 
> 		my $product     = $dbc->product();
> 		my $productName = $product->name();
> 		my $email = $me->default('notify.email');
> 
> 		my $replicationType = "Physical DataGuard";
> 
> 		my ($peerDbc) = $dbc->peers();
> 		if ($peerDbc) {
> 			my $error;
> 			my $drLowSequenceSQL = 'select low_sequence# from v$archive_gap';
> 			my $drLowSequenceNumber;
> 			my $gapDelay;
> 
> 			my @results = ();
> 			my $oc = ariba::Ops::OracleClient->new($sysUser, $sysPass, $instance, $virtualHost);
> 			if (!connectToOracleAndRunSQL($oc, $drLowSequenceSQL, \@results)) {
> 				$error ||= $oc->error() || "Error: ". $results[0];
> 			} else {
> 				$drLowSequenceNumber = $results[0];
> 
> 				if ($drLowSequenceNumber) { 
> 					my $peerLogFileSql = "select name from v\$archived_log where sequence#=$drLowSequenceNumber and dest_id=1";
> 					my $peerLogFileName;
> 					my $peerInstance = uc($peerDbc->sid());
> 					my $peerVirtualHost = $peerDbc->host(); 
> 					my $peerOc = ariba::Ops::OracleClient->new($sysUser, $sysPass, $peerInstance, $peerVirtualHost);
> 					@results = ();
> 					if (!connectToOracleAndRunSQL($peerOc, $peerLogFileSql, \@results)) {
> 						$error ||= $oc->error() || "Error: ". $results[0];
> 					} else {
> 						$peerLogFileName = $results[0];
> 
> 						if ($peerLogFileName) { 
> 							my $cipherStore = ariba::rc::CipherStore->new($me->service());
> 							my $monUser = ariba::rc::Globals::deploymentUser($me->name(), $me->service());
> 							my $monPass = $cipherStore->valueForName($monUser);
> 							my $ssh = ariba::rc::Utils::sshCmd(); 
> 							my $cmd = "$ssh $monUser\@$peerVirtualHost stat --format '%Y' '$peerLogFileName'";
> 
> 							my @output;
> 							if (executeRemoteCommand($cmd, $monPass, 0, undef, undef, \@output)) { 
> 								my $output = join('', @output);
> 								if ($output =~ /^\s*(\d+)\s*$/) { 
> 									my $logFileTime = $1;
> 									$gapDelay = time() - $logFileTime;
> 								} else {
> 									$error = "Modified time stat of '$peerLogFileName' on $peerVirtualHost returned non-numeric result: $output";
> 								}
> 							} else {
> 								$error = "Failed to stat '$peerLogFileName' on $peerVirtualHost: $!";
> 							}
> 						} else { 
> 							$error = "Failed to find log file name with sql: $peerLogFileSql";
> 						}
> 					}
> 				}
> 			}
> 
> 			$drQueries{"$replicationType gap delay for [$instance] on $virtualHost"} = {
> 				info 				=> 1, 
> 				warn				=> 0,	# displays error as warn
> 				error 				=> $error,
> 				format 				=> 'scaleTime(answer)',
> 				recordMaxResults	=> 20000,
> 				recordDataUnits		=> "seconds",
> 				perl 				=> sub { return $error || $gapDelay; }
> 			};
> 		}
> 
> 		my $qm = ariba::monitor::QueryManager->newWithDetails(
> 			"dataguard-status", $productName, $me->service(), undef, \%drQueries
> 		);
> 		$qm->setSQLConnectInfo($sysUser, $sysPass, $instance, $virtualHost);
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
> 	}
182,183c156
< sub connectToOracleAndRunSQL
< {
---
> sub connectToOracleAndRunSQL {
185,197c158,169
<     my $oc         = shift;
<     my $sql        = shift;
<     my $resultsRef = shift;
< 
<     $oc->connect(20, 4);
<     if (   $oc->error()
<         || !$oc->executeSqlWithTimeout($sql, $dataguardSQLTimeout, $resultsRef)
<         || $oc->error())
<     {
<         $$resultsRef[0] ||= "Oracle Error: " . $oc->error();
<         return 0;
<     }
<     $oc->disconnect();    # Need this to close connection ASAP to avoid conflict with bcv backup.
---
> 	my $oc         = shift;
> 	my $sql        = shift;
> 	my $resultsRef = shift;
> 
> 	$oc->connect(20, 4);
> 	if ($oc->error() || 
> 		!$oc->executeSqlWithTimeout($sql, $dataguardSQLTimeout, $resultsRef) || 
> 		$oc->error()) {
> 		$$resultsRef[0] ||= "Oracle Error: " . $oc->error();
> 		return 0;
> 	}
> 	$oc->disconnect(); # Need this to close connection ASAP to avoid conflict with bcv backup.
199c171
<     return 1;
---
> 	return 1;
206d177
< 
filename:./bin/common/query-frequency
89,94d88
<     my %NamesOfQueries =  ('Updating Power Graphs Per Second (Frequency)' => powerGraph, 
<                           'Number of Processed Power Graphs File' => processedPowerGraphs,
<                           'Number of Processed Queries File' => processedQueries,
<                           'Unable to Read PowerGraph Files' => errorPowerGraph, 
<                           'Updating Queries Per Second (Frequency)' => queryFreq,
<                           'Unable to Read Query Files' => errorQuery );
98c92
<         my $query_name = $NamesOfQueries{$query};
---
>   
114,115d107
<             inf_field => "frequency",
<             inf_tags => "query_name=\"$query_name\"",
122,123d113
<     $queries{influx_details} = {measurement => "query_frequency"};
< 
filename:./bin/common/scheduled-tasks
17d16
< use Data::Dumper;
76a76
> 
133c133
<             my @tasks_in_error_state = main::displayTaskDetails($scheduledTasksDetails, $errorTasks,"tasks_in_error_state");
---
> 
140,160c140
<                 'perl' => sub { return scalar(@tasks_in_error_state) },
<                 inf_field => "tasks_in_error_state_count",
<                 inf_default => 0,
<                 inf_tags  => qq(community="$inCommunity"),
<                 group_by => $inCommunity,
<             };
<         
<             foreach my $line(@tasks_in_error_state)
<             {
<                 my ($p1, $p2 ) = split(/\s+/,$line,2);
<                 my @fields = split(/\,/,$p2);
<                 foreach my $field ( @fields )
<                 {
<                     my ($key,$val) = split(/=/,$field);
<                     $queries{"Tasks in error state$inCommunity - $p1 $key"} = {
<                         perl => sub { return $val},
<                         inf_field => $key,
<                         inf_tags  => qq($p1,community="$inCommunity"),
<                         group_by => qq($p1,$inCommunity),
<                     };
<                 };
---
>                 'perl' => sub { main::displayTaskDetails($scheduledTasksDetails, $errorTasks) },
162,163c142
<             
<             my @stuck_tasks = main::displayTaskDetails($scheduledTasksDetails, $stuckTasks,"tasks_in_stuck_state");
---
> 
171,175c150
<                 'perl' => sub { return scalar(@stuck_tasks) },
<                 inf_field => "tasks_in_stuck_state_count",
<                 inf_default => 0,
<                 inf_tags  => qq(community="$inCommunity"),
<                 group_by => $inCommunity,
---
>                 'perl' => sub { main::displayTaskDetails($scheduledTasksDetails, $stuckTasks) },
178,194d152
<             foreach my $line(@stuck_tasks)
<             {
<                 my ($p1, $p2 ) = split(/\s+/,$line,2);
<                 my @fields = split(/\,/,$p2);
<                 foreach my $field ( @fields )
<                 {
<                     my ($key,$val) = split(/=/,$field);
<                     $queries{"Tasks that did not run as expected $inCommunity - $p1 $key"} = {
<                         perl => sub { return $val},
<                         inf_field => $key,
<                         inf_tags  => qq($p1,community="$inCommunity"),
<                         group_by => qq($p1,$inCommunity),
<                     };
<                 };
<             };
<             
<             my @running_too_long = main::displayTaskDetails($scheduledTasksDetails, $runningTooLongTasks,"tasks_running_too_long");
202,206c160
<                 'perl' => sub { return scalar(@running_too_long) },
<                 inf_field => "tasks_running_too_long_count",
<                 inf_default => 0,
<                 inf_tags  => qq(community="$inCommunity"),
<                 group_by => $inCommunity,
---
>                 'perl' => sub { main::displayTaskDetails($scheduledTasksDetails, $runningTooLongTasks) },
209,225d162
<             foreach my $line(@running_too_long)
<             {
<                 my ($p1, $p2 ) = split(/\s+/,$line,2);
<                 my @fields = split(/\,/,$p2);
<                 foreach my $field ( @fields )
<                 {
<                     my ($key,$val) = split(/=/,$field);
<                     $queries{"Tasks that are running for longer than expected $inCommunity - $p1 $key"} = {
<                         perl => sub { return $val},
<                         inf_field => $key,
<                         inf_tags  => qq($p1,community="$inCommunity"),
<                         group_by => qq($p1,$inCommunity),
<                     };
<                 };
<             };
<             
<             my @success = main::displayTaskDetails($scheduledTasksDetails, $healthyTasks,"successful_tasks");
231,235c168
<                 'perl' => sub { return scalar(@success) },
<                 inf_field => "successful_tasks_count",
<                 inf_default => 0,
<                 inf_tags  => qq(community="$inCommunity"),
<                 group_by => $inCommunity,
---
>                 'perl' => sub { main::displayTaskDetails($scheduledTasksDetails, $healthyTasks) },
238,252d170
<             foreach my $line(@success)
<             {
<                 my ($p1, $p2 ) = split(/\s+/,$line,2);
<                 my @fields = split(/\,/,$p2);
<                 foreach my $field ( @fields )
<                 {
<                     my ($key,$val) = split(/=/,$field);
<                     $queries{"Tasks that were successful $inCommunity - $p1 $key"} = {
<                         perl => sub { return $val},
<                         inf_field => $key,
<                         inf_tags  => qq($p1,community="$inCommunity"),
<                         group_by => qq($p1,$inCommunity),
<                     };
<                 };
<             };
280,281c198
<         my $inf_field = qq(tasks_ran_longer_than_).$threshold. qq(_min);
<         my @tasks_ran_longer_than_th = main::parseTasksRuntimeDetails(\@tasksRanLongerThanThresholdResults,$inf_field);
---
> 
286,303c203
<             'perl' => sub { return scalar(@tasks_ran_longer_than_th); },
<             inf_field => $inf_field,
<             inf_default => 0,
<         };
<         foreach my $line(@tasks_ran_longer_than_th)
<         {
<             my ($p1, $p2 ) = split(/\s+/,$line,2);
<             my @fields = split(/\,/,$p2);
<             foreach my $field ( @fields )
<             {
<                 my ($key,$val) = split(/=/,$field);
<                 $queries{"Tasks that ran for longer than $threshold mins - $p1 $key"} = {
<                     perl => sub { return $val},
<                     inf_field => $key,
<                     inf_tags  => qq($p1),
<                     group_by => qq($p1),
<                 };
<             };
---
>             'perl' => sub { main::parseTasksRuntimeDetails(\@tasksRanLongerThanThresholdResults) },
314,315c214
<         $inf_field = "tasks_running_longer_than_".$threshold. "_min";
<         my @tasks_running_longer_than_th =  main::parseTasksRuntimeDetails(\@tasksRunningLongerThanThresholdResults,$inf_field);
---
> 
322,339c221
<             'perl' => sub { return scalar(@tasks_running_longer_than_th); },
<             inf_field => $inf_field,
<             inf_default => 0,
<         };
<         foreach my $line(@tasks_running_longer_than_th)
<         {
<             my ($p1, $p2 ) = split(/\s+/,$line,2);
<             my @fields = split(/\,/,$p2);
<             foreach my $field ( @fields )
<             {
<                 my ($key,$val) = split(/=/,$field);
<                 $queries{"Tasks that are running for longer than $threshold mins - $p1 $key"} = {
<                     perl => sub { return $val},
<                     inf_field => $key,
<                     inf_tags  => qq($p1),
<                     group_by => qq($p1),
<                 };
<             };
---
>             'perl' => sub { main::parseTasksRuntimeDetails(\@tasksRunningLongerThanThresholdResults) },
342d223
<         my @critical_tasks = main::parseCriticalTasksRuntimeDetails(\@tasksRunningLongerThanThresholdResults);
348,350c229
<             'perl' => sub { return scalar(@critical_tasks);},
<             inf_field => "critical_tasks_running_longer_than_".$threshold. "_min",
<             inf_default => 0,
---
>             'perl' => sub { main::parseCriticalTasksRuntimeDetails(\@tasksRunningLongerThanThresholdResults) },
356,371d234
<         foreach my $line(@critical_tasks)
<         {
<             my ($p1, $p2 ) = split(/\s+/,$line,2);
<             my @fields = split(/\,/,$p2);
<             foreach my $field ( @fields )
<             {
<                 my ($key,$val) = split(/=/,$field);
<                 $queries{"Critical tasks that are running for longer than $threshold mins - $p1 $key"} = {
<                     perl => sub { return $val},
<                     inf_field => $key,
<                     inf_tags  => qq($p1),
<                     group_by => qq($p1),
<                 };
<             };
<         };
< 
385d247
<         my @pull_tasks = main::parsePullTasksRuntimeDetails(\@pullTasksRunningLongerThanThresholdResults);
388a251
>             'perl' => sub { main::parsePullTasksRuntimeDetails(\@pullTasksRunningLongerThanThresholdResults) },
390,407d252
<             'perl' => sub { return scalar(@pull_tasks); },
<             inf_field => "pull_tasks_running_longer_than_".$pullTaskThreshold. "_min",
<             inf_default => 0,
<         };
<         foreach my $line(@pull_tasks)
<         {
<             my ($p1, $p2 ) = split(/\s+/,$line,2);
<             my @fields = split(/\,/,$p2);
<             foreach my $field ( @fields )
<             {
<                 my ($key,$val) = split(/=/,$field);
<                 $queries{"Pull tasks that are running for longer than $threshold mins - $p1 $key"} = {
<                     perl => sub { return $val},
<                     inf_field => $key,
<                     inf_tags  => qq($p1),
<                     group_by => qq($p1),
<                 };
<             };
409a255
> 
420c266
<                     SELECT COUNT(*) as count FROM StagedReceiptLineItemTab Sta1
---
>                     SELECT COUNT(*) FROM StagedReceiptLineItemTab Sta1
429d274
<         $queries{influx_details} = { measurement => 'scheduled_tasks' };
695d539
<     my $type = shift;
700,703c544,547
<         my $startTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{StartTime}) || "none";
<         my $endTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{EndTime}) || "none";
<         my $lastTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{LastScheduledTime}) || "none";
<         my $nextTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{NextScheduledTime}) || "none";
---
>         my $startTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{StartTime});
>         my $endTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{EndTime});
>         my $lastTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{LastScheduledTime});
>         my $nextTime = ariba::Ops::DateTime::prettyTime($scheduledTasksDetails->{$key}->{NextScheduledTime});
716c560
<         push(@results, qq(type="$type",name="$key" status=$prettyStatus,start=$startTime,end=$endTime,last=$lastTime,next=$nextTime));
---
>         push(@results, "$key: status = $prettyStatus, start = $startTime, end = $endTime, last = $lastTime, next = $nextTime");
718c562,563
<     return (@results);
---
> 
>     return (join("\n", @results));
742d586
<     my $type = shift;
750c594
<             push(@output, qq(type="$type",scheduler="$scheduler",name="$taskName" duration=$duration));
---
>             push(@output, "$scheduler\t$taskName\t$duration");
754c598
<     return (@output);
---
>     return (join("\n", @output));
768c612
<                 push(@output, qq(type="critical_tasks",scheduler="$scheduler",name="$taskName" duration=$duration));
---
>                 push(@output, "$scheduler\t$taskName\t$duration");
773c617
<     return (@output);
---
>     return (join("\n", @output));
786c630
<                 push(@output, qq(type="pull_tasks",scheduler="$scheduler",name="$taskName" duration=$duration));
---
>                 push(@output, "$scheduler\t$taskName\t$duration");
791c635
<     return (@output);
---
>     return (join("\n", @output));
filename:./bin/common/sendmail-queue
86,87d85
<     my $queueSize = main::messagesInQueue('$mailServer') - main::ebMessagesInQueue('$mailServer');
< 
98,102c96
< 		perl => "return $queueSize",
<         inf_field => "queueSize",
<         inf_tags => qq|datacenter="$datacenter",mailServer="$mailServer"|,
<         inf_default => 0,
<         group_by => "$datacenter,$mailServer",
---
> 		perl => "main::getSortedQWithTimeout('$mailServer', $maxDisplayedItems, $timeout)",
105,106d98
<     $queries{influx_details} = {measurement => "sorted-sendmail-queue"};
< 
117c109
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage, $monserver);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage, $monserver);
filename:./bin/common/sendmail-status
70,74c70
< 		perl    => "return $sendmailLogParser->errorCount()",
<         inf_field => "errorCount",
<         inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
<         inf_default => 0,
<         group_by => "$datacenter,$hostname",
---
> 		perl    => "$perlcode",
76,86d71
<     $queries{"$hostname maillog warnings"} = {
<         uiHint  => 'Maillog Errors',
<         info    => "numrows > -1",
<         crit    => $sendmailLogParser->errorCount() > 0,
<         warn    => $sendmailLogParser->warningCount() > 0,
<         perl    => "return $sendmailLogParser->warningCount()",
<         inf_field => "warningCount",
<         inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
<         inf_default => 0,
<         group_by => "$datacenter,$hostname",
<     };
90d74
<     $queries{influx_details} = {measurement => "Sendmail-Status"};
95c79
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage, $monserver);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage, $monserver);
filename:./bin/common/state-of-machine-db
79,82c79,80
<                 my @machinesUnusedAndInService = machinesUnusedAndInService(\@machinesFromMdb);
<                 foreach my $m (@machinesUnusedAndInService)
<                 {
< 		    $queries{"Machines unused and in service: $m"} = {
---
> 
> 		$queries{"Machines unused and in service"} = {
84,93c82,85
< 			perl => sub {return 'UnusedAndInService'},
<                         inf_field => "machine_status",
<                         inf_tags => "machine_name=\"$m\"",
< 		    };
<                 }
<                 
<                 my @machinesUsedAndNotInService = machinesUsedAndNotInService(\@machinesFromMdb);
<                 foreach my $n (@machinesUsedAndNotInService)
<                 {
< 		    $queries{"Machines used and not inservice: $n"} = {
---
> 			perl => sub { main::machinesUnusedAndInService(\@machinesFromMdb);},
> 		};
> 
> 		$queries{"Machines used and not inservice"} = {
95,101c87,89
< 			crit => "answer eq 'UsedAndNotInService'",
< 			perl => sub {return 'UsedAndNotInService'},
<                         inf_field => "machine_status",
<                         inf_tags => "machine_name=\"$n\"",
< 		    };
<                 }
< 		my $pn = ariba::monitor::StatusPage::fakeProductNameForDatacenter($datacenter);
---
> 			crit => "answer",
> 			perl => sub { main::machinesUsedAndNotInService(\@machinesFromMdb);},
> 		};
103c91,92
<                 $queries{influx_details} = {measurement => "state_of_machine_db"};	
---
> 		my $pn = ariba::monitor::StatusPage::fakeProductNameForDatacenter($datacenter);
> 	
108c97
< 		$qm->processQueries($debug, $me->default('notify.email'), $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $me->default('notify.email'), $sendEmail, $sendPage);
140c129
< 	return @listOfMachinesReturned;
---
> 	return join("\n", @listOfMachinesReturned);
filename:./bin/common/veritas-disk-state
24,27c24,27
< 	-e	Enables sending of email for monitor query.
< 	-p	Enables sending of pages for monitor query.
< 	-d	Turns on debug mode. 
< 	-h	Shows this help.
---
> 	-e    Enables sending of email for monitor query.
> 	-p    Enables sending of pages for monitor query.
> 	-d    Turns on debug mode. 
> 	-h    Shows this help.
161,164d160
< 			inf_fields => "${type}DiskState",
< 			inf_tags => qq|datacenter="$datacenter",hostname="$hostname",metricDescription="non-active disk volumes and plexes",service="$service"|,
< 			inf_default => "none",
< 			group_by => "$hostname,$service",
170d165
< 	$queries{influx_details} = {measurement => "veritas-disk-state"};
172c167
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/veritas-failover-node-state
57d56
<                         $queries{influx_details} = {measurement => "veritas_cluster_status"};
59c58
< 			$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 			$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
90,91d88
<                                 'inf_field' => "active_3par_VVs_not_imported",
<                                 'inf_tags' => "SID=\"$dbSid\",primary=\"$primaryDBCClusterHost\",failover=\"$failoverDBCClusterHost\"",
161c158
<         $queries{influx_details} = {measurement => "veritas_cluster_status"};
---
> 
163c160
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/dba/alert-log
102,103c102
< 			#perl    => sub {return join("\n", @result); },
< 			perl    => sub {return scalar (@result); },
---
> 			perl    => sub {return join("\n", @result); },
105,108d103
<             inf_field => "instanceCount",
<             inf_tags => "datacenter=\"$datacenter\",hostname=\"$hostname\",instance=\"$instance\",uihint=\"alert-log\"",
<             inf_default => 0,
<             group_by => "$datacenter",
113d107
<         queries{"influx_details"} = {measurement => "dba"}; 
118c112
< 		$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/dba/check-oracle-version
58c58
< 	recordOracleVersions($me, $tab, $hostname, $debug, $datacenter);
---
> 	recordOracleVersions($me, $tab, $hostname, $debug);
67d66
<     my $datacenter = shift;
87,90d85
<             inf_field => "OracleVersion",
<             inf_tags => qq|datacenter="$datacenter",uiHint="version/$hostname",hostname="$hostname",sid="$sid"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname",
97d91
<     $q->{"influx_details"} = {measurement => "dba"};
filename:./bin/dba/listener-log
98,100d97
<                         inf_field => "connection_attempt",
<                         inf_tags => qq|sid="$sid",hostname="$hostname"|,
<                         group_by => "$sid-$hostname",
108,110d104
<                         inf_field => "max_connection_attempt_per_second",
<                         inf_tags => qq|sid="$sid",hostname="$hostname"|,
<                         group_by => "$sid-$hostname",
114c108
<                 $queries{influx_details} = {measurement => "dba"};
---
> 
119c113
< 		$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/dba/listener-status
105,108d104
<             'inf_field' => "listernerStatus",
<             'inf_tags' => "datacenter=\"$datacenter\",hostname=\"$hostname\",uihint=\"listener-status\"",
<             'inf_default' => 0,
<             'group_by' => "listener-status",
118,121d113
<                 'inf_field' => "listernerStatus",
<                 'inf_tags' => "datacenter=\"$datacenter\",hostname=\"$hostname\",uihint=\"listener-status\"",
<                 'inf_default' => 0,
<                 'group_by' => "DR-listener-status",
129d120
<     queries{'influx_details'} = {measurement => "dba"};
134c125
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/dba/memory
108,111d107
<         "inf_field" => "totalPhysicalMemory",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
120,123d115
<         "inf_field" => "totalSharedMemory",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
132,135d123
<         "inf_field" => "SharedToPhysicalRatio",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
144,147d131
<         "inf_field" => "SGAAvailable",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
155,158d138
<         "inf_field" => "SGAUsed",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
167,170d146
<         "inf_field" => "HugePagesUsed",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
178,182c154
< 		'recordMaxResults' => 110000,
<         "inf_field" => "totalUsedPGA",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",	
---
> 		'recordMaxResults' => 110000,	
191,194d162
<         "inf_field" => "percentHugePages",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname",
202,205d169
<         "inf_field" => "NumberofSids",
<         "inf_tags"  => "datacenter=\"$datacenter\",uihint=\"memory/$hostname/sga details\",hostname=\"$hostname\"",
<         "default"   => 0,
<         "group_by"  => "$datacenter,memory/$hostname/sga details",
208d171
<     queries{influx_details} = {measurement => "dba"};
filename:./bin/dba/oracle-version
88,91d87
<                 "inf_field"     => "DBVersion",
<                 "inf_tags"      => "datacenter=\"$datacenter\",productName=\"$productName\",uiHint=\"version\"",
<                 "inf_default"   => 0,
<                 "group_by"      => "$datacenter,$productName",
95d90
<     $queries{"influx_details"} = {measurement => "dba"};
filename:./bin/dba/stats-job-status
130,131c130
< 					#perl => sub { return $rojo; },
< 					perl => sub { return $crit_flag; },
---
> 					perl => sub { return $rojo; },
133,136d131
<                     inf_field => "statsJobStatus",
<                     inf_tags => "datacenter=\"$datacenter\",productName=\"$prodname\",uihint=\"Stats/$prodname/$sid\"",
<                     inf_default => 0,
<                     group_by => "$datacenter,Stats/$prodname/$sid",
146d140
<     queries{influx_details} = {measurement => dba"};
filename:./bin/ebs/ebs-database
38,42c38,40
<       crit        => 'answer eq "\"false\""',
<       perl        => "return qq($answer)",
<       inf_field   => "ebs_points_to_bou_db",
<       inf_default => "none",
<     };
---
> 	  crit => 'answer eq "false"',
> 	  perl => "return qq($answer)",
> 	};
44d41
<     $queries{'influx_details'} = {measurement => 'ebs_database'};
47c44
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/ebs/filesys-queue-status
43d42
<           inf_field => "processing_stuck",
53d51
<           inf_field => "queued_stuck",
57d54
<     $queries{'influx_details'} = {measurement => 'ebs_queue_status'};
60c57
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
109c106
<     ( @jobs ) ?  return (join("\n", @jobs)) : qq("0");
---
> 	return (join("\n", @jobs));
filename:./bin/everywhere/check-omniback-result
44d43
<     my $datacenter = $machine->datacenter();
262,263c261
<             #perl => sub { main::queryMessages($status, $lastThree, $archStr, $ctlBackup, $written, $driveStr, $slotStr, $sessionId, $DBID, $startTime, $queue, $duration, $nextSchedule, $jobNameType, $mirrored) },   
<             perl => sub { return $backupResult},   
---
>             perl => sub { main::queryMessages($status, $lastThree, $archStr, $ctlBackup, $written, $driveStr, $slotStr, $sessionId, $DBID, $startTime, $queue, $duration, $nextSchedule, $jobNameType, $mirrored) },   
265,268d262
<             inf_field => "backupResult",
<             inf_tags => "datacenter=\"$datacenter\",sid=\"$sid\",uiHint=\"rman-backup-session-status/$sid\",jobName=\"$jobName\"",
<             inf_default => 0,
<             group_by => "rman-backup-session-status/$sid",
279,283d272
<             inf_field => "productLevelBackupResult",
<             inf_tags => "datacenter=\"$datacenter\",sid=\"$sid\",uiHint=\"product-level-backup-status\",jobName=\"$jobName-Summary\"",
<             inf_default => 0,
<             group_by => "product-level-backup-status",
< 
296,297c285
<     $queries{influx_details} = {measurement => "dba"};
<     my $result = $qm->processQueries($debug, $to, $sendEmail, $sendPage, $server);
---
>     my $result = $qm->processQueriesUsingServer($debug, $to, $sendEmail, $sendPage, $server);
300,313c288,301
< #    if (!$debug && $backupResult eq 'Failed') {
< #        # Send out a separate notificationRequest with more data from omnirpt
< #        my $subject = "Backup failed for: $jobName";
< #
< #        my $notificationRequest = ariba::Ops::NotificationRequest->newWarn(
< #            $progName, $product, $service, $customer, undef, $subject, $fullReport, $to
< #        );
< #
< #        $notificationRequest->setDebug($debug);
< #        $result |= !$notificationRequest->send();
< #        # send() will return non-zero value for success, but we are using
< #        # $result as an exit() value so take the inverse of what send returns
< #    }
< #
---
>     if (!$debug && $backupResult eq 'Failed') {
>         # Send out a separate notificationRequest with more data from omnirpt
>         my $subject = "Backup failed for: $jobName";
> 
>         my $notificationRequest = ariba::Ops::NotificationRequest->newWarn(
>             $progName, $product, $service, $customer, undef, $subject, $fullReport, $to
>         );
> 
>         $notificationRequest->setDebug($debug);
>         $result |= !$notificationRequest->send();
>         # send() will return non-zero value for success, but we are using
>         # $result as an exit() value so take the inverse of what send returns
>     }
> 
filename:./bin/everywhere/diskstats-watcher
202,205d201
<                         "inf_field" => "MBRead",
<                         "inf_tags" => qq|datacenter="$datacenter",hostname="$hostname",volume="$volumeShort"|,
<                         "inf_default" => 0,
<                         "group_by" => "$datacenter,$hostname,$volumeShort",
226,229d221
<                         "inf_field" => "MBWritten",
<                         "inf_tags" => qq|datacenter="$datacenter",hostname="$hostname",volume="$volumeShort"|,
<                         "inf_default" => 0,
<                         "group_by" => "$datacenter,$hostname,$volumeShort",
239d230
<         $queries{influx_details} = {measurement => "diskstats-watcher"};
242c233
< 		$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/everywhere/iostat-data
125c125
< 		iostat($interval, $iterations, $sendEmail, $sendPage, $hostname,$datacenter);
---
> 		iostat($interval, $iterations, $sendEmail, $sendPage, $hostname);
140d139
<     my $datacenter = shift;
368,371d366
<                     inf_field => "dataValue",
<                     inf_tags => qq|dataDescription="$dataField",datacenter="$datacenter"|,
<                     group_by => "$datacenter,$uiHint",
<                     inf_default => 0,
383d377
<         $queries{influx_details} = {measurement => "iostat-data"};
filename:./bin/everywhere/monitor-clamav-definitions-status
84d83
<     my $dataCenter = $machine->monitoringDatacenter() || $machine->datacenter();
136,139d134
<         inf_field => "ClamAVVirusDef",
<         inf_tags => "uihint=\"$hostname/ClamAV Virus Definitions\",datacenter=\"$dataCenter\"",
<         inf_default => 0,
<         group_by => "$hostname,$dataCenter",
147a143
>     my $dataCenter = $machine->monitoringDatacenter() || $machine->datacenter();
154d149
<     queries{influx_details} = {measurement => "ClamAVStatus"};
159c154
<     $q->processQueries($debug, ariba::Ops::Constants->operationsEmailNotificationAddress(), $sendEmail, $sendPage, $server);
---
>     $q->processQueriesUsingServer($debug, ariba::Ops::Constants->operationsEmailNotificationAddress(), $sendEmail, $sendPage, $server);
filename:./bin/everywhere/monitor-clamav-processes-always
47d46
<     my $dataCenter = $machine->monitoringDatacenter() || $machine->datacenter();
67,70d65
<             inf_field => "status",
<             inf_tags => "uihint=\"$hostname/Processes\",datacenter=\"$dataCenter\"",
<             inf_default => 0,
<             group_by => "$hostname/Processes,$dataCenter",
104,107d98
<             inf_field => "IOWait",
<             inf_tags => "uihint=\"$hostname/IO Wait\",datacenter=\"$dataCenter\"",
<             inf_default => 0,
<             group_by => "$hostname/IO Wait,$dataCenter",
136,139d126
<             inf_field => "NetworkIOTotal",
<             inf_tags => "uihint=\"$hostname/Network IO/$descr\",datacenter=\"$dataCenter\"",
<             inf_default => 0,
<             group_by => "$hostname/Network IO/$descr,$dataCenter",
147,150d133
<             inf_field => "NetwokIOinbound",
<             inf_tags => "uihint=\"$hostname/Network IO/$descr\",datacenter=\"$dataCenter\"",
<             inf_default => 0,
<             group_by => "$hostname/Network IO/$descr,$dataCenter",
158,161d140
<             inf_field => "NetworkIOoutbound",
<             inf_tags => "uihint=\"$hostname/Network IO/$descr\",datacenter=\"$dataCenter\"",
<             inf_default => 0,
<             group_by => "$hostname/Network IO/$descr,$dataCenter",
172a152
>     my $dataCenter = $machine->monitoringDatacenter() || $machine->datacenter();
179d158
<     queries{influx_details} = {measurement => "ClamAVStatus"};
184c163
<     $q->processQueries($debug, ariba::Ops::Constants->operationsEmailNotificationAddress(), $sendEmail, $sendPage, $server);
---
>     $q->processQueriesUsingServer($debug, ariba::Ops::Constants->operationsEmailNotificationAddress(), $sendEmail, $sendPage, $server);
filename:./bin/everywhere/monitor-safeguard
99,102d98
<                 inf_field => "activationTime",
<                 inf_tags => qq|datacenter="$datacenter",masterAccount="$masterAccount"|,
<                 inf_default => 0,
<                 group_by => "$datacenter,$masterAccount",
104,105c100
< 	
<             $queries{influx_details} = {measurement => "Safeguard"};
---
> 		
110c105
< 			$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 			$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage, $monServer);
filename:./bin/everywhere/per-cpu-usage
48d47
<     my $hostType;
52d50
<         $hostType = "Database";
55d52
<         $hostType = "Other";
82,85d78
<             inf_field => "totalCounter",
<             inf_tags => qq|datacenter="$datacenter",hostType="ignore",hostname="$hostname",cpuid=$cpuid|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$cpuid,ignore",
92,95d84
<             inf_field => "usageCounter",
<             inf_tags => qq|datacenter="$datacenter",hostType="ignore",hostname="$hostname",cpuid=$cpuid|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$cpuid,ignore",
99,100d87
<     $queries{influx_details} = {measurement => "per-cpu"};
< 
127,130d113
<             inf_field => "cpuUsage",
<             inf_tags => qq|datacenter="$datacenter",hostname="$hostname",cpuid=$cpuid,hostType="$hostType"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,$cpuid,$hostType",
135,137c118,120
<     $queries{influx_details} = {measurement => "per-cpu"};
<     $qm = ariba::monitor::QueryManager->newWithDetails("per-cpu", $tab, $machine->service(), undef, \%queries);
<     eval { $qm->processQueries($debug, $email, $sendEmail, $sendPage); };
---
>     $qm = ariba::monitor::QueryManager->newWithDetails("per-cpu-from-$hostname", $tab, $machine->service(), undef, \%queries);
>     $qm->setUiManager('per-cpu');
>     eval { $qm->processQueriesUsingServerWithTimeout($debug, $email, $sendEmail, $sendPage, $monserver, $timeout); };
filename:./bin/mobile/ANmobile-backend-stats
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
9c9
< # ANmobile-backend-stats : Counts of API response statuses over 5 minute period
---
> # ANmobile-backend-stats : Counts of API response statuses over 5 minute period 
72,74c72,73
< sub main
< {
< 
---
> sub main {
>   
76,77c75,76
<     my $sendPage  = 0;
<     my $debug     = 0;
---
>     my $sendPage = 0;
>     my $debug = 0;
80,92c79,91
<                "help|h"   => sub {pod2usage(1);},
<                "debug|d+" => \$debug,
<                "e"        => \$sendEmail,
<                "p"        => \$sendPage,
<               );
< 
<     my $monProduct = ariba::rc::InstalledProduct->new();
<     my $product    = ariba::rc::InstalledProduct->new('an', $monProduct->service());
<     my $cluster    = $product->currentCluster() || 'primary';
<     my $email      = $product->default('notify.email');
<     my $name       = $product->name();
<     my $service    = $product->service();
<     my $customer   = $product->customer() || undef;
---
>         "help|h" => sub { pod2usage(1); },
>         "debug|d+" => \$debug,
>         "e" => \$sendEmail,
>         "p" => \$sendPage,
>     );
> 
>     my $monProduct = ariba::rc::InstalledProduct->new ();
>     my $product = ariba::rc::InstalledProduct->new ('an', $monProduct->service ());
>     my $cluster = $product->currentCluster () || 'primary';
>     my $email = $product->default ('notify.email');
>     my $name = $product->name ();
>     my $service = $product->service ();
>     my $customer = $product->customer () || undef;
94,96c93
< 
<     for my $instance ($product->appInstancesInCluster($cluster))
<     {
---
>     for my $instance ($product->appInstancesInCluster($cluster)) {
99c96
<         my $host         = $instance->host();
---
>         my $host = $instance->host();
103,142c100,130
<         eval {
<             my $monURL = ariba::monitor::Url->new($instance->mobileBackendMonitorURL());
<             $monURL->setTryCount(3);
<             $monURL->setTimeout(30);
<             my $tmp = $monURL->request();
<             $xml = XMLin($tmp);
<         };
<         if ($@)
<         {
<             #$error = "Error in fetching:".$instance->mobileBackendMonitorURL();
<             $error = -1;
<         }
< 
<         printf ("fetched:%s\n", $instance->mobileBackendMonitorURL()) if $debug;
<         my %indicator;
<         map {$indicator{$_} = $xml->{'MonitorStatus'}{'ResponseCounts'}{'entry'}{$_}} keys %{$xml->{'MonitorStatus'}{'ResponseCounts'}{'entry'}};
<         foreach my $code (keys %indicator)
<         {
<             $queries{"Mobile Backend Stats ($host $code)"} = {
<                                                               uiHint            => "$instanceName",
<                                                               recordMaxResults  => 25920,
<                                                               correctiveActions => [Ops => 'Warn:If many nodes are in warn condition, ops should confirm node health and open ticket with engineering if no problem is found, Crit/Page:Open CIRS'],
<                                                               description       => "Counts of API response statuses over 5 minute period",
<                                                               inf_tags          => qq(host="$host",instance_name="$instanceName"),
<                                                               inf_field         => qq(code_$code),
<                                                               inf_default       => 0,
<                                                               group_by          => $host,
<                                                              };
< 
<             $queries{"Mobile Backend Stats ($host $code)"}{'perl'} = sub {return ($error || $xml->{'MonitorStatus'}{'ResponseCounts'}{'entry'}{$code}{'content'});};
< 
<             if ($code == 500 || $code == 404)
<             {
<                 $queries{"Mobile Backend Stats ($host $code)"}{'crit'} = ("answer >= $indicator{$code}{crit}");
<                 $queries{"Mobile Backend Stats ($host $code)"}{'warn'} = ("answer >= $indicator{$code}{warn} or answer =~ /^Error in fetching/");
<             }
<             else
<             {
<                 $queries{"Mobile Backend Stats ($host $code)"}{'warn'} = ("answer =~ /^Error in fetching/");
<             }
---
>     eval
>      {
>      my $monURL = ariba::monitor::Url->new ($instance->mobileBackendMonitorURL());
>      $monURL->setTryCount(3);
>      $monURL->setTimeout(30);
>      my $tmp = $monURL->request();
>      $xml = XMLin($tmp);
>      };
>      if ($@) {
>         $error = "Error in fetching:".$instance->mobileBackendMonitorURL(); 
>      }
> 
>      printf("fetched:%s\n",$instance->mobileBackendMonitorURL()) if $debug;
>      my %indicator;
>      map {$indicator{$_}=$xml->{'MonitorStatus'}{'ResponseCounts'}{'entry'}{$_}}keys %{$xml->{'MonitorStatus'}{'ResponseCounts'}{'entry'}};
>        foreach my $code(keys %indicator) {
>            $queries {"Mobile Backend Stats ($host $code)"} =  {
>               uiHint => "$instanceName",
>               recordMaxResults => 25920,
>               correctiveActions => [Ops => 'Warn:If many nodes are in warn condition, ops should confirm node health and open ticket with engineering if no problem is found, Crit/Page:Open CIRS'],
>               description => "Counts of API response statuses over 5 minute period",
>            };
> 
>            $queries {"Mobile Backend Stats ($host $code)"}{'perl'} = sub {return ($error || $xml->{'MonitorStatus'}{'ResponseCounts'}{'entry'}{$code}{'content'});};
> 
>            if ($code == 500 || $code == 404) {
>               $queries {"Mobile Backend Stats ($host $code)"}{'crit'} = ("answer >= $indicator{$code}{crit}");
>               $queries {"Mobile Backend Stats ($host $code)"}{'warn'} = ("answer >= $indicator{$code}{warn} or answer =~ /^Error in fetching/");
>            } else {
>               $queries {"Mobile Backend Stats ($host $code)"}{'warn'} = ("answer =~ /^Error in fetching/");
>            }
145,149c133,135
<     }
<     $queries{influx_details} = {measurement => 'an_mobile_backend'};
< 
<     my $qm = ariba::monitor::QueryManager->newWithDetails('AN Mobile Backend', $name, $service, $customer, \%queries);
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>      }
>          my $qm = ariba::monitor::QueryManager->newWithDetails('AN Mobile Backend', $name, $service, $customer, \%queries);
>          $qm->processQueries($debug, $email, $sendEmail, $sendPage);
filename:./bin/mon/fyst-status
90c90
<             "warn" => "answer ne ''",
---
>             "warn" => "numrows > 0",
80,81d79
<     my $error_index=0;
<     my $answer = '';
83,86c81
<     foreach my $err (@errors)
<     {
<         $answer = $err;
<         $error_index += 1;
---
>     my $answer = join("\n", @errors);
88c83
<         $q{"Critical fyst changes in the last 24 hours line $error_index"} = {
---
>     $q{"Critical fyst changes in the last 24 hours"} = {
92,108c87
<             "inf_field" => "fyst_change_error",
<             "inf_tags" => "error_index=$error_index",
<         };
< 
<     }
<     if ($error_index == 0)
<     {
<         $q{"Critical fyst changes in the last 24 hours"} = {
<             info" => 1,
<             "warn" => "answer ne ''",
<             "perl" => sub { return $answer; },
<             "inf_field" => "fyst_change_error",
<             "inf_tags" => "error_index=$error_index",
<         }
<     }
< 
<     $q{influx_details} = {measurement => "fyst_status"};
---
>     };
filename:./bin/mon/monitor-daemon-watcher
75,77c75,76
<                 my $process_name= $process;
<                 $process_name=~ s/ /_/g;
< 		my $status = $processTable->processWithNameExists($process) ? 0 : 1;
---
> 
> 		my $status = $processTable->processWithNameExists($process) ? 'up' : 'down';
87,88c86,87
< 			info => "answer eq 0",
< 			crit => "answer eq 1",
---
> 			info => "answer eq 'up'",
> 			crit => "answer eq 'down'",
92,93d90
<                         inf_field => "$process_name",
<                         inf_default => 0,
96c93
< 	$queries{"influx_details"} = { 'measurement' => "monitor_daemon_watcher" };
---
> 	
106,107c103
<         #$queries{"influx_details"} = { 'measurement' => "monitor_daemon_watcher" };
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/mon/record-pagerequest-volume
94,95d93
<                         inf_field => "page_request_during_last_shift",
<                         group_by => "1",
105,106d102
<                         inf_field => "page_requests_sent_during_last_shift",
<                         group_by => "1",
116,117d111
<                         inf_field => "escalated_pages_during_last_shift"
<                         group_by => "1",
126,127d119
<                         inf_field => "${week}_days_moving_avg_pages_sent"
<                         group_by => "1",
136,137d127
<                         inf_field => "${month}_days_moving_avg_pages_sent"
<                         group_by => "1",
157,158d146
<                         inf_field => "recent_page_requests",
<                         inf_tags => 'page_group="' . $product->name() . " " . $customer . '"',
168,169d155
<                                 inf_field => "recent_page_requests",
<                                 inf_tags => "page_group=" . $product->name(),
179d164
<         $queries{influx_details} = {measurement => "page_metrics"};
filename:./bin/mon/record-vm-tab-status
71,72d70
<                         inf_field => "tab_status",
<                         inf_tags => "tab_product_name=\"$productName\"",
87,88d84
<                         inf_field => "tab_status_average",
<                         inf_tags => "tab_product_name=tab_average",
91,92d86
< 
<         $queries{influx_details} = {measurement => "vm_tab_status"};
96d89
< 
98c91,98
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->run();
> 
> 	if ( $debug ) {
> 		$q->displayToStdout();
> 	} else {
> 		$q->archiveResults();
> 		$q->displayToLog();     
> 	}
112,113d111
<                         inf_field => "${days}_moving_average_tab_status",
<                         inf_tags => "tab_product_name=\"${productName}_moving_average\"",
121,122d118
<                 inf_field => "${days}_moving_avg_for_all_tabs",
<                 inf_tags => "tab_product_name=all_tabs_average",
127,128d122
<         $queries{influx_details} = {measurement => "vm-tab-status-moving-averages"};
< 
filename:./bin/mon/spew-status
82c82
< 		while ((my $k = shift(@instances)) && $ct < 2) {
---
> 		while ((my $k = shift(@instances)) && $ct < 5) {
89c89
< 			$d .= " $logURL "";
---
> 			$d .= " <a href=\"$logURL\">$k</a>";
98d97
<         my $spew_id = 0;
100,102c99
<         foreach my $spew (@spewList)
<         {
< 	    $q->{"$spew_id:Scripts spewing in $datacenter in last 4 hours"} = {
---
> 	$q->{"Scripts spewing in $datacenter in last 4 hours"} = {
104,110c101,103
< 		perl => sub { return $spew; },
<                 inf_field => "spew_message",
<                 inf_tags =>"spew_id=$spew_id,datacenter=$datacenter",
< 	    };
<             $spew_id += 1;
<         }
<         $q->{influx_details} = {measurement => "spew_status"};
---
> 		perl => sub { return join("\n", @spewList); },
> 	};
> 
112c105
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/network/bgp
3c3
< # $Id: //ariba/services/monitor/bin/network/bgp#2 $
---
> # $Id: //ariba/services/monitor/bin/network/bgp#3 $
5a6
> use File::Basename;
16a18
> use dmail::LockLib;
18a21
> my $lockFile = "/tmp/" . basename($0);
34a38,39
> 	die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
40c45
< 			'datacenter'	   => $datacenter,
---
> 			'datacenter'       => $datacenter,
42c47
< 			'status'		   => 'inservice',
---
> 			'status'           => 'inservice',
58c63
< 			my $peers	= $router->bulkWalkOids('bgpPeerRemoteAddr');
---
> 			my $peers    = $router->bulkWalkOids('bgpPeerRemoteAddr');
68,71d72
< 					inf_field => "current_state_time",
< 					inf_tags => qq|datacenter="$datacenter",hostname="$hostname",peer="$peer"|,
< 					inf_default => "NA",
< 					group_by => "$datacenter,$hostname,$peer",
83,86d83
< 					inf_field => "current_state",
< 					inf_tags => qq|datacenter="$datacenter",hostname="$hostname",peer="$peer"|,
< 					inf_default => "NA",
< 					group_by => "$datacenter,$hostname,$peer",
91,95c88,92
< 		#$queries{'For more info about bgp see'} = {
< 		#	perl => " 'below' ",
< 		#	note => "<html><a href=\"$bgpDocUrl\">$bgpDocUrl</a></html>",
< 		#	info => 1,
< 		#};
---
> 		$queries{'For more info about bgp see'} = {
> 			perl => " 'below' ",
> 			note => "<html><a href=\"$bgpDocUrl\">$bgpDocUrl</a></html>",
> 			info => 1,
> 		};
99d95
< 		$queries{influx_details} = {measurement => "network_bgp"};
104c100
< 		$qm->processQueries($debug, $me->default('notify.email'), $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $me->default('notify.email'), $sendEmail, $sendPage);
105a102
> 	dmail::LockLib::releaselock($lockFile);
112c109
< 	my $now	= time();
---
> 	my $now    = time();
filename:./bin/network/etherchannel-status
5a6
> use File::Basename;
14a16
> use dmail::LockLib;
16a19
> my $lockFile = "/tmp/" . basename($0);
27a31,32
>     die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
65a71,76
>             unless($networkDevice) {
>                 print "[DEBUG] driver init failed for $hostname: '$@', skipping...\n" if $debug;
>                 $@ = undef; # clear the error
>                 next;
>             }
>             $networkDevice->snmp()->setTimeout(30);
99,102d109
<                         inf_tags => qq|datacenter=$datacenter,hostname=$hostname,etherchannel_group=$pagpAdminGroupCapability|,
<                         inf_field => "ports_not_configured",
<                         inf_default => "none",
<                         group_by => "$datacenter,$hostname/EtherChannel$pagpAdminGroupCapability",
146,149d152
<                         inf_field => "status",
<                         inf_tags => qq|datacenter=$datacenter,hostname=$hostname,etherchannel_group=$pagpAdminGroupCapability|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$hostname,$pagpAdminGroupCapability",
157d159
<             $queries{influx_details} = {measurement => "network_etherchannel_status"};
162c164
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
164a167
>     dmail::LockLib::releaselock($lockFile);
filename:./bin/network/latency-and-loss
94,97d93
<             inf_fields => "roundTripTimeToSite",
<             inf_tags => qq|site="$site",ip="$sites{$site}"|,
<             inf_default => 0,
<             group_by => "$sites{$site}",
109d104
<     $queries{influx_details} = {measurement => "network-latency-and-loss"};
152,155d146
<         $query->{inf_field} = "packetLoss";
<         $query->{inf_tags} = qq|site="$site",ip="$sites{site}"|;
<         $query->{inf_default} = 0;
<         $query->{group_by} = "$sites{$site}";
159d149
<     $queries{influx_details} = {measurement => "network-latency-and-loss"};
164c154
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/network/network-bad-duplex
20c20
< my $lockFile = "/tmp/Stratus_" . basename($0);
---
> my $lockFile = "/tmp/" . basename($0);
113,114d112
< 					inf_field => "duplex_error",
< 					inf_default => "none",
< 					inf_tags => "datacenter=$datacenter,host=$hostname,device_type=$deviceType",
< 					group_by => "$datacenter,$deviceType,$hostname"
120,121d117
< 
<                 $queries{influx_details} = {measurement => "network_bad_duplex"};
126c122
< 		$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/network/network-errors
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
6c6
< # $Id: //ariba/services/monitor/bin/network/network-errors#8 $
---
> # $Id: //ariba/services/monitor/bin/network/network-errors#9 $
8a9
> use File::Basename;
19a21,23
> use dmail::LockLib;
> 
> my $lockFile = "/tmp/" . basename($0);
31a36,37
>     die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
57,58c63
<             my $service;
<             foreach $service (@deviceServices) {
---
>             foreach my $service (@deviceServices) {
107,110d111
<                         inf_field => "packetCount",
<                         inf_tags => qq|datacenter="$datacenter",metricDescription="$queryName"|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$service,$queryName",
121d121
<         $queries{influx_details} = {measurement => "network_errors"};
126c126
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
128a129
>     dmail::LockLib::releaselock($lockFile);
filename:./bin/network/object-tracking
3a4
> use File::Basename;
13a15
> use dmail::LockLib;
15a18
> my $lockFile = "/tmp/" . basename($0);
18d20
< 
27a30,31
> 	die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
41d44
< 
66c69,74
< 			my $snmp          = ariba::SNMP::Session->newFromMachine($router);
---
> 
> 			unless($networkDevice) {
> 				print "[DEBUG] driver init failed for $routerName: '$@', skipping...\n" if $debug;
> 				$@ = undef; # clear the error
> 				next;
> 			}
110,113d117
< 					inf_field => "stateInfo",
< 					inf_tags => qq|datacenter="$datacenter",routerName="$routerName",trafficFlow="$trafficFlow"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$routerName,$trafficFlow",
132,135d135
< 						inf_field => "connectionFailedMessage",
< 						inf_tags => qq|datacenter="$datacenter",routerName="$routerName"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$routerName",
160,163d159
< 					inf_field => "stateInfo",
< 					inf_tags => qq|datacenter="$datacenter",routerName="$routerName"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$routerName",
168,172d163
< 					perl => sub {return "is running unknown ipsla"},
< 					inf_field => "stateInfo",
< 					inf_tags => qq|datacenter="$datacenter",routerName="$routerName"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$routerName",
178d168
< 			$queries{influx_details} = {measurement => "Network-Path"};
183c173
< 			$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 			$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
185a176
> 	dmail::LockLib::releaselock($lockFile);
86c86
< 						crit => "answer =~ /Failed/",
---
> 						crit => 1,
89,91d88
< 						inf_field => "error",
< 						inf_default => "none",
< 						inf_tags => qq|datacenter="$datacenter",routerName="$routerName",trafficFlow="$trafficFlow"|,	
135,138d131
< 						inf_field => "connectionFailedMessage",
< 						inf_tags => qq|datacenter="$datacenter",routerName="$routerName",trafficFlow="$queryName"|,
< 						inf_default => 0,
< 						group_by => "$datacenter,$routerName,$queryName",
163,166d155
< 					inf_field => "stateInfo",
< 					inf_tags => qq|datacenter="$datacenter",routerName="$routerName",trafficFlow="$queryName"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$routerName,$queryName",
171,175d159
< 					perl => sub {return "is running unknown ipsla"},
< 					inf_field => "stateInfo",
< 					inf_tags => qq|datacenter="$datacenter",routerName="$routerName",trafficFlow="running unknown ipsla"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$routerName,running unknown ipsla",
filename:./bin/network/os-revision
5a6
> use File::Basename;
15a17
> use dmail::LockLib;
17a20
> my $lockFile = "/tmp/" . basename($0);
37d39
< 
46a49,50
>     die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
92d95
< 
131,134d133
<                     inf_field => "OSVersion",
<                     inf_tags => qq|datacenter="$datacenter",device="$device_name"|,
<                     inf_default => 0,
<                     group_by => "$datacenter,$device_name",
138,139c137
<    
<         $queries{influx_details} = {measurement => "Network-OS"};
---
>     
144c142
<         $qm->processQueries($debug, $email, $send_email, $send_page);
---
>         $qm->processQueriesUsingServer($debug, $email, $send_email, $send_page);
145a144
>     dmail::LockLib::releaselock($lockFile);
filename:./bin/network/power
3c3
< # $Id: //ariba/services/monitor/bin/network/power#10 $
---
> # $Id: //ariba/services/monitor/bin/network/power#11 $
5a6
> use File::Basename;
15a17
> use dmail::LockLib;
17a20
> my $lockFile = "/tmp/" . basename($0);
20d22
< 
23c25
< 	my $debug	 = 0;
---
> 	my $debug     = 0;
28c30
< 		if ($arg =~ /^-d/o) { $debug	 = 1; };
---
> 		if ($arg =~ /^-d/o) { $debug     = 1; };
31c33,35
< 	my $me	= ariba::rc::InstalledProduct->new();
---
> 	die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
> 	my $me    = ariba::rc::InstalledProduct->new();
34c38
< 	my $cipherStore	= ariba::rc::CipherStore->new($me->service());
---
> 	my $cipherStore    = ariba::rc::CipherStore->new($me->service());
44,45c48,49
< 			'os'			   => 'catos, ios',
< 			'status'		   => 'inservice',
---
> 			'os'               => 'catos, ios',
> 			'status'           => 'inservice',
50c54
< 			'status'		   => 'inservice',
---
> 			'status'           => 'inservice',
52c56
< 			'os'			   => 'catos, ios',
---
> 			'os'               => 'catos, ios',
56,57c60,61
< 				my @machines = ariba::Ops::Machine->machinesWithProperties(%matchDatacenter);
< 				@machines = (@machines , ariba::Ops::Machine->machinesWithProperties(%matchMonitoringDatacenter));
---
>                 my @machines = ariba::Ops::Machine->machinesWithProperties(%matchDatacenter);
>                 @machines = (@machines , ariba::Ops::Machine->machinesWithProperties(%matchMonitoringDatacenter));
66,67c70,71
< 			'os'			   => 'catos, ios',
< 			'status'		   => 'inservice',
---
> 			'os'               => 'catos, ios',
> 			'status'           => 'inservice',
72c76
< 			'status'		   => 'inservice',
---
> 			'status'           => 'inservice',
74c78
< 			'os'			   => 'catos, ios',
---
> 			'os'               => 'catos, ios',
78,79c82,83
< 				@machines = (@machines , ariba::Ops::Machine->machinesWithProperties(%matchDatacenter));
< 				@machines = (@machines , ariba::Ops::Machine->machinesWithProperties(%matchMonitoringDatacenter));
---
>                 @machines = (@machines , ariba::Ops::Machine->machinesWithProperties(%matchDatacenter));
>                 @machines = (@machines , ariba::Ops::Machine->machinesWithProperties(%matchMonitoringDatacenter));
92a97,101
> 			unless($networkDevice) {
> 				print "[DEBUG] driver init failed for $hostname: '$@', skipping...\n" if $debug;
> 				$@ = undef; # clear the error
> 				next;
> 			}
107,110d115
< 					inf_field => "PS${ps}Status",
< 					inf_tags => qq|datacenter="$datacenter",hostname="$hostname"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$hostname",
118,122c123,127
< 		#$queries{"For more info about power supplies see"} = {
< 		#	perl => "'below'",
< 		#	note => "<html><a href=\"$docURL\">$docURL</a></html>",
< 		#	info => 1,
< 		#};
---
> 		$queries{"For more info about power supplies see"} = {
> 			perl => "'below'",
> 			note => "<html><a href=\"$docURL\">$docURL</a></html>",
> 			info => 1,
> 		};
124d128
< 		$queries{influx_details} = {measurement => "network-power-supply"};
131a136
> 	dmail::LockLib::releaselock($lockFile);
filename:./bin/network/redundancy-check
3c3
< # $Id: //ariba/services/monitor/bin/network/redundancy-check#15 $
---
> # $Id: //ariba/services/monitor/bin/network/redundancy-check#16 $
5a6
> use File::Basename;
15a17
> use dmail::LockLib;
17a20
> my $lockFile = "/tmp/" . basename($0);
22d24
< 
31a34
>     die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
45d47
<             $queries{influx_details} = {measurement => "Network-Redundancy"};
50c52
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
52a55
>     dmail::LockLib::releaselock($lockFile);
91a95,100
>         unless($networkDevice) {
>             print "[DEBUG] driver init failed for $deviceName: '$@', skipping...\n" if $debug;
>             $@ = undef; # clear the error
>             next;
>         }
> 
101,104d109
<         inf_field => "primaryStatus",
<         inf_tags => qq|datacenter="$datacenter",deviceName="$deviceName",uiHint="firewall"|,
<         inf_default => 0,
<         group_by => "$datacenter,$deviceName,firewall",
111,114d115
<         inf_field => "secondaryStatus",
<         inf_tags => qq|datacenter="$datacenter",deviceName="$deviceName",uiHint="firewall"|,
<         inf_default => 0,
<         group_by => "$datacenter,$deviceName,firewall",
147a149,154
>         unless($networkDevice) {
>             print "[DEBUG] driver init failed for $deviceName: '$@', skipping...\n" if $debug;
>             $@ = undef; # clear the error
>             next;
>         }
> 
178,181d184
<             inf_field => "activeSupervisorStatus",
<             inf_tags => qq|datacenter="$datacenter",deviceName="$deviceName",uiHint="Switch"|,
<             inf_default => 0,
<             group_by => "$datacenter,$deviceName,Switch",
189,192d191
<             inf_field => "standbySupervisorStatus",
<             inf_tags => qq|datacenter="$datacenter",deviceName="$deviceName",uiHint="Switch"|,
<             inf_default => 0,
<             group_by => "$datacenter,$deviceName,Switch",
232,236c231
<             uiHint  => 'bigip',
<             inf_field => "failoverState",
<             inf_tags => qq|datacenter="$datacenter",deviceName="$hostname",uiHint="bigip"|,
<             inf_default => 0,
<             group_by => "$datacenter,$hostname,bigip",
---
>             uiHint  => 'bigip'
filename:./bin/network/switch-port-name
22c22
< my $lockFile = "/tmp/Stratus" . basename($0);
---
> my $lockFile = "/tmp/" . basename($0);
188d187
<                         my $error_count = scalar (@errors);
191,196c190,193
< 				info => "answer > -1",
< 				warn => "answer > 0", 
< 				perl => "return qq{$error_count}",
< 				inf_field => "error_count",
< 				inf_tags => "switch_name=\"$switchName\"",
< 				default => 0,
---
> 				noRowCount => 1,
> 				info => "numrows > -1",
> 				warn => "numrows > 0", 
> 				perl => "return qq{$errors}",
202d198
< 		$queries{influx_details} = {measurement => "network_switch_port_name"};
207c203
< 		$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/network/switch-usage
6c6
< # $Id: //ariba/services/monitor/bin/network/switch-usage#7 $
---
> # $Id: //ariba/services/monitor/bin/network/switch-usage#8 $
8a9
> use File::Basename;
19a21,23
> use dmail::LockLib;
> 
> my $lockFile = "/tmp/" . basename($0);
31a36,37
> 	die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
48c54
< 					status	 => 'inservice',
---
> 					status     => 'inservice',
55c61
< 					status	 => 'inservice',
---
> 					status     => 'inservice',
84c90
< 					my $cdbs	 = ariba::monitor::CircularDB->listDBs("snmp/$deviceName", $item);
---
> 					my $cdbs     = ariba::monitor::CircularDB->listDBs("snmp/$deviceName", $item);
134d139
< 						my $metricDescription = $cdb->name();
141c146
< 							hasErraticSchedule => 1,
---
>                                                         hasErraticSchedule => 1,
143,146d147
< 							inf_field => "usage",
< 							inf_tags => qq|deviceType="$deviceType",deviceName="$deviceName",metricDescription="$metricDescription"|,
< 							inf_default => 0,
< 							group_by => "$datacenter,$deviceType,$deviceName,$metricDescription",
160d160
< 		$queries{influx_details} = {measurement => "network-usage"};
163c163
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
167a168
> 	dmail::LockLib::releaselock($lockFile);
filename:./bin/network/vip-pool
5a6
> use File::Basename;
15a17
> use dmail::LockLib;
17a20
> my $lockFile = "/tmp/" . basename($0);
34a38,39
>     die "can't grab lock\n" unless dmail::LockLib::requestlock($lockFile, 5);
> 
51a57,61
>             unless($nm) {
>                 print "[DEBUG] driver init failed for " . $host->hostname() . ": '$@', skipping...\n" if $debug;
>                 $@ = undef; # clear the error
>                 next;
>             }
56a67
>             $snmp->setTimeout(30);
70,73d80
<                     inf_field => "status",
<                     inf_tags => qq|datacenter="$dataCenter",hostname="$hostname",IPName="$name"|,
<                     inf_default => 0,
<                     group_by => "$dataCenter,$hostname",
79d85
<             $queries{influx_details} = {measurement => "Network-F5-VIP-Pool"};
84c90
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
86a93
>     dmail::LockLib::releaselock($lockFile);
filename:./bin/redis/redis-db-stats
30c30
< 		die "\n Redis configs not present in mon.. exiting... ";
---
>         die "\n Redis configs not present in mon.. exiting... ";
43,67c43,67
< 	my $sendEmail = 0;
< 	my $sendPage = 0;
< 	my $product = 'redis';
< 	my %queries;
< 	my $url = 'https://'.$rhost.':9443';	
< 	while(my $arg=shift(@ARGV)){
< 		if($arg =~ /^-d/o){ $debug = 1; }
< 		if($arg =~ /^-e/o){ $sendEmail = 1; };
< 		if($arg =~ /^-p/o){ $sendPage = 1; };
< 	}
< 	my $surl = $url.'/v1/bdbs';
< 	my $cmd = "curl -s -u $user:$pass ". '--insecure '.$surl;
< 	my $results = `$cmd`;#exceptio handling
< 	my $warn ;
< 	my $crit ;
< 	my @output;
< 	my @errors;
< 	my $redis_hash;
< 	my $ref;# =  decode_json( $results);
< 	print "\n $cmd | $results " if($debug);
< 	my $ref;
< 	eval { $ref = decode_json($results);};
< 	if($@) { die "\n Error $@"; }
< 	my %slow;
< 	foreach my $db(@$ref){
---
>     my $sendEmail = 0;
>     my $sendPage = 0;
>     my $product = 'redis';
>     my %queries;
>     my $url = 'https://'.$rhost.':9443';	
>     while(my $arg=shift(@ARGV)){
>         if($arg =~ /^-d/o){ $debug = 1; }
>         if($arg =~ /^-e/o){ $sendEmail = 1; };
>         if($arg =~ /^-p/o){ $sendPage = 1; };
>     }
>     my $surl = $url.'/v1/bdbs';
>     my $cmd = "curl -s -u $user:$pass ". '--insecure '.$surl;
>     my $results = `$cmd`;#exceptio handling
>     my $warn ;
>     my $crit ;
>     my @output;
>     my @errors;
>     my $redis_hash;
>     my $ref;# =  decode_json( $results);
>     print "\n $cmd | $results " if($debug);
>     my $ref;
>     eval { $ref = decode_json($results);};
>     if($@) { die "\n Error $@"; }
>     my %slow;
>     foreach my $db(@$ref){
69c69
< 		my $uid = $db->{uid};
---
>         my $uid = $db->{uid};
76,95c76,95
< 	 }
< 	 $surl = $url.'/v1/license';
< 	 $cmd = "curl -s -u $user:$pass ". '--insecure '.$surl;
< 	 $results = `$cmd`;
< 	 print "\n $cmd | $results " if($debug);
< 	 my $ref;
< 	 eval { $ref = decode_json($results);};
< 	 if($@) { die "\n Error $@"; }
< 	 my @temp = split /\n/, $ref->{license};
< 	 my $lic_exp = $temp[3];
< 	 $lic_exp =~ s/.*z\-//ig;
< 	 $lic_exp =~ s/T.*//ig;
< 	 my @ldate = split /\-/, $lic_exp;
< 	 my $ldt = DateTime->new(
< 			  year	   => $ldate[0],
< 			  month	  => $ldate[1],
< 			  day		=> $ldate[2],
< 			  hour	   => 0,
< 			  minute	 => 0,
< 			  second	 => 0,
---
>      }
>      $surl = $url.'/v1/license';
>      $cmd = "curl -s -u $user:$pass ". '--insecure '.$surl;
>      $results = `$cmd`;
>      print "\n $cmd | $results " if($debug);
>      my $ref;
>      eval { $ref = decode_json($results);};
>      if($@) { die "\n Error $@"; }
>      my @temp = split /\n/, $ref->{license};
>      my $lic_exp = $temp[3];
>      $lic_exp =~ s/.*z\-//ig;
>      $lic_exp =~ s/T.*//ig;
>      my @ldate = split /\-/, $lic_exp;
>      my $ldt = DateTime->new(
>               year       => $ldate[0],
>               month      => $ldate[1],
>               day        => $ldate[2],
> 	          hour       => 0,
>               minute     => 0,
>               second     => 0,
97c97
< 		  );
---
>           );
100,102c100,102
< 	my %shard_map;
< 	$surl = $url.'/v1/bdbs/';
< 	foreach my $id(keys %$redis_hash){
---
>     my %shard_map;
>     $surl = $url.'/v1/bdbs/';
>     foreach my $id(keys %$redis_hash){
104,108c104,108
< 	$results = `$cmd`;
< 	print "\n $cmd | $results " if($debug);
< 	my $ref;
< 	eval { $ref = decode_json($results);};
< 	if($@) { die "\n Error $@"; }
---
>     $results = `$cmd`;
>     print "\n $cmd | $results " if($debug);
>     my $ref;
>     eval { $ref = decode_json($results);};
>     if($@) { die "\n Error $@"; }
110,111c110,111
< 	#my $epip = $ref->{endpoint_ip}->[0];
< 	my $epip = $ref->{endpoints}->[0]->{addr}->[0];
---
>     #my $epip = $ref->{endpoint_ip}->[0];
>     my $epip = $ref->{endpoints}->[0]->{addr}->[0];
122c122
< 	$results = `$cmd`;
---
>     $results = `$cmd`;
125c125
< 	eval {
---
>     eval {
127c127
< 	};
---
>     };
129,131c129,131
< 		my $nocon = $ref->{'bdb:'.$id}->{total_connections_received};	#concatenation needs to be outside
< 		$redis_hash->{$id}->{conn_recvd} = $nocon;
< 	}
---
>         my $nocon = $ref->{'bdb:'.$id}->{total_connections_received};	#concatenation needs to be outside
> 	    $redis_hash->{$id}->{conn_recvd} = $nocon;
>     }
137,142c137,142
< 		  year	   => $year,
< 		  month	  => $month,
< 	  	  day		=> $dayOfMonth,
< 		  hour	   => $hour,
< 		  minute	 => $minute,
< 		  second	 => $second,
---
> 	      year       => $year,
> 	      month      => $month,
>       	  day        => $dayOfMonth,
>           hour       => $hour,
> 	      minute     => $minute,
> 	      second     => $second,
146c146
< 	my $licexpire = $ldt->subtract_datetime_absolute($dt)->delta_seconds / (24*60*60);
---
>     my $licexpire = $ldt->subtract_datetime_absolute($dt)->delta_seconds / (24*60*60);
148,155c148,153
< 				crit	=> 'answer < 50',
< 				perl	=> sub { int($licexpire); },
< 				description => "RLEC License Expiry in days ",
< 				uiHint => "License",
< 				inf_field => "RLEC_license_expire_in_days",
< 				inf_tags => "uihint=License",
< 				inf_default => 0,
< 		};
---
> 		        crit    => 'answer < 50',
>                 perl    => sub { int($licexpire); },
>                 description => "RLEC License Expiry in days ",
>                 uiHint => "License",
> 
>         };
165c163
< 	my $ref;
---
>     my $ref;
189,241c187,229
< 	my $crits;
< 	foreach my $bdb(keys%$redis_hash){
< 		my $endpo = $redis_hash->{$bdb}->{endpoint};
< 		my $db = $redis_hash->{$bdb}->{name};
< 		my $endstat = &get_ep_status($endpo);
< 		$queries{"Endpoint Status $endpo"} = {
< 				crit => 'answer =~ /down/i',
< 				perl	=> sub { return $endstat; },
< 				description => "Redis Endpoint Ping Status $db",
< 				uiHint => "Database",
< 				inf_field => "Redis_endpoint_status",
< 				inf_tags => "uihint=Database,db=$db",
<    				inf_default => "none", 
< 		};
< 		$queries{"Total Connections Received $db"} = {
< 				crit => 'answer > 12000',
< 				warn => 'answer > 10000',
< 				perl	=> sub { return $redis_hash->{$bdb}->{conn_recvd}; },
< 				description => "Redis rate of new client connections to DB (connections/sec)",
< 				uiHint => "Database/$db",
< 				inf_field => "Total_connection_received",
< 				inf_tags => "type=\"Database/$db\",db=$db",
<    				inf_default => 0, 
< 		};
< 
< 		foreach my $shard(@{$redis_hash->{$bdb}->{shards}}){
< 			my $sid = $shard->{sid};
< 			my $db = $redis_hash->{$bdb}->{name};
< 			foreach my $k(keys %$shard){
< 				next if(($k eq 'sid') or ($k eq 'role'));
< 						(my $inf_field = $k) =~ s/\W//g;
< 				my $role = $shard->{role};
< 				$queries{"$db-shard-".$sid."-".$k } = {
< 						perl	=> sub { return $shard->{$k}; },
< 				   		description => "Redis $db Shard $sid $k",
< 				  		uiHint => "Database/$db/Shards/".$role."/Shard-$sid/",
< 						inf_field => "$inf_field",
< 						inf_tags => qq|db="$db",role="$role",sid="$sid"|,
< 						group_by => "$db,$role,$sid",
<    						inf_default => 0, 
< 				};
< 				if($k !~ /slot/i){
< 						$queries{"$db-shard-".$sid."-".$k }->{recordMaxResults} = 5000;
< 						$queries{"$db-shard-".$sid."-".$k }->{recordDataType} =  'counter';
< 						$queries{"$db-shard-".$sid."-".$k }->{recordOnError} = 1;
< 				}
< 				if($k =~ /Mem Size/){
< 		 				$queries{"$db-shard-".$sid."-".$k }->{format} = '%4.2fMB';
< 				}
< 			}
< 		}
< 	}
< 	foreach my $db(keys %slow){
---
>     my $crits;
>     foreach my $bdb(keys%$redis_hash){
>     	my $endpo = $redis_hash->{$bdb}->{endpoint};
>     	my $db = $redis_hash->{$bdb}->{name};
>     	my $endstat = &get_ep_status($endpo);
>     	$queries{"Endpoint Status $endpo"} = {
>     			crit => 'answer =~ /down/i',
>                 perl    => sub { return $endstat; },
>                 description => "Redis Endpoint Ping Status $db",
>                 uiHint => "Database",
>     
>         };
>     	$queries{"Total Connections Received $db"} = {
>         		crit => 'answer > 12000',
> 	        	warn => 'answer > 10000',
>                 perl    => sub { return $redis_hash->{$bdb}->{conn_recvd}; },
>                 description => "Redis rate of new client connections to DB (connections/sec)",
>                 uiHint => "Database/$db",
> 	    };
> 
>     	foreach my $shard(@{$redis_hash->{$bdb}->{shards}}){
>     		my $sid = $shard->{sid};
>     		my $db = $redis_hash->{$bdb}->{name};
>     		foreach my $k(keys %$shard){
>     			next if(($k eq 'sid') or ($k eq 'role'));
>     			my $role = $shard->{role};
>     			$queries{"$db-shard-".$sid."-".$k } = {
>                         perl    => sub { return $shard->{$k}; },
>                    	    description => "Redis $db Shard $sid $k",
>                   	    uiHint => "Database/$db/Shards/".$role."/Shard-$sid/",
>     	        };
>     			if($k !~ /slot/i){
>         				$queries{"$db-shard-".$sid."-".$k }->{recordMaxResults} = 5000;
> 		                $queries{"$db-shard-".$sid."-".$k }->{recordDataType} =  'counter';
>         		        $queries{"$db-shard-".$sid."-".$k }->{recordOnError} = 1;
> 	    		}
> 		    	if($k =~ /Mem Size/){
>          		        $queries{"$db-shard-".$sid."-".$k }->{format} = '%4.2fMB';
> 		    	}
> 		    }
> 	    }
>     }
>     foreach my $db(keys %slow){
243,256c231,239
< 		$queries{"Number of Slowlog Entries $db"} = {
< 				perl	=> sub { return $slow{$db}; },
< 				description => "Redis slowlog count",
< 				uiHint => "SlowLog Counts",
< 				inf_field => "slowlog_count",
< 				inf_tags => "uihint=\"SlowLog Counts\",db=$db",
<    				inf_default => 0, 
< 		};
< 	}
< 
< 	$queries{influx_details} = {measurement => "Redis_cluster_details"};
< 
< 	my $qm = ariba::monitor::QueryManager->newWithDetails('Redis Cluster Details', 'mon', $service, "", '', \%queries);
< 	my $email = $me->default('notify.email') || $me->default('notify');
---
> 	    $queries{"Number of Slowlog Entries $db"} = {
> 	        	perl    => sub { return $slow{$db}; },
>                 description => "Redis slowlog count",
>                 uiHint => "SlowLog Counts",
> 
> 	    };
>     }
>     my $qm = ariba::monitor::QueryManager->newWithDetails('Redis Cluster Details', 'mon', $service, "", '', \%queries);
>     my $email = $me->default('notify.email') || $me->default('notify');
258c241
< 	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
273c256
< 	my $ssh	 = ariba::rc::Utils::sshCmd();
---
> 	my $ssh     = ariba::rc::Utils::sshCmd();
280c263
< 	my $result = join "\n", @output;
---
>     my $result = join "\n", @output;
291c274
< 	my $op = `$cmd`;
---
>     my $op = `$cmd`;
filename:./bin/redis/redis-nodes-status
66,71c66,70
< ######  Too Much Information #####
< #    $queries{"Redis Summary"} = {
< #                    perl    => sub { return $result; },
< #                    description => "Redis Cluster Details",
< #                    uiHint => "Summary",
< #    };
---
>     $queries{"Redis Summary"} = {
>                     perl    => sub { return $result; },
>                     description => "Redis Cluster Details",
>                     uiHint => "Summary",
>     };
117,118d115
<                             inf_field => "node_status",
<                             inf_tags => qq|node_id=$nid,param=$param|,
123,125d119
<  
<     $queries{influx_details} = {measurement => "redis_nodes_details"};
< 
filename:./bin/s4/activity-stats-lli
52a53
> print "$FindBin::Bin\n";
79d79
< $queries->{influx_details} = { measurement => 's4_current_activity_lli' };
85c85
< $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
129,143d128
<     my %influx_db_col = ( 'LLI Exception Count For Submit Excel Bid' => 'submit_excel_bid_cnt',
<                           'LLI Exception Count For Delete All Content' => 'delete_all_content_cnt',
<                           'LLI RFX Count' => 'rfx_cnt',
<                           'LLI Exception Count For Optimize' => 'optimize_cnt',
<                           'LLI Time For All Buyer Reports' => 'buyer_reports_time',
<                           'LLI Exception Count For Publish' => 'publish_cnt',
<                           'LLI Time For Optimize' => 'optimize_time',
<                           'LLI Exception Count For Award' => 'award_cnt',
<                           'LLI Exception Count' => 'exp_cnt',
<                           'LLI Time For Submit Excel Bid' => 'submit_excel_bid_time',
<                           'LLI Time For Delete All Content' => 'delete_all_content_time',
<                           'LLI Exception Count For Generate Excel Bid File' => 'excel_bid_file_cnt',
<                           'Contract Request Count' => 'contract_req_cnt',
<                           'Contract Request Failed Count' => 'contract_req_failed_cnt' );
< 
148d132
<         my $inf_field    = $influx_db_col{$qdisplayname};
178,182c162
<         
<                 $q->{inf_field} = $inf_field;
<                 $q->{inf_default} = 0;
<                 $q->{inf_tags} = qq(community="$community",instance_type="$appname",instance_name="$instancename");
<                 $q->{group_by} = qq($community,$appname,$instancename);
---
>                 
189d168
<                 my $inf_field = $influx_db_col{$qdisplayname};
201,205d179
<                 $q->{inf_field} = $inf_field;           
<                 $q->{inf_default} = 0;
<                 $q->{inf_tags} = qq(instance_name="$h");
<                 $q->{group_by} = qq($h);
< 
212d185
<             my $inf_field    = $influx_db_col{$qdisplayname};
223,226d195
<             $q->{inf_field} = $inf_field;
<             $q->{inf_default} = 0;
<             $q->{inf_tags} = qq(instance_type="summary");
<             $q->{group_by} = qq(summary);
filename:./bin/sysadmin/spare-check
3c3
< # $Id: //ariba/services/monitor/bin/sysadmin/spare-check#16 $
---
> # $Id: //ariba/services/monitor/bin/sysadmin/spare-check#15 $
28,29c28,29
< 				'poweredgec6105,x4140' => 1,
< 				'x4100m2' => 1,
---
>                 'poweredgec6105,x4140' => 1,
>                 'x4100m2' => 1,
44c44
< 		my @typesToMonitor = ( 'poweredgec6105,x4140', 'x4100m2' );
---
>         my @typesToMonitor = ( 'poweredgec6105,x4140', 'x4100m2' );
59c59
< 				status	 => 'spare',
---
> 				status     => 'spare',
74a75,78
> 				# We dont want to crit for x4100m2s anymore, tmid: 137103
>                 		if ($types eq 'x4100m2') {
>                     			$crit = 0;
>                 		}
97,100d100
< 					inf_field => "oddSpareNumber",
< 					inf_tags => qq|datacenter="$datacenter",types=>"$types"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$types",
108,111d107
< 					inf_field => "evenSpareNumber",
< 					inf_tags => qq|datacenter="$datacenter",types=>"$types"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$types",
122,125d117
< 					inf_field => "SpareNumber",
< 					inf_tags => qq|datacenter="$datacenter",types=>"$types"|,
< 					inf_default => 0,
< 					group_by => "$datacenter,$types",
130,131c122
< 		
< 		$queries{influx_details} = {measurement => "Spare-machines"};
---
> 	
133c124
< 		$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/visualizer/current-activity
1c1
< #!/usr/local/bin/perl 
---
> #!/usr/local/bin/perl -w
62,63d61
<         inf_field   => "supplier_address_fetch_cnt",
<         inf_default => 0,
67c65
<     $queries{'influx_details'} = {measurement => 'arecibo_current_activity'};
---
> 
filename:./bin/ws/generate-reports
30d29
< use Data::Dumper;
103c102
<     $tmpDir ||= ariba::Ops::Startup::Common::tmpdir() . "/stratus-generate-" . $productName . "-busypage-report-tmp";
---
>     $tmpDir ||= ariba::Ops::Startup::Common::tmpdir() . "/generate-" . $productName . "-busypage-report-tmp";
506,509d504
<             inf_field => "count",
<             inf_tags  => qq(type="$incident",ui_hint="busy_pages",ts="$when"),
<             inf_default => 0,
<             group_by => "$incident,busy_pages,$when",
533,536d527
<         ## Convert to lc and _
<         $report = lc($report);
<         $report =~ s/\s+/_/g;
< 
557,560d547
<             inf_field => "count",
<             inf_tags  => qq(type="$report",ui_hint="$uiHint",ts="$when"),
<             inf_default => 0,
<             group_by  => qq($report,$uiHint,$when),
564,566c551,554
<   
<     $queries{influx_details} = { measurement => 'webserver_reports' };     
<     my $qm = ariba::monitor::QueryManager->newWithDetails( "reports", $productName, $service, $me->customer(), \%queries);
---
>         
>     my $qm = ariba::monitor::QueryManager->newWithDetails(
>         "reports", $productName, $service, $me->customer(), \%queries
>     );
568c556
<     $qm->processQueries($debug, $notify, $sendEmail, $sendPage);
---
>     $qm->processQueriesUsingServer($debug, $notify, $sendEmail, $sendPage);
filename:./bin/ws/modjk-workers-consistency
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
121c121
<                     perl                            => sub { return scalar(@{$missingWorkersRef}); },
---
>                     perl                            => sub { return join ("\n" , @{$missingWorkersRef}); },
124,127d123
<                     inf_field                       => "missing_workers_cnt",
<                     inf_default                     => 0,
<                     inf_tags                        => qq(product="$productName",ws_type="$webserverType",host="$webserverHost"),
<                     group_by                        => qq($productName,$webserverType,$webserverHost),
133c129
<                     perl                            => sub { return scalar(@{$erroredWorkersRef}); },
---
>                     perl                            => sub { return join ("\n" , @{$erroredWorkersRef}); },
136,139d131
<                     inf_field                       => "workers_in_error_state_cnt",
<                     inf_default                     => 0,
<                     inf_tags                        => qq(product="$productName",ws_type="$webserverType",host="$webserverHost"),
<                     group_by                        => qq($productName,$webserverType,$webserverHost),
145c137
<                     perl                            => sub { return scalar(@{$extraWorkersRef}); },
---
>                     perl                            => sub { return join ("\n" , @{$extraWorkersRef}); },
148,151d139
<                     inf_field                       => "extra_workers_cnt",
<                     inf_default                     => 0,
<                     inf_tags                        => qq(product="$productName",ws_type="$webserverType",host="$webserverHost"),
<                     group_by                        => qq($productName,$webserverType,$webserverHost),
160,163d147
<                     inf_field                       => "percent_down",
<                     inf_default                     => 0,
<                     inf_tags                        => qq(product="$productName",ws_type="$webserverType",host="$webserverHost"),
<                     group_by                        => qq($productName,$webserverType,$webserverHost),
170c154
<     $queries{influx_details} = { measurement => 'ssws_modjk_workers' }; 
---
>     
filename:./lib/ariba/HTTPWatcherPlugin/DeploymentDefaultsUrls.pm
filename:./lib/ariba/HTTPWatcherPlugin/WOFAppInstance.pm
filename:./lib/ariba/Oncall/Schedule_v2.pm
filename:./lib/ariba/Ops/CommonMachineMethods.pm
filename:./lib/ariba/Ops/DBConnection.pm
filename:./lib/ariba/Ops/FileSystemUtilsRPC.pm
filename:./lib/ariba/Ops/MigrationHelper.pm
filename:./lib/ariba/Ops/NetworkDeviceManager.pm
filename:./lib/ariba/Ops/ServiceController.pm
filename:./lib/ariba/Ops/Startup/Apache.pm
filename:./lib/ariba/Ops/Startup/Arches.pm
filename:./lib/ariba/Ops/Startup/OSGI.pm
filename:./lib/ariba/SNMP/Session.pm
filename:./lib/ariba/monitor/Bpm.pm
1c1
< package ariba::monitor::Bpm;
---
> package ariba::monitor::Bpm; 
5c5
< #
---
> #  
16d15
< use Data::Dumper;
20,31c19,27
< sub replaceTokens
< {
<     my $text   = shift;
<     my $tokens = shift;
< 
<     if ($tokens && ref ($tokens) eq 'HASH')
<     {
<         while (my ($token, $value) = each (%$tokens))
<         {
<             $text =~ s/{$token}/$value/gi;
<         }
<     }
---
> sub replaceTokens {
> 	my $text = shift; 
> 	my $tokens = shift;
> 
> 	if ($tokens && ref($tokens) eq 'HASH') {
> 		while (my ($token, $value) = each(%$tokens)) {
> 			$text =~ s/{$token}/$value/gi;
> 		}
> 	}
33c29
<     return $text;
---
> 	return $text;
36,39c32,34
< sub urlForANApp
< {
<     my $an  = shift;
<     my $app = shift;
---
> sub urlForANApp {
> 	my $an = shift; 
> 	my $app = shift; 
44c39
<     return $an->default('AdminSecureFrontDoor') . "/$app.aw/ad/monitorBpm";
---
> 	return $an->default('AdminSecureFrontDoor') . "/$app.aw/ad/monitorBpm";
47,58c42,51
< sub communityUrlsForUrlAndCommunities
< {
<     my $url         = shift;
<     my @communities = @_;
<     my %communityUrls;
< 
<     return \%communityUrls unless defined ($url);
< 
<     foreach my $community (@communities)
<     {
<         $communityUrls{$community} = $url;
<     }
---
> sub communityUrlsForUrlAndCommunities {
> 	my $url = shift; 
> 	my @communities = @_;
> 	my %communityUrls;
> 
>     return \%communityUrls unless defined($url);
> 
> 	foreach my $community (@communities) {
> 		$communityUrls{$community} = $url;
> 	}
60c53
<     return \%communityUrls;
---
> 	return \%communityUrls;
64,68c57,60
< sub communityUrlsForProductAndAppName
< {
<     my $product = shift;
<     my $app     = shift;
<     my %communityUrls;
---
> sub communityUrlsForProductAndAppName {
> 	my $product = shift; 
> 	my $app = shift;
> 	my %communityUrls; 
73,76c65,67
<     my @appInstances = $product->appInstances();
<     foreach my $instance (@appInstances)
<     {
<         next unless ($instance->appName() eq $app);
---
> 	my @appInstances = $product->appInstances(); 
> 	foreach my $instance (@appInstances) {
> 		next unless ($instance->appName() eq $app);
79,80c70
<         if (ariba::monitor::AppRecycleOutage->objectWithNameExists($outageName))
<         {
---
>         if (ariba::monitor::AppRecycleOutage->objectWithNameExists($outageName)) {
85,97c75,82
<         if ($product->name() eq 'buyer')
<         {
<             $communityUrls{$instance->community()} = $instance->businessProcessMonitorURL() unless ($communityUrls{$instance->community()});
<         }
<         elsif ($product->name() eq 'an')
<         {
<             $communityUrls{$instance->community()} = $instance->monitorBpmURL() unless ($communityUrls{$instance->community()});
<         }
<         else
<         {
<             $communityUrls{$instance->community()} = "communityUrlsForProductAndAppName is not implemented for product " . $product->name();
<         }
<     }
---
> 		if ($product->name() eq 'buyer') { 
> 			$communityUrls{$instance->community()} = $instance->businessProcessMonitorURL() unless ($communityUrls{$instance->community()});
> 		} elsif ($product->name() eq 'an') {
> 			$communityUrls{$instance->community()} = $instance->monitorBpmURL() unless ($communityUrls{$instance->community()});
> 		} else { 
> 			$communityUrls{$instance->community()} = "communityUrlsForProductAndAppName is not implemented for product " . $product->name();
> 		}
> 	}
99c84
<     return \%communityUrls;
---
> 	return \%communityUrls;	
102,151c87,131
< # Returns a hash with the following structure:
< #   $responses->{communityId}->{url} = Full url of the GET request
< #                            ->{content} = Xml content from url
< #                            ->{error} = Request errors
< sub getResponsesForUrlsAndParams
< {
<     my $urls                = shift;
<     my $params              = shift;
<     my $addCommunityToParam = shift;
< 
<     my %responses;
< 
<     return \%responses unless (ref ($urls) eq 'HASH' && ref ($params) eq 'HASH');
< 
<     my @communities = keys (%$urls);
<     foreach my $community (sort @communities)
<     {
<         my $url = $urls->{$community};
<         $params->{community} = $community if ($addCommunityToParam);
< 
<         unless ($url)
<         {
<             $responses{$community}{error} = "No url specified for community $community";
<             next;
<         }
< 
<         my $request = ariba::monitor::Url->new($url);
<         $request->setParams($params);
<         $request->setTimeout(30);
< 
<         my $fullUrl = $request->fullUrl();
<         $responses{$community}{url} = $fullUrl;
< 
<         print "Checking $fullUrl\n" if ($main::debug);
< 
<         my $response;
<         eval {$response = $request->request();};
< 
<         if ($request->error() || $@)
<         {
<             my $error = $request->error() || $@;
<             $responses{$community}{error} = "HTTP request error for community $community: $error";
<             next;
<         }
< 
<         unless ($response)
<         {
<             $responses{$community}{error} = "HTTP request has no response for community $community";
<             next;
<         }
---
> # Returns a hash with the following structure: 
> #	$responses->{communityId}->{url} = Full url of the GET request
> #							 ->{content} = Xml content from url
> #							 ->{error} = Request errors
> sub getResponsesForUrlsAndParams {
> 	my $urls = shift; 
> 	my $params = shift;
> 	my $addCommunityToParam = shift;
> 
> 	my %responses;
> 
> 	return \%responses unless (ref($urls) eq 'HASH' && ref($params) eq 'HASH');
> 
> 	my @communities = keys(%$urls);
> 	foreach my $community (sort @communities) { 
> 		my $url = $urls->{$community};
> 		$params->{community} = $community if ($addCommunityToParam);
> 
> 		unless ($url) {
> 			$responses{$community}{error} = "No url specified for community $community";
> 			next;
> 		}
> 
> 		my $request = ariba::monitor::Url->new($url); 
> 		$request->setParams($params); 	
> 		$request->setTimeout(30);
> 
> 		my $fullUrl = $request->fullUrl();
> 		$responses{$community}{url} = $fullUrl;	
> 
> 		print "Checking $fullUrl\n" if ($main::debug);
> 
> 		my $response;
> 		eval { $response = $request->request();  };
> 
> 		if ($request->error() || $@) {
> 			my $error = $request->error() || $@;
> 			$responses{$community}{error} = "HTTP request error for community $community: $error"; 
> 			next;
> 		}
> 
> 		unless ($response) {
> 			$responses{$community}{error} = "HTTP request has no response for community $community"; 
> 			next;
> 		}
153,154c133,134
<         $responses{$community}{content} = $response;
<     }
---
> 		$responses{$community}{content} = $response;
> 	}
156c136
<     return \%responses;
---
> 	return \%responses;
159,202c139,177
< sub splitResponsesBetween4xxAndNon4xx
< {
<     my $responses          = shift;
<     my $responsesFor4xx    = {};
<     my $responsesForNon4xx = {};
< 
<     my @communities = keys (%$responses);
<     foreach my $community (@communities)
<     {
<         # Set common fields
<         foreach my $field (qw(url error))
<         {
<             $responsesFor4xx->{$community}{$field}    = $responses->{$community}{$field};
<             $responsesForNon4xx->{$community}{$field} = $responses->{$community}{$field};
<         }
< 
<         # Split xml based on isNon4xx attribute
<         next unless ($responses->{$community}{content});
< 
<         my @contentFor4xx;
<         my @contentForNon4xx;
<         my $isNon4xx;
<         foreach my $line (split (/\r?\n/, $responses->{$community}{content}))
<         {
<             if ($line =~ / isNon4xx="(\w+)" / || $isNon4xx)
<             {
<                 $isNon4xx = $1 if ($1);
<                 if ($isNon4xx eq 'true')
<                 {
<                     push (@contentForNon4xx, $line);
<                 }
<                 else
<                 {
<                     push (@contentFor4xx, $line);
<                 }
< 
<                 undef ($isNon4xx) if ($line =~ /\/>$|<\/Object>/);
<             }
<             else
<             {
<                 push (@contentFor4xx,    $line);
<                 push (@contentForNon4xx, $line);
<             }
<         }
---
> sub splitResponsesBetween4xxAndNon4xx {
> 	my $responses = shift; 
> 	my $responsesFor4xx = {}; 
> 	my $responsesForNon4xx = {}; 
> 
> 
> 	my @communities = keys(%$responses);
> 	foreach my $community (@communities) {
> 		# Set common fields
> 		foreach my $field (qw(url error)) {
> 			$responsesFor4xx->{$community}{$field} = $responses->{$community}{$field}; 
> 			$responsesForNon4xx->{$community}{$field} = $responses->{$community}{$field}; 
> 		}
> 
> 		# Split xml based on isNon4xx attribute
> 		next unless ($responses->{$community}{content}); 
> 
> 		my @contentFor4xx;
> 		my @contentForNon4xx;
> 		my $isNon4xx;
> 		foreach my $line (split(/\r?\n/, $responses->{$community}{content})) {
> 			if ($line =~ / isNon4xx="(\w+)" / || $isNon4xx) {
> 				$isNon4xx = $1 if ($1);
> 				if ($isNon4xx eq 'true') {
> 					push(@contentForNon4xx, $line); 
> 				} else {
> 					push(@contentFor4xx, $line); 
> 				} 
> 
> 				undef($isNon4xx) if ($line =~ /\/>$|<\/Object>/);
> 			} else {
> 				push(@contentFor4xx, $line); 
> 				push(@contentForNon4xx, $line);
> 			}
> 		}
> 
> 		$responsesFor4xx->{$community}{content} = join("\n", @contentFor4xx);
> 		$responsesForNon4xx->{$community}{content} = join("\n", @contentForNon4xx);
> 	}
204,208c179
<         $responsesFor4xx->{$community}{content}    = join ("\n", @contentFor4xx);
<         $responsesForNon4xx->{$community}{content} = join ("\n", @contentForNon4xx);
<     }
< 
<     return ($responsesFor4xx, $responsesForNon4xx);
---
> 	return ($responsesFor4xx, $responsesForNon4xx);
211,246c182,209
< sub removeProcessedPayloadIdsFromResponses
< {
<     my $processedPayloadIds = shift;
<     my $responses           = shift;
< 
<     my @communities = keys (%$responses);
<     foreach my $community (@communities)
<     {
<         next unless ($responses->{$community}{content});
< 
<         my @content;
<         my $objectContent = '';
<         my $inObject;
<         my $discard;
<         foreach my $line (split (/\r?\n/, $responses->{$community}{content}))
<         {
<             if ($inObject || $line =~ /<Object .* payloadID="([^"]+)"/)
<             {
<                 if ($1)
<                 {
<                     $inObject = 1;
<                     $discard = $processedPayloadIds->{$1} ? 1 : 0;
<                 }
< 
<                 if ($line =~ /\/>$|<\/Object>/)
<                 {
<                     $inObject = 0;
<                 }
< 
<                 push (@content, $line) unless ($discard);
<             }
<             else
<             {
<                 push (@content, $line);
<             }
<         }
---
> sub removeProcessedPayloadIdsFromResponses {
> 	my $processedPayloadIds = shift;
> 	my $responses = shift; 
> 
> 	my @communities = keys(%$responses);
> 	foreach my $community (@communities) {
> 		next unless ($responses->{$community}{content}); 
> 
> 		my @content;
> 		my $objectContent = '';
> 		my $inObject;
> 		my $discard;
> 		foreach my $line (split(/\r?\n/, $responses->{$community}{content})) {
> 			if ($inObject || $line =~ /<Object .* payloadID="([^"]+)"/) {
> 				if ($1) { 
> 					$inObject = 1;
> 					$discard = $processedPayloadIds->{$1} ? 1 : 0;
> 				}
> 				
> 				if ($line =~ /\/>$|<\/Object>/) {
> 					$inObject = 0;
> 				}
> 
> 				push(@content, $line) unless ($discard);
> 			} else {
> 				push(@content, $line); 
> 			}
> 		}
248,249c211,212
<         $responses->{$community}{content} = join ("\n", @content);
<     }
---
> 		$responses->{$community}{content} = join("\n", @content);
> 	}
252,271c215,226
< sub processResultsFromResponses
< {
<     my $responses           = shift;
<     my $processedPayloadIds = shift;
< 
<     my @output;
<     my @xmlOutput;
<     my @errors;
<     my $commonStyle = "white-space:nowrap;padding-right:1em;text-align:left";
<     my @fields      = qw(documentNumber payloadID currentStatus stuckMinutes stuckTime documentSubmitTime errorReason ErrorReason);
<     my %inf_fields = (
<                       documentNumber     => 'document_number',
<                       payloadID          => 'payload_id',
<                       currentStatus      => 'current_status',
<                       stuckMinutes       => 'stuck_mins',
<                       stuckTime          => 'stuck_time',
<                       documentSubmitTime => 'document_submit_time',
<                       ErrorReason        => 'error_reason'
<                      );
<     my @headers;
---
> sub processResultsFromResponses {
> 	my $responses = shift;
> 	my $processedPayloadIds = shift;
> 	my $self = $ariba::monitor::Query::_ourGlobalQuerySelf;
> 	
> 	$self->deleteError();
> 	my @output;
> 	my @xmlOutput;
> 	my @errors;
> 	my $commonStyle = "white-space:nowrap;padding-right:1em;text-align:left";
> 	my @fields = qw(documentNumber payloadID currentStatus stuckMinutes stuckTime documentSubmitTime errorReason ErrorReason);
> 	my @headers; 
272a228
> 	my $shouldPage = defined($self->severity()) && $self->severity() == 0;
274,406c230,345
<     my @communities = keys (%$responses);
< 
<     foreach my $community (sort @communities)
<     {
<         my $response = $responses->{$community}{content} || '';
<         my $url      = $responses->{$community}{url};
<         my $error    = $responses->{$community}{error};
<         if ($error)
<         {
<             push (@errors, $error);
<             next;
<         }
< 
<         unless ($response =~ /BusinessProcessMonitoringResponse/)
<         {
<             push (@errors, "Non-XML or bad response: " . HTML::Entities::encode_entities($response));
<             next
<         }
< 
<         my $xml = eval {XMLin($response, ForceArray => [qw/Threshold Buyer Supplier Object/], KeyAttr => [qw/level anid id/]);};
<         if ($@)
<         {
<             push (@errors, "XML parse error for content: $@");
<             next;
<         }
< 
<         unless ($xml && ref ($xml) eq 'HASH')
<         {
<             push (@errors, "Response is empty or not XML");
<             next;
<         }
< 
<         $response =~ s/<\?.*\?>//;          # Remove the xml declaration
<         $response =~ s/^\s+</</gm;          # Remove white space before tag
<         $response =~ s/>\s*\r?\n\s*/>/g;    # Remove white space/return/newline after tag
<         push (@xmlOutput, "<Community name=\"$community\">$response</Community>");
< 
<         my $thresholdDescription = '{level} is {threshold}';
<         if ($xml->{Metric})
<         {
<             $thresholdDescription = $xml->{Metric}{ThresholdDescription} if ($xml->{Metric}{ThresholdDescription});
<         }
< 
<         foreach my $thresholdType (qw(critical warning))
<         {
<             next unless (   $xml->{Threshold}
<                          && $xml->{Threshold}{$thresholdType}
<                          && $xml->{Threshold}{$thresholdType}{Buyer});
<             my $defaultThreshold = $xml->{Threshold}{$thresholdType}{default};
<             my $buyerData        = $xml->{Threshold}{$thresholdType}{Buyer};
<             my $status           = 'warn';
<             $status = 'crit' if ($thresholdType eq 'critical');
< 
<             foreach my $buyerId (keys (%$buyerData))
<             {
<                 my $supplierData = $buyerData->{$buyerId}{Supplier};
<                 next unless ($supplierData);
<                 my $buyerThreshold = $buyerData->{$buyerId}{threshold};
<                 my $buyerName      = $buyerData->{$buyerId}{name};
< 
<                 foreach my $supplierId (keys (%$supplierData))
<                 {
<                     my $data = $supplierData->{$supplierId}{Object};
<                     next unless ($data);
<                     my $supplierThreshold = $supplierData->{$supplierId}{threshold};
<                     my $supplierName      = $supplierData->{$supplierId}{name};
< 
<                     foreach my $row (@$data)
<                     {
<                         my $buildHeaders = !@headers;
<                         push (@headers, qw(Buyer Supplier)) if ($buildHeaders);
<                         my @columns = qq(buyer=$buyerId ($buyerName)||supplier=$supplierId ($supplierName));
<                         my $errorReason;
< 
<                         foreach my $field (@fields)
<                         {
<                             next unless exists ($row->{$field});
< 
<                             my $value = $row->{$field};
< 
<                             if ($buildHeaders)
<                             {
<                                 if ($field eq 'stuckTime')
<                                 {
<                                     push (@headers, ucfirst ('stuckMinutes'));
<                                 }
<                                 elsif ($field !~ /errorReason/i)
<                                 {
<                                     push (@headers, ucfirst ($field));
<                                 }
<                             }
< 
<                             if ($field =~ /stuck(?:Time|Minutes)/)
<                             {
<                                 $value = int ($value) if (defined ($value));
<                             }
< 
<                             if ($field =~ /errorReason/i)
<                             {
<                                 $value =~ s/<|>//g;
<                                 $value =~ s/\r?\n/<br>/g;
<                                 $errorReason = $value;
<                             }
<                             else
<                             {
<                                 push (@columns, qq($inf_fields{$field}=$value));
<                             }
< 
<                             if (ref ($processedPayloadIds) eq 'HASH' && $field eq 'payloadID')
<                             {
<                                 $processedPayloadIds->{$value} = 1;
<                             }
<                         }
< 
<                         my $thresholdTip = replaceTokens(
<                                                          $thresholdDescription,
<                                                          {
<                                                           level     => $thresholdType,
<                                                           threshold => $supplierThreshold || $buyerThreshold || $defaultThreshold
<                                                          }
<                                                         );
<                         my $thresholdSource = 'internal';
<                         if ($supplierThreshold)
<                         {
<                             $thresholdSource = 'supplier';
<                         }
<                         elsif ($buyerThreshold)
<                         {
<                             $thresholdSource = 'buyer';
<                         }
<                         $thresholdTip .= " ($thresholdSource)";
<                         $thresholdTip =~ s/'/\\'/g;
< 
---
> 	my @communities = keys(%$responses);
> 	foreach my $community (sort @communities) { 
> 		my $response = $responses->{$community}{content} || ''; 
> 		my $url = $responses->{$community}{url};
> 		my $error = $responses->{$community}{error};
> 
> 		$self->setUrl($url);
> 
> 		if ($error) {
> 			push(@errors, $error); 
> 			next;
> 		}
> 
> 		unless ($response =~ /BusinessProcessMonitoringResponse/) {
> 			push(@errors, "Non-XML or bad response: " . HTML::Entities::encode_entities($response)); 
> 			next
> 		}
> 
> 		my $xml = eval { XMLin($response, ForceArray => [qw/Threshold Buyer Supplier Object/], KeyAttr => [qw/level anid id/]); }; 
> 		if ($@) {
> 			push(@errors, "XML parse error for content: $@"); 
> 			next;
> 		}
> 		
> 		unless ($xml && ref($xml) eq 'HASH') {
> 			push(@errors, "Response is empty or not XML");
> 			next;
> 		}
> 
> 		$response =~ s/<\?.*\?>//;			# Remove the xml declaration
> 		$response =~ s/^\s+</</gm;			# Remove white space before tag
> 		$response =~ s/>\s*\r?\n\s*/>/g;	# Remove white space/return/newline after tag
> 		push(@xmlOutput, "<Community name=\"$community\">$response</Community>");
> 		
> 		
> 		my $thresholdDescription = '{level} is {threshold}';
> 		if ($xml->{Metric}) {
> 			$thresholdDescription = $xml->{Metric}{ThresholdDescription} if ($xml->{Metric}{ThresholdDescription});
> 			$self->setDescription($xml->{Metric}{Description}) if (!$self->description() && $xml->{Metric}{Description});
> 		}
> 
> 		foreach my $thresholdType (qw(critical warning)) {
> 			next unless ($xml->{Threshold} && $xml->{Threshold}{$thresholdType} && 
> 				$xml->{Threshold}{$thresholdType}{Buyer}); 
> 			my $defaultThreshold = $xml->{Threshold}{$thresholdType}{default};
> 			my $buyerData = $xml->{Threshold}{$thresholdType}{Buyer};
> 			my $status = 'warn';
> 			$status = 'crit' if ($thresholdType eq 'critical');
> 			if ($self->severity() && $thresholdType eq 'critical' && scalar(keys(%$buyerData)) > 1) {
> 				$self->setSeverity(0);
> 				$shouldPage = 1; 
> 			}
> 
> 			foreach my $buyerId (keys(%$buyerData)) {
> 				my $supplierData = $buyerData->{$buyerId}{Supplier};
> 				next unless ($supplierData);
> 				my $buyerThreshold = $buyerData->{$buyerId}{threshold};
> 				my $buyerName = $buyerData->{$buyerId}{name}; 
> 				
> 				foreach my $supplierId (keys(%$supplierData)) {
> 					my $data = $supplierData->{$supplierId}{Object};
> 					next unless ($data);
> 					my $supplierThreshold = $supplierData->{$supplierId}{threshold}; 
> 					my $supplierName = $supplierData->{$supplierId}{name}; 
> 
> 					foreach my $row (@$data) {
> 						my $buildHeaders = !@headers;
> 						push(@headers, qw(Buyer Supplier)) if ($buildHeaders);
> 						my @columns = ("$buyerId ($buyerName)", "$supplierId ($supplierName)");
> 						my $errorReason;
> 
> 						foreach my $field (@fields) {
> 							next unless exists($row->{$field});
> 
> 							my $value = $row->{$field};
> 		
> 							if ($buildHeaders) {	
> 								if ($field eq 'stuckTime') {
> 									push(@headers, ucfirst('stuckMinutes')); 
> 								} elsif ($field !~ /errorReason/i) {
> 									push(@headers, ucfirst($field)); 
> 								}
> 							}
> 
> 							if ($field =~ /stuck(?:Time|Minutes)/) {
> 								$value = int($value) if (defined($value));
> 							}
> 
> 							if ($field =~ /errorReason/i) {
> 								$value =~ s/<|>//g;
> 								$value =~ s/\r?\n/<br>/g;
> 								$errorReason = $value;
> 							} else {
> 								push(@columns, $value);
> 							}
> 
> 							if (ref($processedPayloadIds) eq 'HASH' && $field eq 'payloadID') {
> 								$processedPayloadIds->{$value} = 1;	
> 							}
> 						}
> 
> 						my $thresholdTip = replaceTokens($thresholdDescription, {
> 								level => $thresholdType, 
> 								threshold => $supplierThreshold || $buyerThreshold || $defaultThreshold
> 							});
> 						my $thresholdSource = 'internal';
> 						if ($supplierThreshold) {
> 							$thresholdSource = 'supplier'; 
> 							$shouldPage = 1;
> 						} elsif ($buyerThreshold) {
> 							$thresholdSource = 'buyer'; 
> 							$shouldPage = 1;
> 						}
> 						$thresholdTip .= " ($thresholdSource)";
> 						$thresholdTip =~ s/'/\\'/g;
> 						
408,419c347,356
<                         my %toolTips = (
<                                         Status    => ucfirst ($thresholdType),
<                                         Threshold => $thresholdTip,
<                                        );
< 
<                         $toolTips{'Error Reason'} = $errorReason if ($errorReason);
<                         my $toolTip = '';
<                         foreach my $field (sort keys (%toolTips))
<                         {
<                             my $value = $toolTips{$field};
<                             $value =~ s/'/"/g;    # Prevent breaking title html below
<                             $toolTip .= "<p class=\"indentSecondLine\"><b>$field</b>: $value</p>";
---
> 						my %toolTips = (
> 							Status => ucfirst($thresholdType), 
> 							Threshold => $thresholdTip,
> 						);
> 
>                         # Weekend outage for Sysco should show as info
>                         # Saturdays from 7pm to 11pm PT
>                         if($self->queryName() =~ m/EDI Gateway to Supplier/i and $buyerId eq 'AN01002330463' and $outage->isInScheduledOutage()) {
>                             $statusForColor = "info";
>                             $toolTips{'Status'} .= " (outage)";
421,427d357
<                         push (@output, join ("||", @columns));
< 
<                     }
<                 }
<             }
<         }
<     }
429,432c359,401
<     if (@errors)
<     {
<         unshift (@output, @errors);
<     }
---
> 						$toolTips{'Error Reason'} = $errorReason if ($errorReason);
> 						my $toolTip = ''; 
> 						foreach my $field (sort keys(%toolTips)) {
> 							my $value = $toolTips{$field};
> 							$value =~ s/'/"/g;  # Prevent breaking title html below
> 							$toolTip .= "<p class=\"indentSecondLine\"><b>$field</b>: $value</p>";
> 						}
> 
> 						my $color = ariba::monitor::StatusPage::colorToRGB(ariba::monitor::StatusPage::statusToColor($statusForColor));
> 
> 						my $style = "style='background-color:$color;$commonStyle'";
> 						my $td = "<td $style>";
> 						my $statusAndTip = "<!-- status: $thresholdType --> $td<i title='$toolTip'>i</i></td> ";
> 						push(@output, "<html>$statusAndTip $td" . join("</td>$td", @columns) . "</td></html>");
> 
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	if (!$shouldPage && $self->crit()) {
> 		# Only change if there is a 'warn'. If no warn, then do crit always. 
> 		if (my $warn = $self->warn()) {
> 			my $crit = $self->crit(); 
> 			$self->deleteCrit(); 
> 			$self->setWarn("$warn || $crit");
> 		}
> 	}
> 
> 	
> 	if (@errors) {
> 		$self->setError(join("\n", @errors));
> 		unshift(@output, $self->error());
> 	}	
> 	$self->setXmlResults(join('', @xmlOutput) || '<!-- No results -->');
> 	$self->setRowCount(scalar(@output));
> 	$self->setMultiRow(1);
> 
> 	if (@output) {
> 		my $th = "<th style='$commonStyle'>";
> 		unshift(@output, "<html><th></th>$th" . join("</th>$th", @headers) . "</th></html>") if (@headers); 
> 	}
434c403
<     return (@output);
---
> 	return join("\n", @output);
436a406
> 
filename:./lib/ariba/monitor/ProductStatus.pm
filename:./lib/ariba/monitor/StatusPage.pm
filename:./lib/ariba/monitor/Utils.pm
filename:./lib/ariba/rc/AppInstanceManager.pm
filename:./lib/ariba/rc/TomcatAppInstance.pm
filename:./bin/common/sizeof-bulk-allocated-resources
15d14
< use Data::Dumper;
20,78c19,76
<     my $debug = 0;
<     my $quiet = 0;
<     my $sendEmail = 0;
<     my $sendPage = 0;
<     my $productName;
< 
<     while(my $arg=shift(@ARGV)){
<             print STDERR "parsing arg $arg\n" if $debug && !$quiet;
<             if($arg =~ /^-d/o){ $debug=1; }
<             if($arg =~ /^-e/o){ $sendEmail=1; };
<             if($arg =~ /^-p$/o){ $sendPage=1; };
<             if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
< 
<     my $product;
<     unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
<         exit(0);
<     }
<     $product = ariba::rc::InstalledProduct->new($productName, $service);
< 
<     my $skip = 0;
< 
<     my %queries  = ();
< 
<     $queries{"Number of realms (total)"} = {
<         info => 1,
<         sql => q`
<             select count(*) as realm_total from realmtab;
<             `,
<         recordMaxResults => $maxResults,
<         recordDataType => 'gauge',
<         recordItem => 'answer'
<         
<     };
< 
<     # buyer has realms of different variant types:
<     my @variants = ();
<     my $success = allVariants($product, \@variants);
<     my $realmsRemainingSql = "select count(*) as unallocated from realmtab where state='unassigned'";
<     my $oracleRealmsRemainingSql = "select count(*) as unallocated from realmtab where state='unassigned' and (dbtype = 'oracle' or dbtype is null)";
<     my $hanaRealmsRemainingSql = "select count(*) as unallocated from realmtab where state='unassigned' and dbtype = 'hana'";
< 
<     #
<     # on failure to fetch variants (e.g. due to oracle being down)
<     # don't create dummy queries that will go stale later and cause
<     # confusion
<     #
< 
<     if ($success) {
<         if (@variants) {
<             for my $variantHash (@variants) {
<                 my $variant = $variantHash->{'BASEDOMAINVARIANT'};
<                 my $realmsRemainingOfTypeSql = "$realmsRemainingSql and basedomainvariant=\'$variant\'";
<                 my $warn = 60;
<                 my $crit = 30;
---
> 	my $debug = 0;
> 	my $quiet = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while(my $arg=shift(@ARGV)){
> 			print STDERR "parsing arg $arg\n" if $debug && !$quiet;
> 			if($arg =~ /^-d/o){ $debug=1; }
> 			if($arg =~ /^-e/o){ $sendEmail=1; };
> 			if($arg =~ /^-p$/o){ $sendPage=1; };
> 			if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 
> 	my $product;
> 	unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
> 		exit(0);
> 	}
> 	$product = ariba::rc::InstalledProduct->new($productName, $service);
> 
> 	my $skip = 0;
> 
> 	my %queries  = ();
> 
> 	$queries{"Number of realms (total)"} = {
> 		info => 1,
> 		sql => q`
> 			select count(*) from realmtab;
> 			`,
> 		recordMaxResults => $maxResults,
> 		recordDataType => 'gauge',
> 		recordItem => 'answer'
> 		
> 	};
> 
> 	# buyer has realms of different variant types:
> 	my @variants = ();
> 	my $success = allVariants($product, \@variants);
> 	my $realmsRemainingSql = "select count(*) from realmtab where state='unassigned'";
> 	my $oracleRealmsRemainingSql = "select count(*) from realmtab where state='unassigned' and (dbtype = 'oracle' or dbtype is null)";
> 	my $hanaRealmsRemainingSql = "select count(*) from realmtab where state='unassigned' and dbtype = 'hana'";
> 
> 	#
> 	# on failure to fetch variants (e.g. due to oracle being down)
> 	# don't create dummy queries that will go stale later and cause
> 	# confusion
> 	#
> 
> 	if ($success) {
> 		if (@variants) {
> 			for my $variant (@variants) {
> 				my $realmsRemainingOfTypeSql = "$realmsRemainingSql and basedomainvariant=\'$variant\'";
> 				my $warn = 60;
> 				my $crit = 30;
81,86c79,84
<                     $warn = 20;
<                     $crit = 10;
<                 }
<                 if ($variant eq "vpsoft84ora") {    
<                     $warn = 15;
<                     $crit = 10;
---
> 					$warn = 20;
> 					$crit = 10;
> 				}
> 				if ($variant eq "vpsoft84ora") {	
> 					$warn = 15;
> 					$crit = 10;
89,91c87,89
<                         $warn = 10;
<                         $crit = 5;
<                     }
---
> 						$warn = 10;
> 						$crit = 5;
> 					}
106,109c104,107
<                 }
<                 if ($variant eq "vsap") {   
<                     $warn = 25;
<                     $crit = 15;
---
> 				}
> 				if ($variant eq "vsap") {	
> 					$warn = 25;
> 					$crit = 15;
112,114c110,112
<                         $warn = 20;
<                         $crit = 10;
<                     }
---
> 						$warn = 20;
> 						$crit = 10;
> 					}
128c126
<                     }
---
> 				    }
147,167c145,161
<                 if ($service eq 'sales') {
<                     $crit = 5;
<                 }
<                 $queries{"Number of realms for variant $variant (unallocated)"} = {
<                     info => "answer",
<                     warn => "answer && answer < $warn",
<                     crit => "!answer || answer <= $crit",
<                     sql => $realmsRemainingOfTypeSql,
<                     recordMaxResults => $maxResults,
<                     recordDataType => 'gauge',
<                     recordItem => 'answer',
<                     ticketOnWarnOpenAfterMinutes => 1,
<                     inf_field => "num_of_realms_unallocated",
<                     inf_tags  => qq(type="$variant"),
<                     inf_default => 0,
<                     group_by  => $variant,
<                 };
<             }
<         } else {
<             my $crit = 50;
<             my $warn = 100;
---
> 				if ($service eq 'sales') {
> 					$crit = 5;
> 				}
> 				$queries{"Number of realms for variant $variant (unallocated)"} = {
> 					info => "answer",
> 					warn => "answer && answer < $warn",
> 					crit => "!answer || answer <= $crit",
> 					sql => $realmsRemainingOfTypeSql,
> 					recordMaxResults => $maxResults,
> 					recordDataType => 'gauge',
> 					recordItem => 'answer',
> 					ticketOnWarnOpenAfterMinutes => 1,
> 				};
> 			}
> 		} else {
> 			my $crit = 50;
> 			my $warn = 100;
170,172c164,166
<                 $warn = 20;
<                 $crit = 10;
<             }
---
> 				$warn = 20;
> 				$crit = 10;
> 			}
190,208c184,198
<             $crit  = 5 if $service eq 'sales';
<             $queries{"Number of Oracle realms (unallocated)"} = {
<                 info => "answer",
<                 warn => "answer && answer < $warn",
<                 crit => "!answer || answer <= $crit",
<                 sql => $oracleRealmsRemainingSql,
<                 recordMaxResults => $maxResults,
<                 recordDataType => 'gauge',
<                 recordItem => 'answer',
<                 ticketOnWarnOpenAfterMinutes => 1,
<                 inf_field  => "num_of_realms",
<                 inf_tags   => qq(type="oracle"),
<                 inf_default => 0,
<                 group_by  => "oralce",
<             };
< 
<                 #
<                 # We currently support s4 product for HANA S4 Lite
<                 # Since this monitor support both buyer and s4 products we have to enable 
---
> 			$crit  = 5 if $service eq 'sales';
> 			$queries{"Number of Oracle realms (unallocated)"} = {
> 				info => "answer",
> 				warn => "answer && answer < $warn",
> 				crit => "!answer || answer <= $crit",
> 				sql => $oracleRealmsRemainingSql,
> 				recordMaxResults => $maxResults,
> 				recordDataType => 'gauge',
> 				recordItem => 'answer',
> 				ticketOnWarnOpenAfterMinutes => 1,
> 			};
> 
> 	            #
> 	            # We currently support s4 product for HANA S4 Lite
> 	            # Since this monitor support both buyer and s4 products we have to enable 
211,224c201,210
<             $queries{"Number of HANA realms (unallocated)"} = {
<                 info => "answer",
<                 warn => "answer && answer < $warn",
<                 crit => "!answer || answer <= $crit",
<                 sql => $hanaRealmsRemainingSql,
<                 recordMaxResults => $maxResults,
<                 recordDataType => 'gauge',
<                 recordItem => 'answer',
<                 ticketOnWarnOpenAfterMinutes => 1,
<                 inf_field  => "num_of_realms",
<                 inf_tags   => qq(type="hana"),
<                 inf_default => 0,
<                 group_by  => "hana",
<             };
---
> 			$queries{"Number of HANA realms (unallocated)"} = {
> 				info => "answer",
> 				warn => "answer && answer < $warn",
> 				crit => "!answer || answer <= $crit",
> 				sql => $hanaRealmsRemainingSql,
> 				recordMaxResults => $maxResults,
> 				recordDataType => 'gauge',
> 				recordItem => 'answer',
> 				ticketOnWarnOpenAfterMinutes => 1,
> 			};
226,227c212,213
<         }
<     }
---
> 		}
> 	}
229,280c215,266
<     $queries{"Density of instance field mapping"} = {
<         format => "%30s %s %d",
<         info => 1,
<         #warn => "answer && answer < 10",
<         #crit => "!answer || answer <= 4",
<         noRowCount => 1,
<         sql => q`
<             select distinct storagefieldname as storage_fieldname, storageclassname as storage_classname,
<             count(storagefieldname) as storage_count from dynamicfieldmaptab 
<             where rowNumber != -1
<             group by storagefieldname, storageclassname, storagevariantname 
<             having count(storagefieldname) >= 3
<             order by count(storagefieldname) desc 
<             `,
<     };
< 
<         my $sqlWithoutWhereClause = q`
<             select overall.cname class, overall.ftype fieldtype, mapped.vname variant, 
<                 mapped.cstar/overall.cstar ratio, mapped.cstar mapped_count, overall.cstar overall_count
<             from 
<                 (select m.classname cname, m.fieldtype ftype, count(*) cstar 
<                 from metalayouttab m 
<                 where m.fieldname like 'UF%' 
<                 group by m.classname, m.fieldtype) overall 
<             inner join 
<                 (select distinct m.classname cname, m.fieldtype ftype, d.storagevariantname vname, count(*) cstar 
<                 from metalayouttab m inner join dynamicfieldmaptab d 
<                 on m.fieldname = d.storagefieldname and m.classname = d.storageclassname 
<                 where m.fieldname like 'UF%' 
<                 group by m.classname, m.fieldtype, d.storagevariantname) mapped 
<                 on overall.cname = mapped.cname and overall.ftype = mapped.ftype`; 
<     $queries{"Flex Field that are 60% used"} = {
<         #format => "%30s %s %d",
<         info => 1,
<         skip => 1,
<         warn => "numrows > 5",
<         sql => "$sqlWithoutWhereClause where mapped.cstar/overall.cstar > 0.6 order by ratio desc",
<     };
< 
<     $queries{"Flex Field that are 85% used"} = {
<         #format => "%30s %s %d",
<         info => 1,
<         skip => 1,
<         crit => "numrows >= 1",
<         sql => "$sqlWithoutWhereClause where mapped.cstar/overall.cstar > 0.85 order by ratio desc",
<     };
< 
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = { measurement => 'sizeof_bulk_allocated_resources'};
<     my $q = ariba::monitor::QueryManager->newWithDetails(
<         "sizeof-bulk-allocated-resources", $product->name(), $service, $product->customer(), \%queries
<     );
---
> 	$queries{"Density of instance field mapping"} = {
> 		format => "%30s %s %d",
> 		info => 1,
> 		#warn => "answer && answer < 10",
> 		#crit => "!answer || answer <= 4",
> 		noRowCount => 1,
> 		sql => q`
> 			select distinct storagefieldname, storageclassname,
> 			count(storagefieldname) from dynamicfieldmaptab 
> 			where rowNumber != -1
> 			group by storagefieldname, storageclassname, storagevariantname 
> 			having count(storagefieldname) >= 3
> 			order by count(storagefieldname) desc 
> 			`,
> 	};
> 
> 		my $sqlWithoutWhereClause = q`
> 			select overall.cname class, overall.ftype fieldtype, mapped.vname variant, 
> 				mapped.cstar/overall.cstar ratio, mapped.cstar mapped_count, overall.cstar overall_count
> 			from 
> 				(select m.classname cname, m.fieldtype ftype, count(*) cstar 
> 				from metalayouttab m 
> 				where m.fieldname like 'UF%' 
> 	 			group by m.classname, m.fieldtype) overall 
> 			inner join 
> 				(select distinct m.classname cname, m.fieldtype ftype, d.storagevariantname vname, count(*) cstar 
> 				from metalayouttab m inner join dynamicfieldmaptab d 
> 				on m.fieldname = d.storagefieldname and m.classname = d.storageclassname 
> 				where m.fieldname like 'UF%' 
> 				group by m.classname, m.fieldtype, d.storagevariantname) mapped 
> 				on overall.cname = mapped.cname and overall.ftype = mapped.ftype`; 
> 	$queries{"Flex Field that are 60% used"} = {
> 		#format => "%30s %s %d",
> 		info => 1,
> 		skip => 1,
> 		warn => "numrows > 5",
> 		sql => "$sqlWithoutWhereClause where mapped.cstar/overall.cstar > 0.6 order by ratio desc",
> 	};
> 
> 	$queries{"Flex Field that are 85% used"} = {
> 		#format => "%30s %s %d",
> 		info => 1,
> 		skip => 1,
> 		crit => "numrows >= 1",
> 		sql => "$sqlWithoutWhereClause where mapped.cstar/overall.cstar > 0.85 order by ratio desc",
> 	};
> 
> 	my $email = $me->default('notify.email');
> 
> 	my $q = ariba::monitor::QueryManager->newWithDetails(
> 		"sizeof-bulk-allocated-resources", $product->name(), $service, $product->customer(), \%queries
> 	);
282c268
<     $q->setSQLConnectInfo($product->connectInfoForOracleClient());
---
> 	$q->setSQLConnectInfo($product->connectInfoForOracleClient());
284c270
<     $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
289,290c275,276
<     my $product = shift;
<     my $variantsRef = shift;
---
> 	my $product = shift;
> 	my $variantsRef = shift;
292c278
<     my $productName = $product->name();
---
> 	my $productName = $product->name();
294,295c280,281
<     if ($productName eq "buyer") {
<         my $oc = ariba::Ops::OracleClient->new($product->connectInfoForOracleClient());
---
> 	if ($productName eq "buyer") {
> 		my $oc = ariba::Ops::OracleClient->new($product->connectInfoForOracleClient());
297,307c283,293
<         my $variantsSql = 'select distinct(basedomainvariant) from realmtab';
<         if ($oc->connect()) {
<             unless($oc->executeSqlWithTimeout($variantsSql, undef, $variantsRef)) {
<                 print STDERR "ERROR: Timedout running sql $variantsSql\n";
<                 return 0;
<             }
<         } else {
<             print STDERR "ERROR: connect failed: ", $oc->error(), "\n";
<             return 0;
<         }
<     }
---
> 		my $variantsSql = 'select distinct(basedomainvariant) from realmtab';
> 		if ($oc->connect()) {
> 			unless($oc->executeSqlWithTimeout($variantsSql, undef, $variantsRef)) {
> 				print STDERR "ERROR: Timedout running sql $variantsSql\n";
> 				return 0;
> 			}
> 		} else {
> 			print STDERR "ERROR: connect failed: ", $oc->error(), "\n";
> 			return 0;
> 		}
> 	}
309c295
<     return 1;
---
> 	return 1;
filename:./lib/ariba/Ops/MCL.pm
filename:./lib/ariba/Ops/QualManager.pm
filename:./lib/ariba/Ops/VaultAccess.pm
filename:./lib/ariba/Ops/Sybase/Utils.pm
filename:./bin/s4/sizeof-bulk-allocated-resources
16d15
< use Data::Dumper;
21,90c20,86
<     my $debug = 0;
<     my $quiet = 0;
<     my $sendEmail = 0;
<     my $sendPage = 0;
<     my $productName;
< 
<     while(my $arg=shift(@ARGV)){
<             print STDERR "parsing arg $arg\n" if $debug && !$quiet;
<             if($arg =~ /^-d/o){ $debug=1; }
<             if($arg =~ /^-e/o){ $sendEmail=1; };
<             if($arg =~ /^-p$/o){ $sendPage=1; };
<             if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
<     }
< 
<     my $me = ariba::rc::InstalledProduct->new();
<     my $cluster = $me->currentCluster();
<     my $service = $me->service();
< 
<     my $product;
<     unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
<         exit(0);
<     }
<     $product = ariba::rc::InstalledProduct->new($productName, $service);
< 
< 
<     my ($sharedStarSchemas, $dedicatedStarSchemas);
<     my @dedicatedConn = ariba::Ops::DBConnection->connectionsForProductOfDBType(
<             $product, ariba::Ops::DBConnection->typeMainStarDedicated());
<     $dedicatedStarSchemas = scalar(@dedicatedConn);
<     my @sharedConn = ariba::Ops::DBConnection->connectionsForProductOfDBType(
<             $product, ariba::Ops::DBConnection->typeMainStarShared());
<     $sharedStarSchemas = scalar(@sharedConn);
< 
<     my(%bySid);
< 
<     foreach my $conn (@dedicatedConn) {
<         my $sid = $conn->sid();
<         $bySid{$sid} = {} unless defined($bySid{$sid});
<         $bySid{$sid}->{$conn->schemaId()} = 1;
<     }
< 
<     my $defaultDbc = ariba::Ops::DBConnection->connectionsForProductOfDBType($product, ariba::Ops::DBConnection->typeMain());
<     my $oc = ariba::Ops::OracleClient->newFromDBConnection($defaultDbc);
<     my $sql = "select distinct databaseschema as dbschema from schematypemaptab where schematype = 'Star' and isDedicated = 1";
< 
<     exit unless $oc->connect();
<     my @usedSchemas = $oc->executeSql($sql);
< 
<     foreach my $schemaHash (@usedSchemas) {
<          my $schema = $schemaHash->{DBSCHEMA};
<         $schema =~ m/(\d+)$/;
<         my $id = $1;
<         foreach my $key (keys %bySid) {
<             delete $bySid{$key}->{$id} if($bySid{$key}->{$id});
<         }
<     }
< 
<     my $skip = 0;
< 
<     my %queries  = ();
< 
<     $queries{"Number of dedicated star schemas (total)"} = {
<         info => 1,
<         perl => $dedicatedStarSchemas,
<         recordMaxResults => $maxResults,
<         recordDataType => 'gauge',
<         recordItem => 'answer',
<         inf_field => "dedicated_star_schemas_total",
<         inf_default => 0,
<     };
---
> 	my $debug = 0;
> 	my $quiet = 0;
> 	my $sendEmail = 0;
> 	my $sendPage = 0;
> 	my $productName;
> 
> 	while(my $arg=shift(@ARGV)){
> 			print STDERR "parsing arg $arg\n" if $debug && !$quiet;
> 			if($arg =~ /^-d/o){ $debug=1; }
> 			if($arg =~ /^-e/o){ $sendEmail=1; };
> 			if($arg =~ /^-p$/o){ $sendPage=1; };
> 			if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
> 	}
> 
> 	my $me = ariba::rc::InstalledProduct->new();
> 	my $cluster = $me->currentCluster();
> 	my $service = $me->service();
> 
> 	my $product;
> 	unless (ariba::rc::InstalledProduct->isInstalled($productName, $service)) {
> 		exit(0);
> 	}
> 	$product = ariba::rc::InstalledProduct->new($productName, $service);
> 
> 
> 	my ($sharedStarSchemas, $dedicatedStarSchemas);
> 	my @dedicatedConn = ariba::Ops::DBConnection->connectionsForProductOfDBType(
> 			$product, ariba::Ops::DBConnection->typeMainStarDedicated());
> 	$dedicatedStarSchemas = scalar(@dedicatedConn);
> 	my @sharedConn = ariba::Ops::DBConnection->connectionsForProductOfDBType(
> 			$product, ariba::Ops::DBConnection->typeMainStarShared());
> 	$sharedStarSchemas = scalar(@sharedConn);
> 
> 	my(%bySid);
> 
> 	foreach my $conn (@dedicatedConn) {
> 		my $sid = $conn->sid();
> 		$bySid{$sid} = {} unless defined($bySid{$sid});
> 		$bySid{$sid}->{$conn->schemaId()} = 1;
> 	}
> 
> 	my $defaultDbc = ariba::Ops::DBConnection->connectionsForProductOfDBType($product, ariba::Ops::DBConnection->typeMain());
> 	my $oc = ariba::Ops::OracleClient->newFromDBConnection($defaultDbc);
> 	my $sql = "select distinct databaseschema from schematypemaptab where schematype = 'Star' and isDedicated = 1";
> 
> 	exit unless $oc->connect();
> 	my @usedSchemas = $oc->executeSql($sql);
> 
> 	foreach my $schema (@usedSchemas) {
> 		$schema =~ m/(\d+)$/;
> 		my $id = $1;
> 		foreach my $key (keys %bySid) {
> 			delete $bySid{$key}->{$id} if($bySid{$key}->{$id});
> 		}
> 	}
> 
> 	my $skip = 0;
> 
> 	my %queries  = ();
> 
> 	$queries{"Number of dedicated star schemas (total)"} = {
> 		info => 1,
> 		perl => $dedicatedStarSchemas,
> 		recordMaxResults => $maxResults,
> 		recordDataType => 'gauge',
> 		recordItem => 'answer'
> 	};
95,101c91,97
<     foreach my $key (keys %bySid) {
<         my $availSchemas = scalar keys(%{$bySid{$key}});
<         my ($warn, $crit);
< 
<         # Warn and Crit values for unallocated dedicated schemas should be the same accross all production services
<         # Tracked by: HOA-14511
<         if (ariba::Ops::ServiceController::isProductionServicesOnly($service)){
---
> 	foreach my $key (keys %bySid) {
> 		my $availSchemas = scalar keys(%{$bySid{$key}});
> 		my ($warn, $crit);
> 
> 		# Warn and Crit values for unallocated dedicated schemas should be the same accross all production services
> 		# Tracked by: HOA-14511
> 		if (ariba::Ops::ServiceController::isProductionServicesOnly($service)){
104c100
<         }
---
> 		}
106,188c102,173
<         if ($service =~ /sales/i) {
<             $warn = "answer <= 10";
<             $crit = "answer <= 5";
<         }
< 
<         $queries{"Number of dedicated star schemas on $key (unallocated)"} = {
<             info => 1,
<             warn => $warn,
<             crit => $crit,
<             perl => $availSchemas,
<             recordMaxResults => $maxResults,
<             recordDataType => 'gauge',
<             recordItem => 'answer',
<             ticketOnWarnOpenAfterMinutes => 1,
<             inf_field => "dedicated_star_schema",
<             inf_tags  => qq(schema_name="$key"),
<             inf_default => 0,
<             group_by => $key,
<         };
<     }
< 
<     $queries{"Number of dedicated star schemas (unallocated)"} = {
<         info => 1,
<         sql => "select ($dedicatedStarSchemas - count(distinct databaseschema)) as dedicated_star_schemas from schematypemaptab where schematype = 'Star' and isDedicated = 1",
<         recordMaxResults => $maxResults,
<         recordDataType => 'gauge',
<         recordItem => 'answer',
<     };
< 
<     $queries{"Number of shared star schemas (total)"} = {
<         info => 1,
<         perl => $sharedStarSchemas,
<         recordMaxResults => $maxResults,
<         recordDataType => 'gauge',
<         recordItem => 'answer',
<         inf_field => "shared_star_schema_total",
<         inf_default => 0,
<     };
< 
<     my $dbc = ariba::Ops::DBConnection->connectionsForProductOfDBType(
<         $product, ariba::Ops::DBConnection->typeMain()
<     );
< 
<     undef($oc);
<     if($dbc) {
<         $oc = ariba::Ops::OracleClient->newFromDBConnection($dbc);
<     }
<     if($oc && $oc->connect()) {
< 
<         my $sql = q`
<             select
<                 distinct databaseschema as dbschemas, count(databaseschema) as schema_cnt
<             from
<                 schematypemaptab
<             where
<                 schematype = 'Star' and isDedicated = 0 and realmid != -1
<             group by databaseschema
<             order by count(databaseschema) desc
<         `;
<         my @results = $oc->executeSql($sql);
< 
<         foreach my $row (@results) {
<             my $schemaName = $row->{DBSCHEMAS};
<             my $realmCount = $row->{SCHEMA_CNT};
<             $queries{"Number of realms for shared star schema $schemaName"} = {
<                 info => 1,
<                 perl => $realmCount,
<                 recordMaxResults => $maxResults,
<                 recordDataType => 'gauge',
<                 recordItem => 'answer',
<                 inf_field  => "realm_cnt",
<                 inf_tags   => qq(schema="$schemaName"),
<                 inf_default => 0,
<                 group_by => $schemaName,
<             };
<         }
<     }
< 
<     my $email = $me->default('notify.email');
<     $queries{influx_details} = { measurement => 'sizeof_bulk_allocated_resources' };
<     my $q = ariba::monitor::QueryManager->newWithDetails(
<         "sizeof-bulk-allocated-resources", $product->name(), $service, $product->customer(), \%queries
<     );
---
> 		if ($service =~ /sales/i) {
> 			$warn = "answer <= 10";
> 			$crit = "answer <= 5";
> 		}
> 
> 		$queries{"Number of dedicated star schemas on $key (unallocated)"} = {
> 			info => 1,
> 			warn => $warn,
> 			crit => $crit,
> 			perl => $availSchemas,
> 			recordMaxResults => $maxResults,
> 			recordDataType => 'gauge',
> 			recordItem => 'answer',
> 			ticketOnWarnOpenAfterMinutes => 1,
> 		};
> 	}
> 
> 	$queries{"Number of dedicated star schemas (unallocated)"} = {
> 		info => 1,
> 		sql => "select ($dedicatedStarSchemas - count(distinct databaseschema)) from schematypemaptab where schematype = 'Star' and isDedicated = 1",
> 		recordMaxResults => $maxResults,
> 		recordDataType => 'gauge',
> 		recordItem => 'answer'
> 	};
> 
> 	$queries{"Number of shared star schemas (total)"} = {
> 		info => 1,
> 		perl => $sharedStarSchemas,
> 		recordMaxResults => $maxResults,
> 		recordDataType => 'gauge',
> 		recordItem => 'answer'
> 	};
> 
> 	my $dbc = ariba::Ops::DBConnection->connectionsForProductOfDBType(
> 		$product, ariba::Ops::DBConnection->typeMain()
> 	);
> 
> 	undef($oc);
> 	if($dbc) {
> 		$oc = ariba::Ops::OracleClient->newFromDBConnection($dbc);
> 	}
> 	if($oc && $oc->connect()) {
> 
> 		my $sql = q`
> 			select
> 				distinct databaseschema, count(databaseschema)
> 			from
> 				schematypemaptab
> 			where
> 				schematype = 'Star' and isDedicated = 0 and realmid != -1
> 			group by databaseschema
> 			order by count(databaseschema) desc
> 		`;
> 		my @results = $oc->executeSql($sql);
> 
> 		foreach my $row (@results) {
> 			my ($schemaName, $realmCount) = split($oc->colsep(), $row);
> 			$queries{"Number of realms for shared star schema $schemaName"} = {
> 				info => 1,
> 				perl => $realmCount,
> 				recordMaxResults => $maxResults,
> 				recordDataType => 'gauge',
> 				recordItem => 'answer'
> 			};
> 		}
> 	}
> 
> 	my $email = $me->default('notify.email');
> 
> 	my $q = ariba::monitor::QueryManager->newWithDetails(
> 		"sizeof-bulk-allocated-resources", $product->name(), $service, $product->customer(), \%queries
> 	);
190c175
<     $q->setSQLConnectInfo($product->connectInfoForOracleClient());
---
> 	$q->setSQLConnectInfo($product->connectInfoForOracleClient());
192c177
<     $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/3par-vv-cache-stats
131c131
< 				if ($nm->vvCacheStats->{$vv}) {
---
> 				if ($nm->vvCacheStats->{$vv}) { 
136c136
< 
---
> 	
144c144
< 			my $warning = 0;
---
> 			my $warning = 0; 
147c147
< 			my $fsTotalReadHitRatio = -1;  # we need to record 'none' (-1) to influx if no data
---
> 			my $fsTotalReadHitRatio;
157,159d156
< 				inf_field => "read_cache_hit_ratio",
< 				inf_tags  => "datacenter=\"$datacenter\",uiHint=\"VV\",fs=\"$fs\"",
< 				inf_default => ""
162c159
< 			my $fsTotalWriteHitRatio = -1;  # we need to record 'none' (-1) to influx if no data
---
> 			my $fsTotalWriteHitRatio;
172,174d168
< 				inf_field => "write_cache_hit_ratio",
< 				inf_tags  => "datacenter=\"$datacenter\",uiHint=\"VV\",fs=\"$fs\"",
< 				inf_default => ""
181d174
< 	$queries{"influx_details"} = { 'measurement' => "3par_vv_cache_status"};
183c176
< 	$q->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 	$q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/an/aribapay-status
71d70
< use Data::Dumper;
92d90
<     my $monserver = ariba::Ops::PageUtils::monitorServer(); 
94,95c92
<     my %squeries = ();
<     $squeries{influx_details} = { measurement => 'an_aribapay_status'};
---
>     my %queries = ();
104c101
<     $squeries{"AribaPay Discover Status"} = {
---
>     $queries{"AribaPay Discover Status"} = {
109,110d105
<         inf_field => qq(discover_status),
<         inf_default => qq(none),
112a108
> 
119c115
<     $squeries{"AribaPay FirstData Status"} = {
---
>     $queries{"AribaPay FirstData Status"} = {
124,125d119
<         inf_field => qq(firstdata_status),
<         inf_default => "none",
128c122,124
<     $squeries{"Payment Batch in Failed Status"} = {
---
> 
> 
>     $queries{"Payment Batch in Failed Status"} = {
130c126,128
<         sql => q`select count(*) as pb_failed_status_cnt
---
>         description => 'Number of failed SUR', 
>         severity => 2,
>         sql => q`select oj.ANID, pb.batch_id, pb.created, pb.detail_status_code
137,146c135
<     $squeries{"Payment Batch without Status Update"} = {
<         warn    => "numrows > 0",
<         sql => q`select count(*) as pb_wo_status_upd_cnt
<                  from payment_batch p
<                  inner join org oj on oj.id = p.org
<                  inner join payment_method pm on pm.id = p.payment_method
<                  where p.status='sent' and pm.name='aribapay' and p.created < (sysdate - 1/24)`,
<     };
< 
<     $squeries{"Remittances with No Status Updates"} = {
---
>     $queries{"Remittances with No Status Updates"} = {
147a137,138
>         description => 'Missing final PRSUR after the projected settlement date', 
>         severity => 2,
149c140
<         sql => q `select count(*) as remit_w_no_status_upd_cnt
---
>         sql => q`select oj1.anid, oj2.anid, p.payment_number, cd.created, cd.document_status
157c148
<     $squeries{"Remittances in Temporary Error State"} = {
---
>     $queries{"Remittances in Temporary Error State"} = {
158a150,151
>         description => 'Number of remittances in 4XXX error state', 
>         severity => 2,
160c153,154
<         sql => q`select count(*) as remit_temp_err_state
---
>         sql => q`select oj1.anid, oj2.anid, p.payment_number, p.detail_status_code,
>                  cd.created, cd.document_status
169c163
<     $squeries{"Missing PRSUR 2001"} = {
---
>     $queries{"Missing PRSUR 2001"} = {
170a165,166
>       description => 'Status is sent more than 2 hours',
>       severity => 2,
172c168
<       sql => q`select count(*) as missing_prsur_2001
---
>       sql => q`select oj1.anid, oj2.anid, p.payment_number, cd.created, cd.document_status 
178c174,186
<     my $qm = ariba::monitor::QueryManager->newWithDetails('aribapay', $an->name(), $mon->service(), undef, \%squeries);
---
>     $queries{"Payment Batch without Status Update"} = {
>         warn    => "numrows > 0",
>         description => 'Number of batches with missing SUR', 
>         severity => 2,
>         sql => q`select p.batch_id, p.created, oj.anid, p.batch_size
>                  from payment_batch p
>                  inner join org oj on oj.id = p.org
>                  inner join payment_method pm on pm.id = p.payment_method
>                  where p.status='sent' and pm.name='aribapay' and p.created < (sysdate - 1/24)`,
>     };
> 
> 
>     my $qm = ariba::monitor::QueryManager->newWithDetails('aribapay', $an->name(), $mon->service(), undef, \%queries);
181,182c189
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
< 
---
>     $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/auc/learning-center-status
4a5,19
> # General comments regarding this script template:
> #   1.  The first monitoring script using this is/was for AUC Learning Center, which has some specific processing
> #       rules that I wasn't able to figure out a way to make them configuration items.  The main example of this
> #       is the time setup.  The DA URL needs to have a start time set one hour before the script runs, with a
> #       duration of one hour.  This requires code and logic to get the current time, calculate the start time,
> #       and build the URL to request data from the DA host.
> #
> #       This could be isolated in a module (perhaps the right way to go), but if it is only used once, it might
> #       as well stay here.  But that does mean this template would need more modification to use it for another
> #       monitoring request, rather than less.
> #
> #   2.  Given the above, and that there may be many of these sorts of things, I've marked the ones present in
> #       this template with the word NOTE, hoping it will stand out (it does in vim, because vim also highlights
> #       this all caps string whan found in a comment).
> 
8a24,27
> use File::Basename;
> use Getopt::Long qw(:config no_ignore_case_always no_getopt_compat require_order no_bundling);
> use LWP;
> use IO::Socket::SSL qw();
9a29
> use File::Slurp;
11c31
< 
---
> # This INC dir works for release and testing, to find the released lib in the user's home.
12a33,34
> # While this one will find the test lib hierarchy, only useful when run from the <.user/bin> directory.
> use lib "$FindBin::Bin/../lib";
14c36,37
< use ariba::Ops::Utils;
---
> use ariba::monitor::Query;
> use ariba::monitor::QueryManager;
15a39,40
> use ariba::Ops::ProductAPIExtensions;
> use ariba::monitor::Utils;
18,38c43,227
< sub main {
<     my $monProd    = ariba::rc::InstalledProduct->new('mon');
<     my $installDir = $monProd->installDir();
<     my $product    = qw(community);
< 
<     my $service = $monProd->service();
<     my $communityProd = ariba::rc::InstalledProduct->new($product, $service);
<     chomp (my $secureSiteURL = $communityProd->default('SiteURLSecure'));
<     return unless $secureSiteURL;
< 
<     my $duration = qw(3600);
<     my $startTime = time () - $duration;
<     my $dev_url  = qq(/internal/learning_center_build_monitoring.php?start_ts=$startTime&duration_sec=$duration);
<     my $prod_url = qq(/internal/community_creation_monitoring.php?start_ts=$startTime&duration_sec=$duration);
< 
<     my $full_url= (ariba::Ops::ServiceController::isProductionServices($service)) ? "$secureSiteURL$prod_url" : "$secureSiteURL$dev_url";
< 
<     eval {
<         my $data_hash = ariba::Ops::Utils::generateJsonOutput($full_url);
<         print encode_json($data_hash) if ( scalar(keys %{$data_hash}) );
<     };
---
> # Debug can have incrementing values, such that '-d -d' sets it to '2'.  For development work, a value of
> # '2' implies not wanting to actually run the queries, but just to dump the query hash and exit.  This
> # can of course be changed as needed.
> my $debug = 0;
> 
> # NOTE:  This will be different for each version of the script, and should be defined in the config file.
> #        However, this would mean no possible message until after the config is read and converted, so
> #        no usage for everything that comes before that.  The simple solution is to create a very generic
> #        usage message here.  This will be *replaced* by the values read in from the config, if any.
> my $program = basename $0; # remove leading path elements, provided by some host systems.
> my $usage = "usage:  $program [-d] [-e] [-p] [-h] -product|-prod product-name\n\n" .
>             "Option names may also be spelled out:\n" .
>             "\t-d or -debug\n\t-e or -sendemail (note spelling!)\n\t-p or -sendpage\n\t-h or -help\n\t" .
>             "-product or -prod product-name (required)\n\n" .
>             "If the 'help' option is present, all other options are ignored.";
> 
> # This will 'die' if any of the needed pieces are not found, with the basic message:
> my $message = "ERROR:  Failed to obtain information required to process: ";
> sub main
> {
>     # handle command line args.  NOTE:  these are the basics, more may be needed to meet functional
>     # and design requirements.
>     my ($sendEmail, $sendPage, $product, $help); # Debug is defined as a file global, above.
>     GetOptions (
>                    'debug|d+'       => \$debug,      # allow multiple debug options to increase debug level.
>                    'sendemail|e'    => \$sendEmail,
>                    'sendpage|p'     => \$sendPage,
>                    'product|prod=s' => \$product,
>                    'help|h'         => \$help,
>                );
> 
>     # Check for help option, print usage and exit:
>     if ($help)
>     {
>         print "$usage\n";
>         exit 0;
>     }
> 
>     # The only required option, for a minimal setup, is the product name.
>     die "$message missing required product name.\n\n$usage\n" unless $product;
>     my $monProd = ariba::rc::InstalledProduct->new ('mon');
>     die "$message cannot create a 'mon' product object.\n" unless $monProd;
>     my $installDir = $monProd->installDir ();
>     die "$message cannot retrieve install directory from monitor product object.\n" unless $installDir;
> 
>     # Prepend the 'home' directory, aka the install directory.  NOTE:  the config file names will be different.  Edit this.
>     my $confFile = "$installDir/etc/query/learning-center.conf";
>     # Read the conf file and convert the JSON to Perl data structures.
>     chomp (my $configString = read_file ($confFile));
>     die "$message cannot read configuration file '$confFile'.\n" unless $configString;
>     my $config = eval {decode_json ($configString)}; # trap and throw away any JSON error messages.
>     # If the decode failed, $config should be undef or empty, and fail the test below.
>     die "$message cannot decode JSON string:\n\n'$configString'.\n" unless $config;
> 
>     # The config structure has one key named 'globals', for all config information not specific to a
>     # particular monitored item.  This needs to be removed from the config and saved separately.
>     my $configGlobals = delete $config->{globals};
>     # There are two "comment" keys present to explain usage/purpose of the 'globals' key, useful only in
>     # the JSON source file, so remove those keys here.
>     delete @$configGlobals{'comment','comment2'};
>     # And finally, there is a 'usage' key, which may or may not have content.  If the generic usage above is sufficient, this
>     # would be empty, otherwise it is an array of strings.
>     my $newUsage = join '', @{delete $config->{'usage'}};
>     $usage = $newUsage if $newUsage;  # Preserves the original unless we have a new one.
> 
>     my $service = $monProd->service ();
>     # NOTE:  this section is very product dependent and should be replaced for new monitoring.
>     # ======================
>     # Check that the product named from the command line exists in this service.
>     die "$message product '$product' is not installed for service '$service'.\n"
>         unless ariba::rc::InstalledProduct->isInstalled ($product, $service);
>     # Retrieve the secure site URL and append our PHP path and arguments.
>     my $communityProd = ariba::rc::InstalledProduct->new ($product, $service);
>     die "$message cannot create a 'community' product object.\n" unless $communityProd;
>     chomp (my $secureSiteURL = $communityProd->default ('SiteURLSecure'));
>     die "$message could not retrieve secure site URL.\n" unless $secureSiteURL;
>     # ======================
>     # We need to determine if the script is running in a production or devlab service, so it can select an appropriate URL path
>     # and options from the config.
>     # Greg says this info should be in the product configs, so a single call will retrieve the right thing regardless of service.
>     my $URLPathOpts;
>     if (ariba::Ops::ServiceController::isProductionServices ($service))
>     {
>         $URLPathOpts = "$secureSiteURL$configGlobals->{url_path_opts_prod}";
>     }
>     else
>     {
>         $URLPathOpts = "$secureSiteURL$configGlobals->{url_path_opts_dev}";
>     }
> 
>     # NOTE:  The exact timing method used for a monitoring script will likely be different so this needs to change or go away.
>     # But the full URL still needs to be created in some way, as a method to call here, from ariba::monitor::Utils, to keep
>     # changes isolated from this script as much as possible.
>     my $fullURL = ariba::monitor::Utils::makeDirectActionURL ($configGlobals->{duration}, $URLPathOpts);
>     print "$fullURL\n" if $debug;
> 
>     # Now, get the data from the remote host.  Because we are using self-signed certificates, and have no local set to verify
>     # against, the request needs to ignore varification:
>     my $userAgent = LWP::UserAgent->new (ssl_opts => {SSL_verify_mode => 0,
>                                                       verify_hostname => 0,});
>     my $request = HTTP::Request->new (GET => $fullURL);
>     my $response = $userAgent->request ($request);
>     $response->is_success or die "ERROR:  Request failed for '$fullURL':  ", $response->message (), "\n";
>     # The response will be JSON from the remote host, which needs to be converted...
>     my $responseHashRef = eval {decode_json ($response->content ())};
>     # And again, if this is undef/empty, we've failed for some reason and an error exit seems best for now.
>     die "$message invalid or missing response from remote '$fullURL'.\n" unless $responseHashRef;
>     print Dumper ($responseHashRef), "\n" if $debug;
> 
>     my %queries;
>     # Now loop over each key in the %$config hash, get the data element for it from the %$responseHashRef, and build
>     # a query object.  NOTE:  for Learning Center, there are 3 basic types of information:
>     #   1.  first, where there are values for each of info, warn and crit (0, 1, 2); a "warn" key exists for only this type;
>     #   2.  the second where there are values for info and crit (0, >0), the crit name is "crit";
>     #   3.  the third, which are informational only.  The severity key has the value 'informational'.
>     # For each value, check first for the 'warn' key, the 'crit' key, and take the last as a default (no check).
>     for my $queryName (keys %$config)
>     {
>         # Build a query object for the basic, common elements, which exists for all queries (though value may vary, the
>         # key is constant).
>         $queries {$config->{$queryName}->{'metric_name'}} = {
>                                                              note => $config->{$queryName}->{'metric_note'},
>                                                              description => $config->{$queryName}->{'metric_description'},
>                                                           };
> 
>         # Check for "global" values that may need to be applied to every query.  For AUC Learning Center, the values are
>         # to be saved in the circular DB, as well as providing for graphing of the results.  This applies to every query.
>         # NOTE:  another piece that is likely product specific.  At least this is skipped if the key is not present.
>         if ($configGlobals->{cdb_rows_retention})
>         {
>             # Implement all requested/required circulardb related query fields here.
>             $queries {$config->{$queryName}->{'metric_name'}}->{'recordMaxResults'} = eval $configGlobals->{cdb_rows_retention};
>             $queries {$config->{$queryName}->{'metric_name'}}->{'recordDataType'} = 'counter';
>             # $queries {'recordDataUnits'} units of the quantity - seems to be any arbitrary string that defines the units in use.
>             $queries {$config->{$queryName}->{'metric_name'}}->{'recordItem'} = 'answer';
>             # $queries {'recordTime'} cdb record id to insert/update, in seconds since epoch
>             # $queries {$config->{$queryName}->{'metric_name'}}->{'recordOnError'} = 1; # cdb updated with results even if error is set on query
>             # It turns out that the value actually used for 'graphRecorded' in other scripts is always a numeric '1'.  I presume there is an
>             # enumeration somewhere that should be interpreting the string values talked about here and in the Query.pm file.
>             $queries {$config->{$queryName}->{'metric_name'}}->{'graphRecorded'} = 1; # graphs to generate all|daily|weekly|monthly|quarterly|yearly
>         }
> 
>         # Then, add the query specific parts.
>         my ($info, $warn, $crit);
>         if (exists $config->{$queryName}->{'warn'}) # NOTE: Test for 'warn' MUST be before test for 'crit', to separate the two types of queries.
>         {
>             $queries {$config->{$queryName}->{'metric_name'}}->{'info'} = "answer == $config->{$queryName}->{'info'}";
>             $queries {$config->{$queryName}->{'metric_name'}}->{'warn'} = "answer == $config->{$queryName}->{'warn'}";
>             $queries {$config->{$queryName}->{'metric_name'}}->{'crit'} = "answer == $config->{$queryName}->{'crit'}";
>             $queries {$config->{$queryName}->{'metric_name'}}->{'perl'} = sub {return $responseHashRef->{$queryName}};
>             $queries {$config->{$queryName}->{'metric_name'}}->{'severity'}    = $config->{$queryName}->{'severity'};
>         }
>         elsif (exists $config->{$queryName}->{'crit'})
>         {
>             $queries {$config->{$queryName}->{'metric_name'}}->{'info'} = "answer == $config->{$queryName}->{'info'}";
>             $queries {$config->{$queryName}->{'metric_name'}}->{'crit'} = "answer >= $config->{$queryName}->{'crit'}";
>             $queries {$config->{$queryName}->{'metric_name'}}->{'perl'} = sub {return $responseHashRef->{$queryName}};
>             $queries {$config->{$queryName}->{'metric_name'}}->{'severity'} = $config->{$queryName}->{severity};
>         }
>         else # an 'informational' query.  Only have the note and description and an info value.
>         {
>             $queries {$config->{$queryName}->{'metric_name'}}->{'perl'} = sub {return $responseHashRef->{$queryName}};
>             $queries {$config->{$queryName}->{'metric_name'}}->{'info'} = "answer";
>         }
>     }
> 
>     if ($debug > 2)
>     {
>         print Dumper (\%queries);
>         exit 0;
>     }
> 
>     if ($debug > 1)
>     {
>         # Print what script would do normally, and exit without any other action.
>         print "Expando name:  '$configGlobals->{expando_name}'\nName of communityProd:\n",
>               $communityProd->name (), "\n============\nName of service:\n", $service, "\nArg is:  undef\n",
>               "=========\nDump of queries:\n", Dumper (\%queries),;
>     }
>     else
>     {
>         my $queryManager = ariba::monitor::QueryManager->newWithDetails ($configGlobals->{expando_name}, $communityProd->name (),
>                                                                          $service, undef, \%queries);
>         $queryManager->processQueries ($debug, $configGlobals->{email}, $sendEmail, $sendPage);
>     }
41c230
< main(@ARGV);
---
> main (@ARGV);
112d300
< 
filename:./bin/buyer/contract-status
34,35c34,36
<         sql => "SELECT count(*) as contract_count 
<             FROM
---
>         sql => "SELECT Con1.rootId, App2.ap_PartitionNumber, App2.ap_LastModified,
>             App2.ap_UniqueName, App2.ap_Name, App2.ap_NextVersion,
>             Con1.mar_ExternalSourcingId, App2.ap_StatusString FROM
41a43
>         processAnswer => sub { notifyForCRStatus(); },
44,45d45
<     $q{influx_details} = {measurement => 'buyer_contract_status'};
< 
54a55,91
> sub notifyForCRStatus {
>     my ($program, $productName, $service, $customer, $cluster, $status);
>     my $self = $ariba::monitor::Query::_ourGlobalQuerySelf;
>     my $notify = "linterthal\@ariba.com,tehunter\@ariba.com,TJCarr\@ariba.com,amanigan\@ariba.com,jdvorchak\@ariba.com";
>     $service = $self->service();
>     $program = $0;
>     $customer = undef;
>     $status = "warn";
>     $productName = $self->productName();
>     $cluster = $self->cluster(),
> 
>     my $ret = join("\n", ( $self->results() ) );
> 
>     $notify = "jmcminn\@ariba.com" if($service eq 'dev');
> 
>     if($self->results()) {
>         my $subject = ":: Contracts needing attention from support";
>         my $body = "The following contracts are in suspicious states:\n\n";
>         $body .= $ret;
> 
>         my $notificationRequest = ariba::Ops::NotificationRequest->newMessage(
>             $status,
>             $program,
>             $productName,
>             $service,
>             $customer,
>             $cluster,
>             $subject,
>             $body,
>             $notify
>         );
>         $notificationRequest->sendAsEmail();
>     }
> 
>     return($ret);
> }
> 
filename:./bin/common/cpu-watcher
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
34d33
<     my $service = $me->service();
83d81
<             my $has_hysteresis = 0;
132d129
<                 $has_hysteresis = 1
135,137d131
<             my $crit_threshold = $has_hysteresis ? (split(' ', $crit))[0] : $crit;
<             my $hysteresis_tag = $has_hysteresis ? "yes" : "no";
<            
183,186d176
<                     inf_field => "cpu_usage_percentage",
<                     inf_tags => qq|cluster=$cluster,service=$service,hostname=$hostname,hysteresis=$hysteresis_tag|,
<                     inf_default => 0,
<                     group_by => "$datacenter,$hostname"
208,211d197
<                 inf_field => "cpu_avg_usage_percentage_sample4",
<                 inf_tags => qq|cluster=$cluster,service=$service,hostname=$hostname,hysteresis=$hysteresis_tag|,
<                 inf_default => 0,
<                 group_by => "$datacenter,$hostname"
213,229d198
< 
<             $queries{qq!$hostname cpu variable crit threshold!} = {
<                 perl        => sub { return $crit_threshold },
<                 inf_field   => "cpu_avg_usage_percentage_crit_threshold",
<                 inf_tags    => qq|cluster=$cluster,service=$service,hostname=$hostname,hysteresis=$hysteresis_tag|,
<                 inf_default => 95,
<                 group_by    => "$datacenter,$hostname"
<             };
< 
<             $queries{qq!$hostname cpu variable warn threshold!} = {
<                 perl        => sub { return $warn },
<                 inf_field   => "cpu_avg_usage_percentage_warn_threshold",
<                 inf_tags    => qq|cluster=$cluster,service=$service,hostname=$hostname,hysteresis=$hysteresis_tag|,
<                 inf_default => 85,
<                 group_by    => "$datacenter,$hostname"
<             };
< 
234d202
<         $queries{influx_details} = {measurement => "dc_cpu_watcher"};
238c206
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/disk-usage
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/common/disk-usage#126 $
---
> # $Id: //ariba/services/monitor/bin/common/disk-usage#127 $
34d33
<     my $cluster = $me->currentCluster();
39,62c38,61
<                 my %matchDatacenter = (
<                         status => 'inservice',
<                         datacenter => $datacenter,
<                         os => 'sunos,linux,redhat,hp-ux,ontap,windows2003,suse,cdot',
<                         monitoringDatacenter => '',
<                 );
< 
<                 my %matchMonitoringDatacenter = (
<                         status => 'inservice',
<                         monitoringDatacenter => $datacenter,
<                         os => 'sunos,linux,redhat,hp-ux,ontap,suse,cdot',
<                 );
< 
<                 # VMs are marked as outofservice because they do not want cfengine to update them
<                 my %matchVirtualMachinesInDatacenter = (
<                         status      => 'outofservice',
<                         datacenter  => $datacenter,
<                         os      => 'redhat',
<                         hardwareType    => 'VM',
<                 );
< 
<                 my @machines = ariba::Ops::Machine->machinesWithProperties(%matchDatacenter);
<                 push(@machines, ariba::Ops::Machine->machinesWithProperties(%matchMonitoringDatacenter));
<                 push(@machines, ariba::Ops::Machine->machinesWithProperties(%matchVirtualMachinesInDatacenter));
---
>         my %matchDatacenter = (
>             status => 'inservice',
>             datacenter => $datacenter,
>             os => 'sunos,linux,redhat,hp-ux,ontap,windows2003,suse,cdot',
>             monitoringDatacenter => '',
>         );
> 
>         my %matchMonitoringDatacenter = (
>             status => 'inservice',
>             monitoringDatacenter => $datacenter,
>             os => 'sunos,linux,redhat,hp-ux,ontap,suse,cdot',
>         );
> 
>         # VMs are marked as outofservice because they do not want cfengine to update them
>         my %matchVirtualMachinesInDatacenter = (
>             status      => 'outofservice',
>             datacenter  => $datacenter,
>             os      => 'redhat',
>             hardwareType    => 'VM',
>         );
> 
>         my @machines = ariba::Ops::Machine->machinesWithPropertiesForService($service, %matchDatacenter);
>         push(@machines, ariba::Ops::Machine->machinesWithPropertiesForService($service, %matchMonitoringDatacenter));
>         push(@machines, ariba::Ops::Machine->machinesWithPropertiesForService($service, %matchVirtualMachinesInDatacenter));
64c63
<                 my %queries = ();
---
>         my %queries = ();
133c132
<                         
---
> 
136c135
<                         
---
> 
142c141
<                         
---
> 
144c143
<                         
---
> 
158c157
<                         
---
> 
217,221c216,220
< 					#HOA-18483
< 					if ($filesystem =~ m|^/hana:log|){
< 						$warn = 65;
< 						$crit = 70;
< 					}
---
>                                         #HOA-18483
>                                         if ($filesystem =~ m|^/hana:log|){
>                                                 $warn = 65;
>                                                 $crit = 70;
>                                         }
252c251
<                     
---
> 
265,267c264,266
<                                 perl => sub { 
<                                     return ariba::Ops::MachineProductInfo->topProductRolesForServiceAndHost($me->service(), $hostname);
<                                 }, 
---
>                                 perl => sub {
>                                     return ariba::Ops::MachineProductInfo->topProductRolesForServiceAndHost($service, $hostname);
>                                 },
270,273d268
<                         inf_field => "disk_usage_pct",
<                         inf_tags => qq|cluster=$cluster,service=$service,hostname=$hostname,filesystem=$filesystem|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$hostname"
278,281c273,276
< 		    if($filesystem =~m|piwik|i) {
< 				 $queries{"$hostname $filesystem used"}->{"correctiveActions"} = [
<                     			Ops => 'Please refer the wiki --> https://wiki.ariba.com/pages/viewpage.action?title=Monitoring+piwik+for+pending+data+loads+and+disk+space+usage&spaceKey=ENGDPTS'
<                 		];
---
>                     if($filesystem =~m|piwik|i) {
>                                  $queries{"$hostname $filesystem used"}->{"correctiveActions"} = [
>                                         Ops => 'Please refer the wiki --> https://wiki.ariba.com/pages/viewpage.action?title=Monitoring+piwik+for+pending+data+loads+and+disk+space+usage&spaceKey=ENGDPTS'
>                                 ];
283,284c278,279
< 			}
<     
---
>                         }
> 
292,307c287
<                 
<                     $queries{"$hostname $filesystem used crit threshold"} = {
<                         perl        => sub { return $crit },
<                         inf_field   => "disk_usage_pct_crit_threshold",
<                         inf_tags    => qq|cluster=$cluster,service=$service,hostname=$hostname,filesystem=$filesystem|,
<                         inf_default => 95,
<                         group_by    => "$datacenter,$hostname"
<                     }; 
< 
<                     $queries{"$hostname $filesystem used warn threshold"} = {
<                         perl        => sub { return $warn },
<                         inf_field   => "disk_usage_pct_warn_threshold",
<                         inf_tags    => qq|cluster=$cluster,service=$service,hostname=$hostname,filesystem=$filesystem|,
<                         inf_default => 85,
<                         group_by    => "$datacenter,$hostname"
<                     }; 
---
> 
309c289
<                     
---
> 
324c304
<                                     return ariba::Ops::MachineProductInfo->topProductRolesForServiceAndHost($me->service(), $hostname);
---
>                                     return ariba::Ops::MachineProductInfo->topProductRolesForServiceAndHost($service, $hostname);
328,333c308,309
<                         inf_field => "inode_used_pct",
<                         inf_tags => qq|cluster=$cluster,service=$service,hostname=$hostname,filesystem=$filesystem|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$hostname"
<                     };
<                 
---
>                                 };
> 
341,344d316
<                         inf_field => "disk_used_absolute_gb",
<                         inf_tags => qq|cluster=$cluster,service=$service,hostname=$hostname,filesystem=$filesystem|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$hostname"
355,358d326
<                         inf_field => "growth_rate_gb",
<                         inf_tags => qq|cluster=$cluster,service=$service,hostname=$hostname,filesystem=$filesystem|,
<                         inf_default => 0,
<                         group_by => "$datacenter,$hostname"
369c337
<         }   
---
>         }
371c339
<         if (!(ariba::Ops::ServiceController::isProductionServicesOnly($me->service()))) {
---
>         if (!(ariba::Ops::ServiceController::isProductionServicesOnly($service))) {
375c343
<             if (ariba::Ops::ServiceController::isDevServiceOnly($me->service()) && 
---
>             if (ariba::Ops::ServiceController::isDevServiceOnly($service) &&
383d350
<         $queries{influx_details} = {measurement => "dc_disk_usage"};
386,387c353,354
<         my $q = ariba::monitor::QueryManager->newWithDetails("disk-usage", $pn, $me->service(), $me->customer(), \%queries);
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         my $q = ariba::monitor::QueryManager->newWithDetails("disk-usage", $pn, $service, $me->customer(), \%queries);
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/common/dns-watcher
4c4
< # $Id: //ariba/services/monitor/bin/common/dns-watcher#23 $
---
> # $Id: //ariba/services/monitor/bin/common/dns-watcher#24 $
45c45
< 	my $qmName	= 'dns-watcher-stratus';
---
> 	my $qmName	= 'dns-watcher';
54c54
< 	#
---
> 	# 
62c62
< 
---
> 								
64c64
< 
---
> 	
88d87
< 		my $badCount = 0;
94d92
< 			$badCount = scalar(@badList);
104,107d101
<             inf_default => "ok",
<             inf_tag => qq(datacenter="$datacenter"),
<             group_by => "$datacenter",
< 		};
109,118d102
< 		$queries{"Invalid DNS servers count"} = {
< 			noRowCount => 1,
< 			format     => "</td><td colspan=2>%s",
< 			info       => 1,
< 			crit       => "answer > 0",
< 			perl       => sub { return $badCount },
< 			inf_field => "invalidDNSServersCount",
< 			inf_default => 0,
< 			inf_tag => qq(datacenter="$datacenter"),
< 			group_by => "$datacenter",
126,128c110,112
< 					info       => "answer eq '0'", # up
< 					warn       => "answer eq '1'", # sick
< 					crit       => "answer eq '2'", # down
---
> 					info       => "answer eq 'up'",
> 					warn       => "answer eq 'sick'",
> 					crit       => "answer eq 'down'",
132,133c116,118
<                     inf_default => 0,
<                     group_by => "$datacenter".$machine->hostname(),
---
> 					processAnswer => sub { 
> 						ariba::monitor::MachineHelper::computeStatusChange($machine, $hysteresis)
> 					},
138d122
<         $queries{influx_details} = {measurement => "dns_watcher"};
145c129,138
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
> 		$qm->run();
> 		#$qm->runInParallel(10);
> 
> 		if ($debug) {
>                         $qm->displayToStdout();
>                 } else {
>                         $qm->checkStatus();
>                         $qm->archiveResults();
> 			$qm->displayToLog();
> 		}
146a140
> 		ariba::monitor::MachineHelper::notifyPeople($me, $progName, $pager, $sendPage, \@machines);
202c196
< 		$machine->setNewStatus(2);
---
> 		$machine->setNewStatus("down");
205c199
< 		$machine->setNewStatus(0);
---
> 		$machine->setNewStatus("up");
215c209
< 
---
> 	
218c212
< 
---
> 	
filename:./bin/common/durable-email-monitoring
24,43c24,42
<                   '5' => {
<                           warn => 'answer > 0.25 && answer < 0.5',
<                           crit => 'answer >= 0.5',
<                          },
<                   '0' => {
<                           warn => 'answer > 2 && answer < 3',
<                           crit => 'answer >= 3',
<                          },
<                   '10' => {
<                            warn => 'answer > 4 && answer < 8',
<                            crit => 'answer >= 8',
<                           },
<                  );
< 
< my %priority_tag = (5 => 'High', 0 => 'Normal', 10 => 'Low');
< 
< sub main
< {
<     my $debug     = 0;
<     my $quiet     = 0;
---
>  '5' => {
>         warn => 'answer > 0.25 && answer < 0.5',
>         crit => 'answer >= 0.5',
>     },
> '0'=> {
>         warn => 'answer > 2 && answer < 3',
>         crit => 'answer >= 3',
>     },
>  '10'  => {
>         warn => 'answer > 4 && answer < 8',
>         crit => 'answer >= 8',
>     },
> );
> 
> my %priority_tag = ( 5 => 'High', 0 => 'Normal' , 10 => 'Low' );
> 
> sub main {
>     my $debug = 0;
>     my $quiet = 0;
45c44
<     my $sendPage  = 0;
---
>     my $sendPage = 0;
48,49c47
<     while (my $arg = shift (@ARGV))
<     {
---
>     while(my $arg=shift(@ARGV)){
51,54c49,52
<         if ($arg =~ /^-d/o)    {$debug++;}
<         if ($arg =~ /^-e/o)    {$sendEmail = 1;}
<         if ($arg =~ /^-p$/o)   {$sendPage = 1;}
<         if ($arg =~ /^-prod/o) {$productName = shift (@ARGV);}
---
>         if($arg =~ /^-d/o){ $debug++; }
>         if($arg =~ /^-e/o){ $sendEmail=1; };
>         if($arg =~ /^-p$/o){ $sendPage=1; };
>         if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
57c55
<     my $me      = ariba::rc::InstalledProduct->new();
---
>     my $me = ariba::rc::InstalledProduct->new();
60c58
<     my $email   = $me->default('notify.email');
---
>     my $email = $me->default('notify.email');
64,66c62,63
<     unless (@products)
<     {
<         exit (0);
---
>     unless (@products) {
>         exit(0);
69,70c66
<     for my $product (@products)
<     {
---
>     for my $product (@products) {
72c68
<         my $lockfile = "/tmp/stratus-durable-email-monitoring";
---
>         my $lockfile = "/tmp/durable-email-monitoring";
74,76c70,71
<         $lockfile .= "-" . $product->customer() if ($product->customer());
<         if (!dmail::LockLib::requestlock($lockfile, 5))
<         {
---
>         $lockfile .= "-" . $product->customer() if($product->customer());
>         if (!dmail::LockLib::requestlock($lockfile,5)) {
82,83c77,78
<         my $dbc  = $dbcs[0];
<         my $oc   = ariba::Ops::OracleClient->newFromDBConnection($dbc);
---
>         my  $dbc = $dbcs[0];
>         my $oc = ariba::Ops::OracleClient->newFromDBConnection($dbc);
87c82
<         my %queries    = ();
---
>         my %queries  = ();
89d83
< 
93,99c87,92
<         my @instance_array;
<         map {push (@instance_array, $_)} $product->appInstancesInCluster($cluster);
<         my @countgen = (1 .. scalar @instance_array);
<         for my $cg (@countgen)
<         {
<             map {$instance_hash{$cg} = $_} $product->appInstancesInCluster($cluster);
<         }
---
>          my @instance_array;
>           map{push(@instance_array,$_)}$product->appInstancesInCluster($cluster);
>           my @countgen = (1..scalar @instance_array);
>           for my $cg(@countgen) {
>           map{$instance_hash{$cg}=$_}$product->appInstancesInCluster($cluster);
>           }
101c94
<         my $instanceToMonitor = generateRandom(\%instance_hash, scalar @instance_array);
---
>         my $instanceToMonitor = generateRandom(\%instance_hash,scalar @instance_array);
103,104c96
<         for my $instance (@$instanceToMonitor)
<         {
---
>         for my $instance (@$instanceToMonitor) {
109,111c101
< 
<             #my $results = $durableEmailStats->request(900);
<             my $results = $durableEmailStats->request();
---
>             my $results = $durableEmailStats->request(900);
115c105
<             print "Dumper of xml:" . Dumper($xml_ref) if ($debug > 1);
---
>             print "Dumper of xml:".Dumper($xml_ref) if ($debug > 1);
117,122c107,109
<             if ($xml_ref)
<             {
<                 foreach my $realmid (keys (%{$xml_ref->{realm}}))
<                 {
<                     foreach my $priorityid (keys (%{$xml_ref->{realm}->{$realmid}->{priority}}))
<                     {
---
>             if($xml_ref) { 
>                 foreach my $realmid ( keys( %{$xml_ref->{realm}} ) ) {
>                     foreach my $priorityid ( keys( %{$xml_ref->{realm}->{$realmid}->{priority} }  ) ) {
124,125c111,112
<                         my $created_last_hour  = $xml_ref->{realm}->{$realmid}->{priority}->{$priorityid}->{created_last_hour};
<                         my $pending            = $xml_ref->{realm}->{$realmid}->{priority}->{$priorityid}->{pending};
---
>                         my $created_last_hour = $xml_ref->{realm}->{$realmid}->{priority}->{$priorityid}->{created_last_hour};
>                         my $pending = $xml_ref->{realm}->{$realmid}->{priority}->{$priorityid}->{pending};
127c114
<                         print " created_last_hour : $created_last_hour,pending : $pending , oldest_unsent_time : $oldest_unsent_time \n" if ($debug > 2);
---
>                         print " created_last_hour : $created_last_hour,pending : $pending , oldest_unsent_time : $oldest_unsent_time \n" if ( $debug > 2 );
130,132c117,119
<                         $realm_href->{$realmid}->{$priorityid}->{'created_last_hour'}  = $created_last_hour;
<                         $realm_href->{$realmid}->{$priorityid}->{'pending'}            = $pending;
<                         $realm_href->{$realmid}->{$priorityid}->{'oldest_unsent_time'} = $oldest_unsent_time;
---
>                         $realm_href->{$realmid}->{$priorityid}->{'created_last_hour'} = $created_last_hour; 
>                         $realm_href->{$realmid}->{$priorityid}->{'pending'} = $pending; 
>                         $realm_href->{$realmid}->{$priorityid}->{'oldest_unsent_time'} = $oldest_unsent_time; 
136,144c123,125
<                 #Get all realms from DB
<                 my @realms = $oc->executeSql("select id from realmtab");    #whatever it is
<                 print "total number of realms" . scalar (@realms) . "\n" if ($debug > 1);
< 
<                 foreach my $realm (@realms)
<                 {
<                     my $realmid = $realm->{'ID'};
<                     foreach my $priorityid (keys %thresholds)
<                     {
---
>                 #Get all realms from DB 
>                 my @realms = $oc->executeSql("select id from realmtab"); #whatever it is
>                 print "total number of realms".scalar(@realms)."\n" if ( $debug > 1);
146,147c127,131
<                         #For every [realms*priority] we need to store Query results.Not a scalable solution.
<                         my ($created_last_hour, $pending, $oldest_unsent_time);
---
>                 foreach my $realmid(@realms) {
>                     foreach my $priorityid (keys %thresholds) {
> 
>                         #For every [realms*priority] we need to store Query results.Not a scalable solution.   
>                         my ($created_last_hour,$pending,$oldest_unsent_time);
150,153c134,136
<                         if (exists $realm_href->{$realmid}->{$priorityid})
<                         {
<                             $created_last_hour  = $realm_href->{$realmid}->{$priorityid}->{'created_last_hour'};
<                             $pending            = $realm_href->{$realmid}->{$priorityid}->{'pending'};
---
>                         if( exists $realm_href->{$realmid}->{$priorityid} ) {
>                             $created_last_hour = $realm_href->{$realmid}->{$priorityid}->{'created_last_hour'};
>                             $pending = $realm_href->{$realmid}->{$priorityid}->{'pending'};
156,159c139,141
<                         else
<                         {
<                             $created_last_hour  = 0;
<                             $pending            = 0;
---
>                         else {
>                             $created_last_hour = 0;
>                             $pending = 0;
165,172c147,151
<                                                                                                                'recordMaxResults' => 8760,
<                                                                                                                'uiHint'           => "Realms/Realm $realmid",
<                                                                                                                'perl'             => sub {return $pending;},
<                                                                                                                inf_tags           => qq(realm_id=$realmid,priority=$priority_tag{$priorityid}),
<                                                                                                                inf_field          => qq(pending),
<                                                                                                                inf_default        => 0,
<                                                                                                                group_by           => qq($realmid,$priority_tag{$priorityid}),
<                                                                                                               };
---
>                             'recordMaxResults' => 8760,
>                             'uiHint' => "Realms/Realm $realmid",
>                             'perl' => sub { return $pending; },
>                         };
> 
178,190c157,165
<                             'uiHint'           => "Realms/Realm $realmid",
<                             'warn'             => $thresholds{$priorityid}{'warn'},
<                             'crit'             => $thresholds{$priorityid}{'crit'},
<                             'format'           => '%.2f hours',
< 
<                             #if $oldest_unsent_time is exit it will return the difference with current time else
<                             #it return the $oldest_unsent_time (which is set as empty string at line # 130 )
<                             'perl' => sub {return ($oldest_unsent_time ? ((time - str2time($oldest_unsent_time)) / 3600) : $oldest_unsent_time);},
<                             inf_tags    => qq(realm_id=$realmid,priority=$priority_tag{$priorityid}),
<                             inf_field   => qq(oldest_unsent_time),
<                             inf_default => 0,
<                             group_by    => qq($realmid,$priority_tag{$priorityid}),
<                                                                                                                          };
---
>                             'uiHint' => "Realms/Realm $realmid",
>                             'warn'   => $thresholds{$priorityid}{'warn'},
>                             'crit'   => $thresholds{$priorityid}{'crit'},
>                             'format' => '%.2f hours',
>              #if $oldest_unsent_time is exit it will return the difference with current time else 
>              #it return the $oldest_unsent_time (which is set as empty string at line # 130 )
>                 'perl'   => sub { return ($oldest_unsent_time ? ((time - str2time($oldest_unsent_time))/3600) : $oldest_unsent_time ); },
>                         };
>                         #}
194,201c169,172
<                                                                                                                              'recordMaxResults' => 8760,
<                                                                                                                              'uiHint'           => "Realms/Realm $realmid",
<                                                                                                                              'perl'             => sub {return $created_last_hour;},
<                                                                                                                              inf_tags           => qq(realm_id=$realmid,priority=$priority_tag{$priorityid}),
<                                                                                                                              inf_field          => qq(created_last_hour),
<                                                                                                                              inf_default        => 0,
<                                                                                                                              group_by           => qq($realmid,$priority_tag{$priorityid}),
<                                                                                                                             };
---
>                 'recordMaxResults' => 8760,
>                             'uiHint' => "Realms/Realm $realmid",
>                             'perl' => sub { return $created_last_hour; },
>                         };
205c176,178
<                         my $previous_instance = ariba::monitor::Query->generateInstanceName($qname, $productName, $me->customer(), $me->currentCluster());
---
>                         my $previous_instance = ariba::monitor::Query->generateInstanceName(
>                             $qname, $productName, $me->customer(), $me->currentCluster()
>                         );
207c180
<                         my $completedQuery   = ariba::monitor::Query->new($previous_instance);
---
>                         my $completedQuery = ariba::monitor::Query->new($previous_instance);
212c185
<                         my $sent_emails_last_hour = $previous_results + $created_last_hour - $pending;
---
>                         my $sent_emails_last_hour = $previous_results + $created_last_hour - $pending ;
217,224c190,193
<                                                                                                                              'recordMaxResults' => 8760,
<                                                                                                                              'uiHint'           => "Realms/Realm $realmid",
<                                                                                                                              'perl'             => sub {return "$sent_emails_last_hour";},
<                                                                                                                              inf_tags           => qq(realm_id=$realmid,priority=$priority_tag{$priorityid}),
<                                                                                                                              inf_field          => qq(sent_emails_last_hour),
<                                                                                                                              inf_default        => 0,
<                                                                                                                              group_by           => qq($realmid,$priority_tag{$priorityid}),
<                                                                                                                             };
---
>                             'recordMaxResults' => 8760,
>                             'uiHint' => "Realms/Realm $realmid",
>                             'perl' => sub { return "$sent_emails_last_hour"; },
>                         };
227d195
< 
233,235c201,204
<         $queries{influx_details} = {measurement => 'buyer_durable_email_monitoring'};
<         my $q = ariba::monitor::QueryManager->newWithDetails("persisted-mail-queue", $product->name(), $service, $product->customer(), \%queries);
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         my $q = ariba::monitor::QueryManager->newWithDetails(
>             "persisted-mail-queue", $product->name(), $service, $product->customer(), \%queries
>         );
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
241,242c210
< sub parseDurableEmailStatsDetails
< {
---
> sub parseDurableEmailStatsDetails {
246c214,216
<     eval {$xml_href = XMLin($xml_content, ForceArray => 1);};
---
>     eval {
>         $xml_href = XMLin($xml_content,ForceArray => 1);
>     };
248,250c218,219
<     if ($@ or ref ($xml_href) !~ /Hash/i)
<     {
<         return (0);
---
>     if( $@ or ref($xml_href) !~/Hash/i ) {
>         return(0);
253c222
<     return ($xml_href);
---
>     return($xml_href);
256,263c225,230
< sub generateRandom
< {
<     my $ho     = shift;
<     my $c      = shift;
<     my $random = int (rand ($c)) + 1;
<     if ($random + 2 >= $c)
<     {
<         $random = $random - 2;
---
> sub generateRandom {
>     my $ho = shift;
>     my $c = shift;
>     my $random =  int(rand($c))+1;
>     if ($random + 2 >= $c) {
>        $random = $random - 2;
266,269c233,235
<     my @randcount = ($random .. $random + 2);
<     foreach my $rc (@randcount)
<     {
<         push (@randhashfive, $ho->{$rc});
---
>     my @randcount = ($random..$random+2);
>     foreach my $rc(@randcount) {
>        push (@randhashfive,$ho->{$rc});
271c237
<     return \@randhashfive;
---
>     return \@randhashfive; 
274d239
< main();
275a241
> main();
filename:./bin/common/hana-isup
44c44
< my $LOCKFILE = "/tmp/stratus-$prog";
---
> my $LOCKFILE = "/tmp/$prog";
144,145c144,146
<             # watchdog section now handles and creates corresponding timeout entries in influx. 
< 
---
>             # Therefore, to avoid stale query objects and associated confusion, we'll have to
>             # maintain a cluster-level query object at the parent level, that can be updated
>             # in the watchdog timeout section.
146a148,161
>             my $cluster_title = "Hana ISUP: _cluster connection $hostIndex";
>             $parent_queries{$cluster_title} = {
>                     # retain 1 year of results: 12 runs/hr x 24 hrs/day * 365 days = 105120
>                     recordDataUnits => '1 = up, 0 = down',
>                     recordMaxResults => 110000,
>                     # we want to explicitly record "1" for up, and "0" for down, in the cdb.
>                     # alternatively, we could have used "$self->status()" instead of "answer" here,
>                     # but I felt it would be slightly more legible this way.
>                     recordItem => '"answer" eq "YES" ? 1 : 0',
>                     info => 'answer eq "YES"',
>                     crit => 'answer ne "YES"',
>                     noCritOnError => $outage,
>                     perl => sub { return 'YES'; },
>                 };
154c169,170
<                 my $clusterConnectStatus = $hanaClient->connect($cto, $ntries) || 0;
---
>                 my $clusterConnectStatus = "YES";
>                 $clusterConnectStatus = $hanaClient->error() unless $hanaClient->connect($cto, $ntries);
157,158c173,174
<                 my $tenant    =  do_sysdb_query(\%queries, $dbsid, $dbuser, $dbpass, $hanaClient, $clusterConnectStatus, $outage, $host, $port);
<                 my $hostIndex = "($pname) " . ( $tenant ? "MDC tenant" : "" ) . " [$qm_index]";
---
>                 my $tenant    =  do_sysdb_query(\%queries, $dbsid, $dbuser, $dbpass, $hanaClient, $clusterConnectStatus, $outage);
>                 my $hostIndex = "($pname)$tenant [$qm_index]";
164a181,186
>                     # we want to explicitly record "1" for up, and "0" for down, in the cdb.
>                     # alternatively, we could have used "$self->status()" instead of "answer" here,
>                     # but I felt it would be slightly more legible this way.
>                     recordItem => '"answer" eq "YES" ? 1 : 0',
>                     info => 'answer eq "YES"',
>                     crit => 'answer ne "YES"',
167,170d188
<                     inf_field   => "cluster_connection_status",
<                     inf_default => 0,
<                     inf_tags    => qq(product="$pname",dbhost=$host,dbport=$port,sid=$dbsid,dbname=$dbname),
<                     group_by    => "$pname,$host,$port"
173,197d190
<                 $queries{"Hana ISUP: _cluster connection $hostIndex : MDC Tenant Info"} = {
<                     # retain 1 year of results: 12 runs/hr x 24 hrs/day * 365 days = 105120
<                     recordDataUnits => '1 = up, 0 = down',
<                     recordMaxResults => 110000,
<                     noCritOnError => $outage,
<                     perl => sub { return $tenant; },
<                     inf_field   => "mdc_tenant",
<                     inf_default => 0,
<                     inf_tags    => qq(product="$pname",dbhost=$host,dbport=$port,sid=$dbsid,dbname=$dbname),
<                     group_by    => "$pname,$host,$port"
<                 };
< 
<                 $queries{"Hana ISUP: _cluster connection $hostIndex - error string"} = {
<                     # retain 1 year of results: 12 runs/hr x 24 hrs/day * 365 days = 105120
<                     recordDataUnits => '1 = up, 0 = down',
<                     recordMaxResults => 110000,
<                     noCritOnError => $outage,
<                     perl => sub { return $hanaClient->error(); },
<                     inf_field   => "cluster_connection_err_str",
<                     inf_tags    => qq(product="$pname",dbhost=$host,dbport=$port,sid=$dbsid,dbname=$dbname),
<                     group_by    => "$pname,$host,$port"
<                 } unless $clusterConnectStatus;
< 
<                 $queries{"influx_details"} = { measurement => "hana_isup" };
<                  
211,237c204,228
<                     my $hana_host = "$tenant $hanaHost:$port:$dbsid:$dbname";
< 
<                     my $hanaHostClient = ariba::Ops::HanaClient->new($dbuser, $dbpass, $hanaHost, $port, undef, undef);
<                     $hanaHostClient->setDebug($debug > 1);
< 
<                     my $connectStatus = $hanaHostClient->connect($cto, $ntries) || 0;
< 
<                     $queries{$title} = {
<                         # see comments in _cluster query above for details.
<                         recordDataUnits => '1 = up, 0 = down',
<                         recordMaxResults => 110000,
<                         perl => sub { return $clusterConnectStatus ? $connectStatus : 0; },
<                         noCritOnError => $outage,
<                         inf_field    => "host_connection_status",
<                         inf_default  => 0,
<                         inf_tags     => qq(product="$pname",dbhost=$host,dbport=$port,sid=$dbsid,dbname=$dbname,hana_dbhost="$hanaHost"),
<                         group_by     => "$pname,$host,$port,$hanaHost"
<                     };
< 
<                     $queries{"$title - error string"} = {
<                         # see comments in _cluster query above for details.
<                         perl => sub { return $clusterConnectStatus ? $hanaHostClient->error() : 'Could not connect to cluster'; },
<                         noCritOnError => $outage,
<                         inf_field    => "host_connection_err_str",
<                         inf_tags     => qq(product="$pname",dbhost=$host,dbport=$port,sid=$dbsid,dbname=$dbname,hana_dbhost="$hanaHost"),
<                         group_by     => "$pname,$host,$port,$hanaHost"
<                     } unless ( $clusterConnectStatus && $connectStatus );
---
>                     if($clusterConnectStatus eq "YES") {
>                         my $hanaClient = ariba::Ops::HanaClient->new($dbuser, $dbpass, $hanaHost, $port, undef, undef);
>                         $hanaClient->setDebug($debug > 1);
> 
>                         my $connectStatus = "YES";
>                         $connectStatus = $hanaClient->error() unless $hanaClient->connect($cto, $ntries);
> 
>                         $queries{$title} = {
>                             # see comments in _cluster query above for details.
>                             recordDataUnits => '1 = up, 0 = down',
>                             recordMaxResults => 110000,
>                             recordItem => '"answer" eq "YES" ? 1 : 0',
>                             info => 'answer eq "YES"',
>                             crit => 'answer ne "YES"',
>                             perl => sub { return $connectStatus; },
>                             noCritOnError => $outage,
>                         };
>                     }
>                     else {
>                         $queries{$title} = {
>                             warn => 1,
>                             perl => sub { return 'Could not connect to cluster' },
>                             noCritOnError => $outage,
>                         };
>                     }
250c241
<                 $kids{$kid} = { product => $pname, dbhost => $host, dbport => $port };
---
>                 $kids{$kid} = $cluster_title;
253,257c244,247
<         # dont think we need this anymore - commenting them out. 
<         #if ( $isProdMsServce && %parent_queries ){
<         #    my $qm = ariba::monitor::QueryManager->newWithDetails('hana-isup', $product->name(), $me->service(), $me->customer(), \%parent_queries);
<         #    $qm->processQueries($debug, $email, $sendEmail, $sendPage);
<         #}
---
>         if ( $isProdMsServce && %parent_queries ){
>             my $qm = ariba::monitor::QueryManager->newWithDetails('hana-isup', $product->name(), $me->service(), $me->customer(), \%parent_queries);
>             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
>         }
270d259
< 
275,300c264,265
<             my $product = $kids{$kid}->{product};
<             my $dbhost = $kids{$kid}->{dbhost};
<             my $dbport = $kids{$kid}->{dbport};
< 
<             $parent_queries{"Hana ISUP: _cluster connection ($product) $dbhost:$dbport - timeout"} = {
<                 # retain 1 year of results: 12 runs/hr x 24 hrs/day * 365 days = 105120
<                 recordDataUnits => '1 = up, 0 = down',
<                 recordMaxResults => 110000,
<                 perl => sub { return 0; },
<                 inf_field   => "cluster_connection_status",
<                 inf_default => 0,
<                 inf_tags    => qq(product=$product,dbhost=$dbhost,dbport=$dbport),
<                 group_by    => "$product,$dbhost,$dbport"
<             };
< 
<             $parent_queries{"error string for cluster connection timeout ($product) $dbhost:$dbport"} = {
<                 # retain 1 year of results: 12 runs/hr x 24 hrs/day * 365 days = 105120
<                 recordDataUnits => '1 = up, 0 = down',
<                 recordMaxResults => 110000,
<                 perl => sub { return "timeout"; },
<                 inf_field   => "cluster_connection_err_str",
<                 inf_tags    => qq(product=$product,dbhost=$dbhost,dbport=$dbport),
<                 group_by    => "$dbhost,$dbport"
<             };
< 
<             $parent_queries{"influx_details"} = { measurement => "hana_isup" };
---
>             my $title = $kids{$kid};
>             $parent_queries{$title}->{perl} = sub { return "timeout"; };
304,305c269,272
<     my $qm = ariba::monitor::QueryManager->newWithDetails('hana-isup', $me->name(), $me->service(), $me->customer(), \%parent_queries);
<     $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>     unless ( $isProdMsServce ){
>         my $qm = ariba::monitor::QueryManager->newWithDetails('hana-isup', $me->name(), $me->service(), $me->customer(), \%parent_queries);
>         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
>     }
313c280
<     my ($queries, $dbsid, $dbuser, $dbpass, $hanaClient, $clusterConnectStatus, $outage, $dbhost, $dbport) = @_;
---
>     my ($queries, $dbsid, $dbuser, $dbpass, $hanaClient, $clusterConnectStatus, $outage) = @_;
315c282
<     return 0 unless (my $sysdb_host = $hanaClient->sysdb_host()); # not an MDC tenant
---
>     return '' unless (my $sysdb_host = $hanaClient->sysdb_host()); # not an MDC tenant
319c286
<     my $hostIndex  = "$sysdb_host:$sysdb_port:$dbsid:$dbname";
---
>     my $hostIndex  = "[$sysdb_host:$sysdb_port:$dbsid:$dbname]";
322d288
<     $hostIndex = "(MDC master) $hostIndex";
324,346c290,311
<         my $hanaSysdbClient = ariba::Ops::HanaClient->new($dbuser, $dbpass, $sysdb_host, $sysdb_port, undef, undef);
<         $hanaSysdbClient->setDebug($debug > 1);
<         my $sysdbConnectStatus = $hanaSysdbClient->connect($cto, $ntries) || 0;
<         
<         $queries->{$title} = {
<             description => 'the system db connection status for this MDC cluster',
<             perl => sub { return $clusterConnectStatus ? $sysdbConnectStatus : 0; },
<             noCritOnError => $outage,
<             inf_field  => "system_db_connection_status",
<             inf_default => 0,
<             inf_tags   => qq(dbhost=$dbhost,dbport=$dbport,system_dbhost=$sysdb_host,system_dbport=$sysdb_port),
<             group_by   => "$dbhost,$dbport,$sysdb_host,$sysdb_port"
<         };
< 
<         $queries->{"$title - error string"} = {
<             description => 'the error string for system db query for this MDC cluster',
<             perl => sub { return $clusterConnectStatus ? $hanaSysdbClient->error() : 'Could not connect to cluster'; },
<             noCritOnError => $outage,
<             inf_field  => "system_db_err_str",
<             inf_tags   => qq(dbhost=$dbhost,dbport=$dbport,system_dbhost=$sysdb_host,system_dbport=$sysdb_port),
<             group_by   => "$dbhost,$dbport,$sysdb_host,$sysdb_port"
<         } unless ( $clusterConnectStatus && $sysdbConnectStatus );
< 
---
>         if ($clusterConnectStatus eq "YES") {
>             my $hanaClient = ariba::Ops::HanaClient->new($dbuser, $dbpass, $sysdb_host, $sysdb_port, undef, undef);
>             $hanaClient->setDebug($debug > 1);
> 
>             my $connectStatus = "YES";
>             $connectStatus = $hanaClient->error() unless $hanaClient->connect($cto, $ntries);
> 
>             $queries->{$title} = {
>                 description => 'the system db for this MDC cluster',
>                 info => 'answer eq "YES"',
>                 crit => 'answer ne "YES"',
>                 perl => sub { return $connectStatus; },
>                 noCritOnError => $outage,
>             };
>         }
>         else {
>             $queries->{$title} = {
>                 warn => 1,
>                 perl => sub { return 'Could not connect to cluster' },
>                 noCritOnError => $outage,
>             };
>         }
348c313
<     return 1; #MDC tenant
---
>     return " (MDC tenant)";
358c323
<         my $hostIndex = "$standbyHost:$dbsid";
---
>         my $hostIndex = "[$standbyHost:$dbsid]";
361,364c326,327
<             perl => sub { return 1; },
<             inf_field => "standby_status",
<             inf_tags  => qq(standby_host="$hostIndex"),
<             group_by  => "$hostIndex"
---
>             perl => sub { return 'standby' },
>             info => 1,
filename:./bin/common/load-average-watcher
3c3
< # $Id: //ariba/services/monitor/bin/common/load-average-watcher#9 $
---
> # $Id: //ariba/services/monitor/bin/common/load-average-watcher#10 $
82,89d81
<                 inf_default => 0,
<                 group_by => "$datacenter,$hostname"
<             };
<             $queries{ qq!$hostname load average crit threshold! } = {
<                 perl      => sub { $crit },
<                 inf_field => "loadavg_crit_threshold",
<                 inf_tags  => qq|datacenter=$datacenter,hostname=$hostname|,
<                 group_by  => "$datacenter,$hostname"
93d84
< 	$queries{influx_details} = {measurement => "load_average_watcher"};
97c88
<         $q->processQueries( $debug, $email, $sendEmail, $sendPage );
---
>         $q->processQueriesUsingServer( $debug, $email, $sendEmail, $sendPage );
filename:./bin/common/oracle-long-running-transactions
15c15
< my $LOCKFILE = '/tmp/stratus-oracle-long-running-transactions';
---
> my $LOCKFILE = '/tmp/oracle-long-running-transactions';
108,121d107
< 
<         my $long_running_transaction_count = scalar(@results);
< 		my $long_running_transactions;
< 		if ($long_running_transaction_count) {
< 			for (my $i = 0; $i < $long_running_transaction_count; $i++) {
< 				$long_running_transactions .= "|";
< 				$long_running_transactions .= join('|', values(%{$results[$i]}));
< 				$long_running_transactions .= "|";
< 			}
< 		} else {
< 			$long_running_transactions = "none";
< 		}
<         $dbsid = uc($dbsid);
< 
127c113
<             'perl'          => sub { return $long_running_transaction_count }, 
---
>             'perl'          => sub {return join("\n",@results)}, 
131,149c117
<             'inf_field' => "long_running_transaction_count",
<             'inf_tags'  => "sid=$dbsid,dbhost=$host",
<             'inf_default' => 0,
<             'group_by' => $dbsid
<         };
< 
<         $sidQueries{"[$dbsid]"} = {
<             'info'          => "answer",
<             'crit'          => "answer != 0",
<             'uiHint'        => "$dbsid",
<             'description'   => "This shows Long Running Trasaction details for $dbsid",
<             'perl'          => sub {return $long_running_transactions}, 
<             correctiveActions => [
<                 Ops => 'Report to AN team',
<             ],
<             'inf_field' => "long_running_transactions",
<             'inf_tags'  => "sid=$dbsid,dbhost=$host",
<             'group_by' => $dbsid
<         };
---
>         }
151d118
<     $sidQueries{"influx_details"} = { 'measurement' => "oracle_long_running_transactions"};
filename:./bin/common/reporting-job-stats
23,26c23,26
< sub main
< {
<     my $debug     = 0;
<     my $quiet     = 0;
---
> 
> sub main {
>     my $debug = 0;
>     my $quiet = 0;
28c28
<     my $sendPage  = 0;
---
>     my $sendPage = 0;
30,32c30,31
< 
<     while (my $arg = shift (@ARGV))
<     {
---
>  
>     while(my $arg=shift(@ARGV)){
34,37c33,36
<         if ($arg =~ /^-d/o)    {$debug++;}
<         if ($arg =~ /^-e/o)    {$sendEmail = 1;}
<         if ($arg =~ /^-p$/o)   {$sendPage = 1;}
<         if ($arg =~ /^-prod/o) {$productName = shift (@ARGV);}
---
>         if($arg =~ /^-d/o){ $debug++; }
>         if($arg =~ /^-e/o){ $sendEmail=1; };
>         if($arg =~ /^-p$/o){ $sendPage=1; };
>         if($arg =~ /^-prod/o){ $productName=shift(@ARGV); };
40c39
<     my $me      = ariba::rc::InstalledProduct->new();
---
>     my $me = ariba::rc::InstalledProduct->new();
43c42
<     my $email   = $me->default('notify.email');
---
>     my $email = $me->default('notify.email');
47,49c46,47
<     unless (@products)
<     {
<         exit (0);
---
>     unless (@products) {
>         exit(0);
52,53c50
<     for my $product (@products)
<     {
---
>     for my $product (@products) {
55c52
<         my $lockfile = "/tmp/stratus-reporting-job-stats";
---
>         my $lockfile = "/tmp/reporting-job-stats";
57,59c54,55
<         $lockfile .= "-" . $product->customer() if ($product->customer());
<         if (!dmail::LockLib::requestlock($lockfile, 5))
<         {
---
>         $lockfile .= "-" . $product->customer() if($product->customer());
>         if (!dmail::LockLib::requestlock($lockfile,5)) {
65,66c61,62
<         my $dbc  = $dbcs[0];
<         my $oc   = ariba::Ops::OracleClient->newFromDBConnection($dbc);
---
>         my  $dbc = $dbcs[0];
>         my $oc = ariba::Ops::OracleClient->newFromDBConnection($dbc);
70c66
<         my %queries    = ();
---
>         my %queries  = ();
72d67
< 
77,78c72
<         map {push (@instance_array, $_)} $product->appInstancesInCluster($cluster);
< 
---
>         map{push(@instance_array,$_)}$product->appInstancesInCluster($cluster);
80,83c74,76
<         my @countgen = (1 .. scalar @instance_array);
<         for my $cg (@countgen)
<         {
<             map {$instance_hash{$cg} = $_} $product->appInstancesInCluster($cluster);
---
>         my @countgen = (1..scalar @instance_array);
>         for my $cg(@countgen) {
>             map{$instance_hash{$cg}=$_}$product->appInstancesInCluster($cluster);
86c79
<         my $instanceToMonitor = generateRandom(\%instance_hash, scalar @instance_array);
---
>         my $instanceToMonitor = generateRandom(\%instance_hash,scalar @instance_array);
88,89c81
<         for my $instance (@$instanceToMonitor)
<         {
---
>         for my $instance (@$instanceToMonitor) {
91d82
< 
96c87
<             my $results           = $reportingJobStats->request(900);
---
>             my $results = $reportingJobStats->request(900);
100,108c91
<             print "Dumper of xml:" . Dumper($xml_ref) if ($debug > 1);
< 
<             if ($xml_ref)
<             {
< 
<                 if ($xml_ref->{realm})
<                 {
<                     foreach my $realmName (keys (%{$xml_ref->{realm}}))
<                     {
---
>             print "Dumper of xml:".Dumper($xml_ref) if ($debug > 1);
109a93,97
>             if($xml_ref) {
>             
>                 if ($xml_ref->{realm}){
>                     foreach my $realmName ( keys( %{$xml_ref->{realm}} ) ) {
>                     
112,113c100
<                         foreach my $errorType (keys (%{$xml_ref->{realm}->{$realmName}->{status}}))
<                         {
---
>                         foreach my $errorType ( keys( %{$xml_ref->{realm}->{$realmName}->{status} }  ) ) {
117,118c104,105
< 
<                             $realm_href->{$realmId}->{'FailedReportingJobs'}->{'errors'}->{$errorType} = $errorCount;
---
>                             
>                             $realm_href->{$realmId}->{'FailedReportingJobs'}->{'errors'}->{$errorType} = $errorCount; 
124,130c111,115
<                 #Get all realms from DB
<                 my @realms = $oc->executeSql("select id from realmtab");    #whatever it is
<                 print "total number of realms " . scalar (@realms) . "\n" if ($debug > 1);
< 
<                 foreach my $realm (@realms)
<                 {
<                     my $realmId = $realm->{ID};
---
>                 #Get all realms from DB 
>                 my @realms = $oc->executeSql("select id from realmtab"); #whatever it is
>                 print "total number of realms".scalar(@realms)."\n" if ( $debug > 1);
> 
>                 foreach my $realmId (@realms) {
135,136c120
<                     if (exists $realm_href->{$realmId}->{'FailedReportingJobs'})
<                     {
---
>                     if( exists $realm_href->{$realmId}->{'FailedReportingJobs'} ) {
139c123
< 
---
>                     
141,152c125,142
<                                                                                         'desciption'  => 'Total count of failed reporting jobs',
<                                                                                         'severity'    => 2,
<                                                                                         'crit'        => "answer >= 5",
<                                                                                         'warn'        => "answer >= 3",
<                                                                                         'info'        => "defined(answer)",
<                                                                                         'uiHint'      => "Realms/Realm $realmId",
<                                                                                         'perl'        => sub {return $totalFailedReportingJobs;},
<                                                                                         'inf_tags'    => qq(realm_id=$realmId),
<                                                                                         'inf_field'   => qq(failed_reporting_jobs_count),
<                                                                                         'inf_default' => 0,
<                                                                                         'group_by'    => ($realmId),
<                                                                                        };
---
>                         'desciption' => 'Total count of failed reporting jobs',
>                         'severity'   => 2,
>                         'crit'       => "answer >= 5",
>                         'warn'       => "answer >= 3",
>                         'info'       => "defined(answer)",
>                         'ticketOnWarnOpenAfterMinutes' => 60,
>                         'ticketDueInDays'     => 'today',
>                         'ticketOwner' => 'unassigned-prodops',
>                         'correctiveActions'   => [
>                              Ops => 'Notify Engr and provide log file',
>                              Engr => 'Check inspector Reporting API monitor page and analyze log file',
>                         ],
>                         'graphRecorded'     => 1,
>                         'recordDataType'    => "gauge",
>                         'recordMaxResults' => 2160,
>                         'uiHint' => "Realms/Realm $realmId",
>                         'perl' => sub { return $totalFailedReportingJobs; },
>                     };
154d143
< 
160,162c149,152
<         $queries{influx_details} = {measurement => 'buyer_reporting_job_stats'};
<         my $q = ariba::monitor::QueryManager->newWithDetails("reporting-job-stats", $product->name(), $service, $product->customer(), \%queries);
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         my $q = ariba::monitor::QueryManager->newWithDetails(
>             "reporting-job-stats", $product->name(), $service, $product->customer(), \%queries
>         );
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
168,169c158
< sub parseReportingJobStats
< {
---
> sub parseReportingJobStats {
173c162,164
<     eval {$xml_href = XMLin($xml_content, ForceArray => 1);};
---
>     eval {
>         $xml_href = XMLin($xml_content,ForceArray => 1);
>     };
175,177c166,167
<     if ($@ or ref ($xml_href) !~ /Hash/i)
<     {
<         return (0);
---
>     if( $@ or ref($xml_href) !~/Hash/i ) {
>         return(0);
180c170
<     return ($xml_href);
---
>     return($xml_href);
183,190c173,178
< sub generateRandom
< {
<     my $ho     = shift;
<     my $c      = shift;
<     my $random = int (rand ($c)) + 1;
<     if ($random + 2 >= $c)
<     {
<         $random = $random - 2;
---
> sub generateRandom {
>     my $ho = shift;
>     my $c = shift;
>     my $random =  int(rand($c))+1;
>     if ($random + 2 >= $c) {
>        $random = $random - 2;
193,196c181,183
<     my @randcount = ($random .. $random + 2);
<     foreach my $rc (@randcount)
<     {
<         push (@randhashfive, $ho->{$rc});
---
>     my @randcount = ($random..$random+2);
>     foreach my $rc(@randcount) {
>        push (@randhashfive,$ho->{$rc});
198c185
<     return \@randhashfive;
---
>     return \@randhashfive; 
200a188
> 
201a190
> 
filename:./bin/dba/db-locking-check
16,17d15
< use ariba::Ops::OracleClient;
< use Data::Dumper;
21,22c19
< sub main
< {
---
> sub main {
27,28c24
<     while (my $arg = shift (@ARGV))
<     {
---
>     while (my $arg = shift(@ARGV)) {
30,34c26,30
<         if ($arg =~ m/^-h$/o) {usage(); next;}
<         if ($arg =~ m/^-d$/o)    {$debug       = 1;             next;}
<         if ($arg =~ m/^-e$/o)    {$sendEmail   = 1;             next;}
<         if ($arg =~ m/^-p$/o)    {$sendPage    = 1;             next;}
<         if ($arg =~ m/^-prod$/o) {$productName = shift (@ARGV); next;}
---
>         if ($arg =~ m/^-h$/o) { usage(); next; }
>         if ($arg =~ m/^-d$/o) { $debug=1; next; }
>         if ($arg =~ m/^-e$/o) { $sendEmail=1; next; };
>         if ($arg =~ m/^-p$/o) { $sendPage=1; next; };
>         if ($arg =~ m/^-prod$/o) { $productName = shift(@ARGV); next; };
37,41c33,37
<     my $me       = ariba::rc::InstalledProduct->new();
<     my $hostname = ariba::Ops::NetworkUtils::hostname();
<     my $cluster  = $me->currentCluster();
<     my $email    = $me->default('notify.email');
<     my $service  = $me->service();
---
>     my $me            = ariba::rc::InstalledProduct->new();
>     my $hostname      = ariba::Ops::NetworkUtils::hostname();
>     my $cluster       = $me->currentCluster();
>     my $email         = $me->default('notify.email');
>     my $service = $me->service();
44,45c40
<     foreach my $product (@products)
<     {
---
>     foreach my $product (@products) {
47,49c42,43
<         for my $dbc (ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbconnections))
<         {
<             next if $dbc->isDR();    # skip DRs
---
>         for my $dbc (ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbconnections)) {
>             next if $dbc->isDR();   # skip DRs
51c45
<             my $type = $dbc->type();
---
>             my $type     = $dbc->type();
54,56c48,50
<             my $product     = $dbc->product();
<             my $prodName    = $product->name();
<             my $service     = $product->service();
---
>             my $product  = $dbc->product();
>             my $prodName = $product->name();
>             my $service  = $product->service();
61,90c55,60
<             my $instance = my $sid = uc ($dbc->sid());
<             next if $instance =~ /HANA/;          # skip hana SIDs
<             next if $instance =~ /(MON|RMAN)/;    # skip MON and RMAN SIDs
<             next if $activeHost =~ /hana/i;       # skip hana Hosts
< 
<             my $user = "sys";
<             my $pass = $me->default("dbainfo.$user.password");
<             my $oc   = ariba::Ops::OracleClient->new($user, $pass, $sid, $virtualHost);
<             $oc->connect();
<             my @results;
<             my $no_of_blocking_count = 0;
<             my @massaged_data;
<             unless ($oc->error())
<             {
<                 my $sql =
< q(select B.USERNAME ||' ('||B.SID||','||B.SERIAL#||','||B.CLIENT_IDENTIFIER||','||B.SQL_ID||','||B.PREV_SQL_ID||') is Currently '||B.STATUS||' for last '||W.LAST_CALL_ET||' Sec and it''s BLOCKING user '|| W.USERNAME|| ' ('||W.SID||','||W.SERIAL#||','||W.CLIENT_IDENTIFIER||','||W.sql_id||','||W.prev_sql_id||')' from (select SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where BLOCKING_SESSION >0 and type <> 'BACKGROUND' and event like '%enq%' and last_call_et > 180) W, (select SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where type <> 'BACKGROUND' and sid in (select blocking_session from v$session where blocking_session >0)) B where W.BLOCKING_SESSION=B.SID union select B.USERNAME ||' ('||B.SID||','||B.SERIAL#||','||B.CLIENT_IDENTIFIER||','||B.SQL_ID||','||B.PREV_SQL_ID||') is Currently '||B.STATUS||' for last '||W.LAST_CALL_ET||' Sec and it''s BLOCKING user '|| W.USERNAME|| ' ('||W.SID||','||W.SERIAL#||','||W.CLIENT_IDENTIFIER||','||W.sql_id||','||W.prev_sql_id||')' from (select SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where BLOCKING_SESSION >0 and type <> 'BACKGROUND' and last_call_et > 90 and event like '%enq%') W, (select SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where sid in (select blocking_session from v$session where blocking_session >0 group by blocking_session having count(*) > 10) and type <> 'BACKGROUND') B where W.BLOCKING_SESSION=B.SID);
<                 $oc->executeSqlWithTimeout($sql, 400, \@results);
<                 $no_of_blocking_count = scalar (@results);
<                 if ($no_of_blocking_count)
<                 {
<                     foreach my $hash (@results)
<                     {
<                         foreach my $key (keys %{$hash})
<                         {
<                             push (@massaged_data, $hash->{$key});
<                         }
<                     }
<                 }
<             }
<             my $data_str = join (";", @massaged_data);
---
>             my $instance = uc($dbc->sid());
>             next if $instance =~ /HANA/;        # skip hana SIDs
>             next if $instance =~ /(MON|RMAN)/;  # skip MON and RMAN SIDs
>             next if $activeHost =~ /hana/i;     # skip hana Hosts
>             my $pid = fork();
>             next if ($pid); # If successful fork, parent goes to next product, child checks the SID.
94c64
<             my $time_interval = 30;    # we want to have different time intervals for TX and SV sids
---
>             my $time_interval = 30;     # we want to have different time intervals for TX and SV sids
98,119c68,79
<                                                                info              => 'answer = 0',
<                                                                sql               => "select db_wait_monitor($time_interval,20,360) as locking from dual",
<                                                                format            => "<html>%s<br></td><td>queryError</html>",
<                                                                timeout           => 400,
<                                                                recordMaxResults  => 110000,
<                                                                uiHint            => 'Locking',
<                                                                description       => 'This query detects locking on the database. Call DBA immediately if paged.',
<                                                                correctiveActions => [
<                                                                                      Ops => 'If crit, escalate to DBA',
<                                                                                     ],
<                                                                inf_tags    => qq(sid=$instance,host=$activeHost),
<                                                                inf_default => 0,
<                                                                group_by    => qq($instance,$activeHost),
<                                                               };
<             $queries{" [$instance] on $activeHost no of blocking count "} = {
<                                                                              crit        => "numrows > 0",
<                                                                              perl        => $no_of_blocking_count,
<                                                                              inf_field   => "no_of_blocking_count",
<                                                                              inf_default => 0,
<                                                                              inf_tags    => qq(sid=$instance,host=$activeHost),
<                                                                              group_by    => qq($instance,$activeHost),
<                                                                             };
---
>                 info => 'answer = 0',
>                 sql => "select db_wait_monitor($time_interval,20,360) from dual",
>                 format => "<html>%s<br></td><td>queryError</html>",
>                 timeout => 400,
>                 recordMaxResults => 110000,
>                 uiHint => 'Locking',
>                 description => 'This query detects locking on the database. Call DBA immediately if paged.',
>                 correctiveActions => [
>                     Ops => 'If crit, escalate to DBA',
>                 ],
>             };
> 
122,127c82,97
<                                                                       perl        => $data_str,
<                                                                       inf_field   => "no_of_blocking",
<                                                                       inf_default => "none",
<                                                                       inf_tags    => qq(sid=$instance,host=$activeHost),
<                                                                       group_by    => qq($instance,$activeHost),
<                                                                      };
---
>                 info => 'numrows = 0',
>                 crit => "numrows > 0",
>                 sql => q(select B.USERNAME ||' ('||B.SID||','||B.SERIAL#||','||B.CLIENT_IDENTIFIER||','||B.SQL_ID||','||B.PREV_SQL_ID||') is Currently '||B.STATUS||' for last '||W.LAST_CALL_ET||' Sec and it''s BLOCKING user '|| W.USERNAME|| ' ('||W.SID||','||W.SERIAL#||','||W.CLIENT_IDENTIFIER||','||W.sql_id||','||W.prev_sql_id||')' from (select SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where BLOCKING_SESSION >0 and type <> 'BACKGROUND' and event like '%enq%' and last_call_et > 600) W, (select SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where type <> 'BACKGROUND' and sid in (select blocking_session from v$session where blocking_session >0)) B where W.BLOCKING_SESSION=B.SID union select B.USERNAME ||' ('||B.SID||','||B.SERIAL#||','||B.CLIENT_IDENTIFIER||','||B.SQL_ID||','||B.PREV_SQL_ID||') is Currently '||B.STATUS||' for last '||W.LAST_CALL_ET||' Sec and it''s BLOCKING user '|| W.USERNAME|| ' ('||W.SID||','||W.SERIAL#||','||W.CLIENT_IDENTIFIER||','||W.sql_id||','||W.prev_sql_id||')' from (select SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where BLOCKING_SESSION >0 and type <> 'BACKGROUND' and last_call_et > 90 and event like '%enq%') W, (select SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET,sql_id,prev_sql_id,CLIENT_IDENTIFIER from v$session where sid in (select blocking_session from v$session where blocking_session >0 group by blocking_session having count(*) > 10) and type <> 'BACKGROUND') B where W.BLOCKING_SESSION=B.SID),
>                 format => "<html>%s<br></td><td>queryError</html>",
>                 timeout => 400,
>                 recordMaxResults => 110000,
>                 uiHint => 'Locking',
>                 description => 'This query detects number of waiting/blocking  on the database. Call DBA immediately if paged.',
>                 correctiveActions => [
>                     Ops => 'If crit, escalate to DBA',
>                 ],
>             };
> 
>             my $qm = ariba::monitor::QueryManager->newWithDetails(
>                 "dba", $product->name(), $product->service(), undef, \%queries
>             );
129,130c99,100
<             $queries{influx_details} = {measurement => 'dba_db_locking'};
<             my $qm = ariba::monitor::QueryManager->newWithDetails("dba", $product->name(), $product->service(), undef, \%queries);
---
>             my $user = "sys";
>             my $pass = $me->default("dbainfo.$user.password");
133c103,104
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
>             return;
135c106
<     }
---
>     }       
140a112
> 
filename:./bin/dba/db-sequence-check
20,22c20,21
< sub usage
< {
<     my $error = shift;
---
> sub usage {
>         my $error = shift;
24c23
<     print <<USAGE;
---
>         print <<USAGE;
36c35
<     print "(error) $error\n" if $error;
---
>         print "(error) $error\n" if $error;
38c37
<     exit ();
---
>         exit();
41,42c40
< sub main
< {
---
> sub main {
47,48c45
<     while (my $arg = shift (@ARGV))
<     {
---
>     while (my $arg = shift(@ARGV)) {
50,54c47,51
<         if ($arg =~ m/^-h$/o) {usage(); next;}
<         if ($arg =~ m/^-d$/o)    {$debug       = 1;             next;}
<         if ($arg =~ m/^-e$/o)    {$sendEmail   = 1;             next;}
<         if ($arg =~ m/^-p$/o)    {$sendPage    = 1;             next;}
<         if ($arg =~ m/^-prod$/o) {$productName = shift (@ARGV); next;}
---
>         if ($arg =~ m/^-h$/o) { usage(); next; }
>         if ($arg =~ m/^-d$/o) { $debug=1; next; }
>         if ($arg =~ m/^-e$/o) { $sendEmail=1; next; };
>         if ($arg =~ m/^-p$/o) { $sendPage=1; next; };
>         if ($arg =~ m/^-prod$/o) { $productName = shift(@ARGV); next; };
57,61c54,58
<     my $me       = ariba::rc::InstalledProduct->new();
<     my $hostname = ariba::Ops::NetworkUtils::hostname();
<     my $cluster  = $me->currentCluster();
<     my $email    = $me->default('notify.email');
<     my $service  = $me->service();
---
>     my $me	          = ariba::rc::InstalledProduct->new();
>     my $hostname      = ariba::Ops::NetworkUtils::hostname();
>     my $cluster       = $me->currentCluster();
>     my $email         = $me->default('notify.email');
>     my $service = $me->service();
64,65c61
<     foreach my $product (@products)
<     {
---
>     foreach my $product (@products) {
67,76c63,71
<         for my $dbc (ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbconnections))
<         {
<             next if $dbc->isDR();    # skip DRs
< 
<             my $type        = $dbc->type();
<             my $user        = "sys";
<             my $pass        = $me->default("dbainfo.$user.password");
<             my $product     = $dbc->product();
<             my $prodName    = $product->name();
<             my $service     = $product->service();
---
>         for my $dbc (ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbconnections)) {
>             next if $dbc->isDR();	# skip DRs
>            
>             my $type     = $dbc->type();
> 	    my $user = "sys";
> 	    my $pass = $me->default("dbainfo.$user.password");
>             my $product  = $dbc->product();
>             my $prodName = $product->name();
>             my $service  = $product->service();
81,83c76,78
<             my $instance = uc ($dbc->sid());
<             next if $instance =~ /HANA/;        # skip hana SIDs
<             next if $virtualHost =~ /hana/i;    # skip hana Hosts
---
>             my $instance = uc($dbc->sid());
>             next if $instance =~ /HANA/;		# skip hana SIDs
>             next if $virtualHost =~ /hana/i;		# skip hana Hosts
86,105c81,101
< 
<             my $oc = ariba::Ops::OracleClient->new($user, $pass, $instance, $virtualHost);
<             $oc->connect();
<             my $versionSql = 'select version from v$instance';
< 
<             my $version         = $oc->executeSql($versionSql);
<             my $requiredVersion = "11.2.0.2";
< 
<             $queries{"$instance on $activeHost with sequence constraint number"} = {
<                                                                                     warn                         => "answer = 2000000000 && $version eq $requiredVersion",
<                                                                                     sql                          => 'select con# as cons_num from con$ where name=\'_NEXT_CONSTRAINT\' and owner#=0',
<                                                                                     recordMaxResults             => 110000,
<                                                                                     ticketOnWarnOpenAfterMinutes => 1,
<                                                                                     ticketOwner                  => "unassigned-dba",
<                                                                                     uiHint                       => 'Incremental Constraint Sequence',
<                                                                                     inf_tags                     => qq(sid=$instance,host=$activeHost),
<                                                                                    };
< 
<             $queries{influx_details} = {measurement => 'dba_db_sequence_check'};
<             my $qm = ariba::monitor::QueryManager->newWithDetails("dba", $product->name(), $product->service(), undef, \%queries);
---
> 		
> 	    my $oc = ariba::Ops::OracleClient->new($user, $pass, $instance, $virtualHost);
> 	    $oc->connect();
> 	    my $versionSql = 'select version from v$instance';
> 	
> 	    my $version = $oc->executeSql($versionSql);
> 	    my $requiredVersion = "11.2.0.2";
> 
> 	    $queries{"$instance on $activeHost with sequence constraint number"} = {
> 	        warn => "answer = 2000000000 && $version eq $requiredVersion" ,
> 	        sql => 'select con# from con$ where name=\'_NEXT_CONSTRAINT\' and owner#=0', 
> 	        recordMaxResults => 110000,
> 	        ticketOnWarnOpenAfterMinutes => 1,
> 	        ticketOwner => "unassigned-dba",
> 	        uiHint => 'Incremental Constraint Sequence',
> 	        };
> 
>             my $qm = ariba::monitor::QueryManager->newWithDetails(
>                 "dba", $product->name(), $product->service(), undef, \%queries
>             );
> 		
108,110c104,106
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
<         }
<     }
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
>             }
>     }       
filename:./bin/dba/physical-dataguard-status-replicated
106,107c106
<             #my ( $db_link, $repInstance ) = split('\s+',$link_instance);
<             my ( $db_link, $repInstance ) = ($link_instance->{DB_LINK},$link_instance->{HOST});
---
>             my ( $db_link, $repInstance ) = split('\s+',$link_instance);
113d111
< 
116,117c114
<             my $r = $oc->executeSql($query);
<             my $repHost = $r->{HOST_NAME};
---
>             my $repHost = $oc->executeSql($query);
120,130d116
<                 my $inf_tags = qq(db_type=$uiHint,rep_instance=$repInstance,instance_host=$repHost);
<                 $queries{"shipping warn"} = {
<                     perl => sub { return $shipWarn},
<                     inf_field => "shipWarn",
<                     inf_tags => $inf_tags,
<                 };
<                 $queries{"shipping crit"} = {
<                     perl => sub { return $shipCrit},
<                     inf_field => "shipCrit",
<                     inf_tags => $inf_tags,
<                 };
132d117
<                     inf_tags => $inf_tags,
144c129
<                     sql => "select(next_time_onpri-next_time_ondr)*86400 shipping_lag
---
>                     sql => "select(next_time_onpri-next_time_ondr)*86400
157d141
<                     inf_tags => $inf_tags,
173c157
<                              extract(second from to_dsinterval(value)) as apply_lag_duration
---
>                              extract(second from to_dsinterval(value))
179d162
<                     inf_tags => $inf_tags,
191c174
<                     sql => "select (primary_date-standby_date) * 86400 as total_lag_duration
---
>                     sql => "select (primary_date-standby_date) * 86400
200d182
<                     inf_tags => $inf_tags,
206c188
<                     sql => "select max(unapp_redo) as unapplied_logs_quantity from 
---
>                     sql => "select max(unapp_redo) from 
218d199
<                     inf_tags => $inf_tags,
224c205
<                     sql => "select avg(sofar) as average_apply_rate from v\$recovery_progress\@$db_link
---
>                     sql => "select avg(sofar) from v\$recovery_progress\@$db_link
229d209
<                     inf_tags => $inf_tags,
235c215
<                     sql => "select round(unapplied_redo/apply_rate,2) as time_to_apply
---
>                     sql => "select round(unapplied_redo/apply_rate,2)
252,261d231
<                 $queries{"mode"} = {
<                     perl => sub {return $mode},
<                     inf_field => "mode",
<                     inf_tags => $inf_tags,
<                 };
<                 $queries{"inBackup"} = {
<                     perl => sub {return $inBackup},
<                     inf_field => "in_backup",
<                     inf_tags => $inf_tags,
<                 };
263d232
<                     inf_tags => $inf_tags,
272c241
<                     sql => q`select recovery_mode as recovery_mode from v$archive_dest_status where type='PHYSICAL'`,
---
>                     sql => q`select recovery_mode from v$archive_dest_status where type='PHYSICAL'`,
278d246
<                     inf_tags => $inf_tags,
291c259
<                              else 'Recovery not Running' end) as gap_status from
---
>                              else 'Recovery not Running' end) \"Gap status\" from
304d271
<                     inf_tags => $inf_tags,
313c280
<                     sql => "select status as apply_status from v\$managed_standby\@$db_link where process='MRP0'",
---
>                     sql => "select status from v\$managed_standby\@$db_link where process='MRP0'",
317d283
<                 inf_tags => qq(db_type=$uiHint,rep_instance=$repInstance,instance_host=$virtualHost),
325c291
<                 sql => q`select error as archive_destination_error from v$archive_dest_status where dest_id=2`,
---
>                 sql => q`select error from v$archive_dest_status where dest_id=2`,
327c293
<             $queries{influx_details} = {measurement => "physical_dataguard_replicated"}; 
---
>      
330c296
<             $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>             $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
filename:./bin/dms/dms-metrices
1c1
< #!/usr/local/bin/perl
---
> #!/usr/local/bin/perl -w
3c3
< # $Id: //ariba/services/monitor/bin/dms/dms-metrices#1 $
---
> # $Id: //ariba/services/monitor/bin/dms/dms-metrices#2 $
60,63c60,63
<         if ($arg =~ /^-h$/o) { usage();         next; }
<         if ($arg =~ /^-d$/o) { $debug++;        next; }
<         if ($arg =~ /^-e$/o) { $sendEmail++;    next; }
<         if ($arg =~ /^-p$/o) { $sendPage++;     next; }
---
>         if ($arg =~ /^-h$/o)  { usage();        next; }
>         if ($arg =~ /^-d$/o)  { $debug++;       next; }
>         if ($arg =~ /^-e$/o)  { $sendEmail++;   next; }
>         if ($arg =~ /^-p$/o)  { $sendPage++;    next; }
76c76
< 
---
>     
84c84
< 
---
>         
87c87
< 
---
>             
91c91
<         
---
>                 
94c94
<                     my $result = ( defined $fieldData ) ? 1 : 0; # 1 = "Yes", 0 = "No"
---
>                     my $result = ( defined $fieldData ) ? "Yes":"No";
101,106c101,102
<                             'inf_field'          => "data_fetched",
<                             'inf_default'        => 0,
<                             'inf_tags'           => qq(field="$field",realmid="$realmid"),
<                             'group_by'           => qq($realmid,$field),
<                         };
<                         
---
>                                 };
>                                 
112a109
>                         
114,116c111,113
< 
<                             foreach my $param (@$parameters) {          
<                                 my $info = 1 ;
---
>                         
>                             foreach my $param (@$parameters) {
>                                 my $info = 1;
118c115
< 
---
>                                 
125c122
<                                         'recordMaxResults'  => 180,
---
>                                         'recordMaxResults'  => 4500,
131,134d127
<                                         'inf_field'         => "cnt",
<                                         'inf_default'       => 0,
<                                         'inf_tags'          => qq(action="$param",field="$field",type="$type->{type}",realmid="$realmid"),
<                                         'group_by'          => qq($realmid,$param,$field,$type->{type}),
145c138
< 
---
>     
148c141
<        
---
>         
150c143
< 
---
>         
163c156
< 
---
>                     
166c159
<                         my $result = ( defined $fieldData ) ? 1 : 0; # 1 = "Yes" 0 = "No"
---
>                         my $result = ( defined $fieldData ) ? "Yes":"No";
173,176d165
<                                 'inf_field'          => 'data_fetched',
< 								'inf_default'        => 0,
<                                 'inf_tags'           => qq(field="$field",node="$nodeName"),
<                                 'group_by'           => qq($nodeName,$field),
178c167
< 
---
>                                     
185c174
< 
---
>                             
187c176
< 
---
>                             
191c180
< 
---
>                                     
204,207d192
<                                             'inf_field'         => "cnt",
<                                             'inf_default'       => 0,
<                                             'inf_tags'          => qq(action="$param",field="$field",type="$type->{type}",node="$nodeName"),
<                                             'group_by'          => qq($nodeName,$param,$field,$type->{type}),
217c202
< 
---
>             
226c211
< 
---
>                     
230c215
< 
---
>                         
234c219
< 
---
>                             
243c228
<                                     'recordOnError'     => 1,
---
>                                     'recordOnError'     => 1, 
247,250d231
<                                     'inf_field'         => "cnt",
<                                     'inf_default'       => 0,
<                                     'inf_tags'          => qq(action="$param",datasource="$name",node="$nodeName"),
<                                     'group_by'          => qq($nodeName,$param,$name),
260d240
< 
264d243
<         $queries{'influx_details'} = {measurement => 'dms_metrics'};
266c245
<         $qm->processQueries($debug, $email, $sendEmail, $sendPage);
---
>         $qm->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
271d249
< 
276c254
< 
---
>     
279c257
<     my $timeout = 300;
---
>     my $timeout = 60;
311,397d288
< 
< #
< # sample output DEV8 service
< # http://svcdev8ss.ariba.com/dms/monitor/metrices
< =head
< 
< {  
<    "status":"OK",
<    "statusCode":200,
<    "fetchSize":0,
<    "pageNumber":0,
<    "totalRecords":0,
<    "totalPages":0,
<    "errorMessages":[  
< 
<    ],
<    "debugInfo":{  
<       "requestProcessingTime":null,
<       "storeProcessingTime":null
<    },
<    "realms":[  
<       {  
<          "realm":{  
<             "realm_id":"s4All-21",
<             "scheduledJobs":[  
<                {  
<                   "type":"AML_PULL",
<                   "lastSuccessfulRunTime":1481029200597,
<                   "sourceId":"DMSE2E",
<                   "success":3831,
<                   "failure":38990,
<                   "created":11,
<                   "processing":0
<                },
<             ],
<             "inBoundMessageQueue":[  
<                {  
<                   "type":"ITEM_PRICE",
<                   "success":3,
<                   "failure":0,
<                   "created":0,
<                   "processing":0
<                }
<             ],
<             "outBoundMessageQueue":[  
<                {  
<                   "type":"PIR",
<                   "success":0,
<                   "failure":0,
<                   "created":2,
<                   "processing":0
<                }
<             ],
<             "fileImport":null
<          }
<       },
<       {  
<          "realm":{  
<             "realm_id":"s4All-7",
<             "scheduledJobs":[  
<                {  
<                   "type":"BOMUploadPostProcess",
<                   "lastSuccessfulRunTime":1480412584699,
<                   "sourceId":"s4All-7",
<                   "success":2134,
<                   "failure":43828,
<                   "created":0,
<                   "processing":0
<                },
<             ],
<             "inBoundMessageQueue":null,
<             "outBoundMessageQueue":null,
<             "fileImport":[  
<                {  
<                   "type":"DataMigration",
<                   "inProgress":0,
<                   "completed":39,
<                   "cancelled":0
<                }
<             ]
<          }
<       }
<    ]
< }
< 
< =cut
< 
400a292
> 
filename:./bin/s4/activity-stats
23c23
<     my $debug = shift;
---
>     my $debug = shift; 
45c45
< 
---
>         
54,61c54,61
< sub initSchemaStats {
<     my $schemaStatsRef = shift;
<     my $schemaIdsRef = shift;
<     my $schemaStatFieldsRef = shift;
< 
<     for my $field (keys %$schemaStatFieldsRef) {
<         for my $schemaId (@$schemaIdsRef) {
<             $schemaStatsRef->{$schemaId}{$field} = 0;
---
> sub initSchemaStats { 
>     my $schemaStatsRef = shift; 
>     my $schemaIdsRef = shift; 
>     my $schemaStatFieldsRef = shift; 
> 
>     for my $field (keys %$schemaStatFieldsRef) { 
>         for my $schemaId (@$schemaIdsRef) { 
>             $schemaStatsRef->{$schemaId}{$field} = 0; 
64c64
< }
---
> } 
67,75c67,75
< sub parseSchemaStatsAndStoreHighestValues {
<     my $stats = shift;
<     my $schemaStatsRef = shift;
<     my $queryName = shift;
< 
<     if ($stats) {
<         while ($stats =~ /Schema(\d+):(\d+)/g) {
<             my $schemaId = int($1);
<             my $value = $2;
---
> sub parseSchemaStatsAndStoreHighestValues { 
>     my $stats = shift; 
>     my $schemaStatsRef = shift; 
>     my $queryName = shift; 
> 
>     if ($stats) { 
>         while ($stats =~ /Schema(\d+):(\d+)/g) { 
>             my $schemaId = int($1); 
>             my $value = $2; 
78c78
<     }
---
>     } 
161c161
<                 }
---
>                 }                                
213c213
<             'queryName' => 'S4 star schema failed pulls',
---
>             'queryName' => 'S4 star schema failed pulls', 
222,223c222,223
<         analysisFailedASMSharedSchemaValidations => {
<             'queryName' => 'S4 star schema failed validations',
---
>         analysisFailedASMSharedSchemaValidations => { 
>             'queryName' => 'S4 star schema failed validations', 
235,237c235,237
<         },
<         analysisMaxTimeSinceLastSharedLoad => {
<             'queryName' => 'S4 star schema time elapsed since the last load completed (in minutes); 0 if current load has started',
---
>         }, 
>         analysisMaxTimeSinceLastSharedLoad => { 
>             'queryName' => 'S4 star schema time elapsed since the last load completed (in minutes); 0 if current load has started', 
243,247c243,247
<         },
<         analysisASMSharedSchemaCurrentLoadTime => {
<             'queryName' => 'S4 star schema time for which the current load has been running (in minutes); 0 if current load has not started',
<             'warn' => 'answer >= 1080',
<             'crit' => 'answer >= 2160',
---
>         }, 
>         analysisASMSharedSchemaCurrentLoadTime => { 
>             'queryName' => 'S4 star schema time for which the current load has been running (in minutes); 0 if current load has not started', 
>             'warn' => 'answer >= 1080', 
>             'crit' => 'answer >= 2160', 
251,252c251,252
<         },
<     );
---
>         }, 
>     ); 
291,292c291,292
<         my %schemaStats = ();
< 
---
>         my %schemaStats = (); 
>         
309c309
< 
---
>         
311,312c311,312
<         print "SCHEMA ID \n", Dumper(@schemaIds), "\n", if($debug) ;
<         initSchemaStats(\%schemaStats, \@schemaIds, \%schemaStatFields) if (@schemaIds);
---
>         print "SCHEMA ID \n", Dumper(@schemaIds), "\n", if($debug) ; 
>         initSchemaStats(\%schemaStats, \@schemaIds, \%schemaStatFields) if (@schemaIds); 
318,324c318
<             $instanceName =~ s/,//g;
< 
<             my ($uiHint, $inf_tags);
< 
<             my $app_name = $instance->appName();
<             $app_name =~ s/,//g;
< 
---
>             my $uiHint;
326c320
<                 $uiHint = $app_name;
---
>                 $uiHint = $instance->appName();
335,336c329
<                 $uiHint = "$community/" . $app_name;
<                 $inf_tags = qq|community="$community",app_name=$app_name,instance_name=$instanceName|;
---
>                 $uiHint = "$community/" . $instance->appName();
365,367d357
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Incoming Request Count"|,
<                     'group_by' => qq|$inf_tags,description="Incoming Request Count"|,
377,379d366
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Incoming Request Failures"|,
<                     'group_by' => qq|$inf_tags,description="Incoming Request Failures"|,
389,391d375
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Send Quote Count"|,
<                     'group_by' => qq|$inf_tags,description="Send Quote Count"|,
401,403d384
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Send Quote Failures"|,
<                     'group_by' => qq|$inf_tags,description="Send Quote Failures"|,
413,415d393
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Posting Update Count"|,
<                     'group_by' => qq|$inf_tags,description="Posting Update Count"|,
425,427d402
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Posting Update Failures"|,
<                     'group_by' => qq|$inf_tags,description="Posting Update Failures"|,
451,453d425
<                         'inf_field' => "value",
<                         'inf_tags' => qq|$inf_tags,description="Large/Huge RFX Count"|,
<                         'group_by' => qq|$inf_tags,description="Large/Huge RFX Count"|,
469,471d440
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Active RFX Count"|,
<                     'group_by' => qq|$inf_tags,description="Active RFX Count"|,
486,488d454
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="New RFX Count"|,
<                     'group_by' => qq|$inf_tags,description="New RFX Count"|,
503,505d468
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Sourcing Work Load"|,
<                     'group_by' => qq|$inf_tags,description="Sourcing Work Load"|,
523,525d485
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Number of Bids Processed since last sample"|,
<                     'group_by' => qq|$inf_tags,description="Number of Bids Processed since last sample"|,
550,551c510,511
<             #AnalysisSharedSchemaLoadsFailed - List of shared schema having
<             #   failed loads with number of failures.
---
>             #AnalysisSharedSchemaLoadsFailed - List of shared schema having 
>             #   failed loads with number of failures. 
554c514
<             #AnalysisFailedASMSharedSchemaValidations - number of validation
---
>             #AnalysisFailedASMSharedSchemaValidations - number of validation 
556c516
<             #AnalysisGlobalDedicatedPresentationLoads - Number of running
---
>             #AnalysisGlobalDedicatedPresentationLoads - Number of running 
558c518
<             #AnalysisGlobalSharedPresentationLoads - Number of running shared
---
>             #AnalysisGlobalSharedPresentationLoads - Number of running shared 
561c521
<             #AnalysisMaxTimeSinceLastSharedLoad - List of times since last
---
>             #AnalysisMaxTimeSinceLastSharedLoad - List of times since last 
577,579c537,539
<                 for my $statField (keys %schemaStatFields) {
<                     my $stats = $monitorStats->attribute($statField);
<                     parseSchemaStatsAndStoreHighestValues($stats, \%schemaStats, $statField);
---
>                 for my $statField (keys %schemaStatFields) { 
>                     my $stats = $monitorStats->attribute($statField); 
>                     parseSchemaStatsAndStoreHighestValues($stats, \%schemaStats, $statField); 
595,597d554
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Number of SV dataloads in progress"|,
<                     'group_by' => qq|$inf_tags,description="Number of SV dataloads in progress"|,
607,609d563
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Number of SV A/B switch in progress"|,
<                     'group_by' => qq|$inf_tags,description="Number of SV A/B switch in progress"|,
627,629d580
<                     'inf_field' => "value",
<                     'inf_tags' => qq|$inf_tags,description="Number of Failed Schema Operations"|,
<                     'group_by' => qq|$inf_tags,description="Number of Failed Schema Operations"|,
641,642d591
<                             'inf_field' => 'total_failed_dedicated_presentation_load',
<                             'group_by' => 'general'
655,659d603
<                             $queries{hasPreMigrationError} = {
<                                 perl => sub {return $hasPreMigrationError},
<                                 inf_field => 'hasPreMigrationError',
<                                 group_by => 'general',
<                             };
667,668d610
<                                 'inf_field' => 'pre_migration_status',
<                                 'group_by' => 'general',
680,684d621
<                             $queries{hasPostMigrationError} = {
<                                 perl => sub {return $hasPostMigrationError},
<                                 inf_field => 'hasPostMigrationError',
<                                 group_by => 'general',
<                             };
692,693d628
<                                 'inf_field' => "post_migration_status",
<                                 'group_by' => 'general',
701,705d635
<                             $queries{preMigrationTakingLongTime} = {
<                                 perl => sub {return $preMigrationTakingLongTime},
<                                 inf_field => 'preMigrationTakingLongTime',
<                                 group_by => 'general',
<                             };
713,714d642
<                                 'inf_field' => 'long_running_pre_migration',
<                                 'group_by' => 'general',
722,726d649
<                             $queries{postMigrationTakingLongTime} = {
<                                 perl => sub {return $postMigrationTakingLongTime},
<                                 inf_field => 'postMigrationTakingLongTime',
<                                 group_by => 'general',
<                             };
734,735d656
<                                 'inf_field' => 'long_running_post_migration',
<                                 'group_by' => 'general',
753,754d673
<                                 'inf_field' => 'hana_dedicated_load_errors',
<                                 'group_by' => 'general',
772,773d690
<                                 'inf_field' => 'hana_long_running_presentation_load',
<                                 'group_by' => 'general',
791,792d707
<                                 'inf_field' => 'hana_long_running_data_loads',
<                                 'group_by' => 'general',
810,811d724
<                                 'inf_field' => 'schema_on_more_than_one_host',
<                                 'group_by' => 'general',
839,845c752,758
<                     my @archesMonitors =
<                         ( [ "realmsExceedingPublishTimeForNRTPriorityMetric",
<                             "Arches Search - Number of items exceeding the SLA for NRT priority per realm",
<                             "Arches Search - Number of items exceeding the SLA for NRT priority in community",
<                             "Arches Search - Number of items exceeding the SLA for NRT priority in all communites",
<                             "500",
<                             "200",
---
>                     my @archesMonitors =  
>                         ( [ "realmsExceedingPublishTimeForNRTPriorityMetric",  
>                             "Arches Search - Number of items exceeding the SLA for NRT priority per realm", 
>                             "Arches Search - Number of items exceeding the SLA for NRT priority in community", 
>                             "Arches Search - Number of items exceeding the SLA for NRT priority in all communites", 
>                             "500", 
>                             "200", 
847,852c760,765
<                           [ "realmsExceedingPublishTimeForTopPriorityMetric",
<                             "Arches Search - Number of items exceeding the SLA for Top priority per realm",
<                             "Arches Search - Number of items exceeding the SLA for Top priority in community",
<                             "Arches Search - Number of items exceeding the SLA for Top priority in all communities",
<                             "1500",
<                             "600",
---
>                           [ "realmsExceedingPublishTimeForTopPriorityMetric", 
>                             "Arches Search - Number of items exceeding the SLA for Top priority per realm", 
>                             "Arches Search - Number of items exceeding the SLA for Top priority in community", 
>                             "Arches Search - Number of items exceeding the SLA for Top priority in all communities", 
>                             "1500", 
>                             "600", 
854,859c767,772
<                           [ "realmsExceedingPublishTimeForFilePriorityMetric",
<                             "Arches Search - Number of items exceeding the SLA for File priority per realm",
<                             "Arches Search - Number of items exceeding the SLA for File priority in community",
<                             "Arches Search - Number of items exceeding the SLA for File priority in all communities",
<                             "3500",
<                             "1400",
---
>                           [ "realmsExceedingPublishTimeForFilePriorityMetric", 
>                             "Arches Search - Number of items exceeding the SLA for File priority per realm", 
>                             "Arches Search - Number of items exceeding the SLA for File priority in community", 
>                             "Arches Search - Number of items exceeding the SLA for File priority in all communities", 
>                             "3500", 
>                             "1400", 
861,866c774,779
<                           [ "realmsExceedingPublishTimeForBatchPriorityMetric",
<                             "Arches Search - Number of items exceeding the SLA for Batch priority per realm",
<                             "Arches Search - Number of items exceeding the SLA for Batch priority in community",
<                             "Arches Search - Number of items exceeding the SLA for Batch priority in all communities",
<                             "2500",
<                             "1000",
---
>                           [ "realmsExceedingPublishTimeForBatchPriorityMetric", 
>                             "Arches Search - Number of items exceeding the SLA for Batch priority per realm", 
>                             "Arches Search - Number of items exceeding the SLA for Batch priority in community", 
>                             "Arches Search - Number of items exceeding the SLA for Batch priority in all communities", 
>                             "2500", 
>                             "1000", 
868,873c781,786
<                           [ "unpublishedWorkItemCountForNRTPriorityMetric",
<                             "Arches Search - Number of unpublished items for NRT priority per realm",
<                             "Arches Search - Number of unpublished items for NRT priority in community",
<                             "Arches Search - Number of unpublished items for NRT priority in all communities",
<                             "",
<                             "",
---
>                           [ "unpublishedWorkItemCountForNRTPriorityMetric", 
>                             "Arches Search - Number of unpublished items for NRT priority per realm", 
>                             "Arches Search - Number of unpublished items for NRT priority in community", 
>                             "Arches Search - Number of unpublished items for NRT priority in all communities", 
>                             "", 
>                             "", 
875,880c788,793
<                           [ "unpublishedWorkItemCountForTopPriorityMetric",
<                             "Arches Search - Number of unpublished items for Top priority per realm",
<                             "Arches Search - Number of unpublished items for Top priority in community",
<                             "Arches Search - Number of unpublished items for Top priority in all communities",
<                             "",
<                             "",
---
>                           [ "unpublishedWorkItemCountForTopPriorityMetric", 
>                             "Arches Search - Number of unpublished items for Top priority per realm", 
>                             "Arches Search - Number of unpublished items for Top priority in community", 
>                             "Arches Search - Number of unpublished items for Top priority in all communities", 
>                             "", 
>                             "", 
882,887c795,800
<                           [ "unpublishedWorkItemCountForFilePriorityMetric",
<                             "Arches Search - Number of unpublished items for File priority per realm",
<                             "Arches Search - Number of unpublished items for File priority in community",
<                             "Arches Search - Number of unpublished items for File priority in all communities",
<                             "",
<                             "",
---
>                           [ "unpublishedWorkItemCountForFilePriorityMetric", 
>                             "Arches Search - Number of unpublished items for File priority per realm", 
>                             "Arches Search - Number of unpublished items for File priority in community", 
>                             "Arches Search - Number of unpublished items for File priority in all communities", 
>                             "", 
>                             "", 
889,894c802,807
<                           [ "unpublishedWorkItemCountForBatchPriorityMetric",
<                             "Arches Search - Number of unpublished items for Batch priority per realm",
<                             "Arches Search - Number of unpublished items for Batch priority in community",
<                             "Arches Search - Number of unpublished items for Batch priority in all communities",
<                             "",
<                             "",
---
>                           [ "unpublishedWorkItemCountForBatchPriorityMetric", 
>                             "Arches Search - Number of unpublished items for Batch priority per realm", 
>                             "Arches Search - Number of unpublished items for Batch priority in community", 
>                             "Arches Search - Number of unpublished items for Batch priority in all communities", 
>                             "", 
>                             "", 
896,901c809,814
<                           [ "unpublishedWorkItemCountForBatchPriorityMetric",
<                             "Arches Search - Number of unpublished items for Batch priority per reelm",
<                             "Arches Search - Number of unpublished items for Batch priority in community",
<                             "Arches Search - Number of unpublished items for Batch priority in all communities",
<                             "",
<                             "",
---
>                           [ "unpublishedWorkItemCountForBatchPriorityMetric", 
>                             "Arches Search - Number of unpublished items for Batch priority per reelm", 
>                             "Arches Search - Number of unpublished items for Batch priority in community", 
>                             "Arches Search - Number of unpublished items for Batch priority in all communities", 
>                             "", 
>                             "", 
903,908c816,821
<                           [ "numberOfArchesPublishRequestFailurePerRealmMetric",
<                             "Arches Search - Number of failed publish requests per realm",
<                             "Arches Search - Number of failed publish requests in community",
<                             "Arches Search - Number of failed publish requests in all communities",
<                             "10",
<                             "",
---
>                           [ "numberOfArchesPublishRequestFailurePerRealmMetric", 
>                             "Arches Search - Number of failed publish requests per realm", 
>                             "Arches Search - Number of failed publish requests in community", 
>                             "Arches Search - Number of failed publish requests in all communities", 
>                             "10", 
>                             "", 
910,915c823,828
<                           [ "numberOfArchesPublishRequestSkippedPerRealmMetric",
<                             "Arches Search - Number of skipped publish requests per realm",
<                             "Arches Search - Number of skipped publish requests in community",
<                             "Arches Search - Number of skipped publish requests in all communities",
<                             "",
<                             "",
---
>                           [ "numberOfArchesPublishRequestSkippedPerRealmMetric", 
>                             "Arches Search - Number of skipped publish requests per realm", 
>                             "Arches Search - Number of skipped publish requests in community", 
>                             "Arches Search - Number of skipped publish requests in all communities", 
>                             "", 
>                             "", 
971c884
< 
---
>                 
979c892
< 
---
>                     
984,985c897,898
< 
<                     push @{ $s4MetricRollupRef->{ "dataPushErrorCount" }->{ "values" } }, addS4Queries( \%queries, $monitorStats, "dataPushErrorCount", "$instanceName DataPush - Number of failed pushes", "$uiHint/DataPush" );
---
>                     
>                     push @{ $s4MetricRollupRef->{ "dataPushErrorCount" }->{ "values" } }, addS4Queries( \%queries, $monitorStats, "dataPushErrorCount", "$instanceName DataPush - Number of failed pushes", "$uiHint/DataPush" );                              
989c902
< 
---
>                     
994,995c907,908
<                     $s4MetricRollupRef->{ "dataUpdaterWorkTotalCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";
< 
---
>                     $s4MetricRollupRef->{ "dataUpdaterWorkTotalCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";                    
>                     
999,1000c912,913
<                     $s4MetricRollupRef->{ "dataUpdaterWorkSuccessCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";
< 
---
>                     $s4MetricRollupRef->{ "dataUpdaterWorkSuccessCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";                       
>                     
1004,1005c917,918
<                     $s4MetricRollupRef->{ "dataUpdaterWorkErrorCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";
< 
---
>                     $s4MetricRollupRef->{ "dataUpdaterWorkErrorCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";                        
>                     
1009,1010c922,923
<                     $s4MetricRollupRef->{ "dataUpdaterSuccessCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";
< 
---
>                     $s4MetricRollupRef->{ "dataUpdaterSuccessCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";                     
>                     
1014,1015c927,928
<                     $s4MetricRollupRef->{ "dataUpdaterWorkAverageTime" }->{ "uiHint" } = "AOD DataSync/DataUpdater";
< 
---
>                     $s4MetricRollupRef->{ "dataUpdaterWorkAverageTime" }->{ "uiHint" } = "AOD DataSync/DataUpdater";     
>                     
1020,1021c933,934
<                     $s4MetricRollupRef->{ "dataPushThrottlingQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/DataPush";
< 
---
>                     $s4MetricRollupRef->{ "dataPushThrottlingQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/DataPush";                     
>                     
1027c940
< 
---
>                     
1039c952
< 
---
>                     
1050c963
< 
---
>                     
1053,1055c966,968
<                     $s4MetricRollupRef->{ "changeListErrorCount" }->{ "description" } = "GetChangeList - Number of failed requests";
<                     $s4MetricRollupRef->{ "changeListErrorCount" }->{ "uiHint" } = "AOD DataSync/GetChangeList";
< 
---
>                     $s4MetricRollupRef->{ "changeListErrorCount" }->{ "description" } = "GetChangeList - Number of failed requests";  
>                     $s4MetricRollupRef->{ "changeListErrorCount" }->{ "uiHint" } = "AOD DataSync/GetChangeList";                  
>                     
1060c973
< 
---
>                                    
1063c976
<                     $s4MetricRollupRef->{ "changeListAverageTime" }->{ "description" } = "GetChangeList - Average time for a request";
---
>                     $s4MetricRollupRef->{ "changeListAverageTime" }->{ "description" } = "GetChangeList - Average time for a request";  
1075,1077c988,990
<                     $s4MetricRollupRef->{ "getDataTotalCount" }->{ "description" } = "GetData - Total number request";
<                     $s4MetricRollupRef->{ "getDataTotalCount" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataTotalCount" }->{ "description" } = "GetData - Total number request";   
>                     $s4MetricRollupRef->{ "getDataTotalCount" }->{ "uiHint" } = "AOD DataSync/GetData";                 
>                     
1080,1082c993,995
<                     $s4MetricRollupRef->{ "getDataSuccessCount" }->{ "description" } = "GetData - Number of successful requests";
<                     $s4MetricRollupRef->{ "getDataSuccessCount" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataSuccessCount" }->{ "description" } = "GetData - Number of successful requests";  
>                     $s4MetricRollupRef->{ "getDataSuccessCount" }->{ "uiHint" } = "AOD DataSync/GetData";                      
>                     
1085c998
<                     $s4MetricRollupRef->{ "getDataErrorCount" }->{ "description" } = "GetData - Number of failed requests";
---
>                     $s4MetricRollupRef->{ "getDataErrorCount" }->{ "description" } = "GetData - Number of failed requests";                     
1087c1000
< 
---
>                     
1090,1092c1003,1005
<                     $s4MetricRollupRef->{ "getDataSyncObjCount" }->{ "description" } = "GetData - Number of sync objects";
<                     $s4MetricRollupRef->{ "getDataSyncObjCount" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataSyncObjCount" }->{ "description" } = "GetData - Number of sync objects"; 
>                     $s4MetricRollupRef->{ "getDataSyncObjCount" }->{ "uiHint" } = "AOD DataSync/GetData";                      
>                     
1096,1097c1009,1010
<                     $s4MetricRollupRef->{ "getDataUpdaterCount" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataUpdaterCount" }->{ "uiHint" } = "AOD DataSync/GetData";                   
>                     
1102c1015
< 
---
>                     
1141c1054
< 
---
>                     
1154c1067
< 
---
>                     
1160c1073
< 
---
>                                         
1165c1078
< 
---
>                     
1170,1171c1083,1084
<                     $s4MetricRollupRef->{ "getDataQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/GetData";   
>                                      
1175,1176c1088,1089
<                     $s4MetricRollupRef->{ "getDataThrottlingQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataThrottlingQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/GetData";                      
>                     
1181,1182c1094,1095
<                     $s4MetricRollupRef->{ "dataUpdaterReschedulerQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";
< 
---
>                     $s4MetricRollupRef->{ "dataUpdaterReschedulerQueueBlockedCount" }->{ "uiHint" } = "AOD DataSync/DataUpdater";                    
>                     
1187,1188c1100,1101
<                     $s4MetricRollupRef->{ "changeListQueueBlockedTime" }->{ "uiHint" } = "AOD DataSync/GetChangeList";
< 
---
>                     $s4MetricRollupRef->{ "changeListQueueBlockedTime" }->{ "uiHint" } = "AOD DataSync/GetChangeList";                     
>                     
1193,1194c1106,1107
<                     $s4MetricRollupRef->{ "getDataQueueBlockedTime" }->{ "uiHint" } = "AOD DataSync/GetData";
< 
---
>                     $s4MetricRollupRef->{ "getDataQueueBlockedTime" }->{ "uiHint" } = "AOD DataSync/GetData";                       
>                     
1199c1112
<                     $s4MetricRollupRef->{ "getDataThrottlingQueueBlockedTime" }->{ "uiHint" } = "AOD DataSync/GetData";
---
>                     $s4MetricRollupRef->{ "getDataThrottlingQueueBlockedTime" }->{ "uiHint" } = "AOD DataSync/GetData";  
1206c1119
< 
---
>                     
1209c1122
<                     $s4MetricRollupRef->{ "changeListErrorTime" }->{ "description" } = "GetChangeList - Time of last failed request";
---
>                     $s4MetricRollupRef->{ "changeListErrorTime" }->{ "description" } = "GetChangeList - Time of last failed request";  
1211c1124
< 
---
>                     
1216c1129
<                 }
---
>                 }                    
1234,1236c1147,1149
<             #calculate individual items and rollup
<             push @{ $s4MetricRollupRef->{ $valId }->{ "values" } },
<                 addS4QueriesWithCritAndWarn( \%queries, $valValue, $valName, "$valUIHint/Arches Search",
---
>             #calculate individual items and rollup           
>             push @{ $s4MetricRollupRef->{ $valId }->{ "values" } }, 
>                 addS4QueriesWithCritAndWarn( \%queries, $valValue, $valName, "$valUIHint/Arches Search", 
1243,1244c1156,1157
<             push @{ $s4MetricRollupRef->{ $valId . "Totals" }->{ "values" } },
<                 addS4QueriesWithCritAndWarn( \%queries, $valSumNumbers, $valSumOfNumbersName, "$valUIHint/Arches Search",
---
>             push @{ $s4MetricRollupRef->{ $valId . "Totals" }->{ "values" } }, 
>                 addS4QueriesWithCritAndWarn( \%queries, $valSumNumbers, $valSumOfNumbersName, "$valUIHint/Arches Search", 
1254c1167
< 
---
>             
1258c1171
< 
---
>             
1269c1182
< 
---
>             
1292,1293c1205,1206
<             }
< 
---
>             }                    
>             
1323c1236
<                 }
---
>                 }            
1325c1238
< 
---
>             
1358,1359d1270
<             'inf_field' => 'total_number_active_RFX',
<             'group_by' => 'general',
1374,1375d1284
<                 'inf_field' => 'Total_number_active_large_huge_RFX',
<                 'group_by' => 'general',
1390,1391d1298
<             'inf_field' => 'Total_number_bids_processed',
<             'group_by' => 'general',
1400,1401d1306
<             'inf_field' => 'Total_number_SV_dataload_in_progress',
<             'group_by' => 'general',
1410,1411d1314
<             'inf_field' => 'Total_number_SV_AB_switch_in_progress',
<             'group_by' => 'general',
1421,1422d1323
<                 'inf_field' => 'incoming_request_total',
<                 'group_by' => 'Spot Quote',
1434,1435d1334
<                 'inf_field' => 'incoming_request_failure_total',
<                 'group_by' => 'Spot Quote',
1443,1444d1341
<                 'inf_field' => 'send_quote_total',
<                 'group_by' => 'Spot Quote',
1456,1457d1352
<                 'inf_field' => 'send_quote_failure_total',
<                 'group_by' => 'Spot Quote',
1469,1470d1363
<                 'inf_field' => 'posting_update_total',
<                 'group_by' => 'Spot Quote',
1478,1479d1370
<                 'inf_field' => 'posting_update_failure_total',
<                 'group_by' => 'Spot Quote',
1508,1509d1398
<                 'inf_field' => 'failed_sourcing_or_buyer_shared_star_schema_pulls',
<                 'group_by' => 'general',
1517,1518d1405
<                 'inf_field' => 'running_presentation_loads_on_dedicated_schema',
<                 'group_by' => 'general',
1525,1526d1411
<                 'inf_field' => 'runing_presentation_loads_on_shared_schema',
<                 'group_by' => 'general',
1528,1535c1413,1420
<             for my $schemaId (keys %schemaStats) {
<                 my %stats = %{$schemaStats{$schemaId}};
<                 for my $field (keys %stats) {
<                     my $value = $stats{$field};
<                     my $queryName = $schemaStatFields{$field}->{'queryName'};
<                     my $warn = $schemaStatFields{$field}->{'warn'};
<                     my $crit = $schemaStatFields{$field}->{'crit'};
<                     my $uiHint = $schemaStatFields{$field}->{'uiHint'} || "Schema Stat";
---
>             for my $schemaId (keys %schemaStats) { 
>                 my %stats = %{$schemaStats{$schemaId}}; 
>                 for my $field (keys %stats) { 
>                     my $value = $stats{$field}; 
>                     my $queryName = $schemaStatFields{$field}->{'queryName'}; 
>                     my $warn = $schemaStatFields{$field}->{'warn'}; 
>                     my $crit = $schemaStatFields{$field}->{'crit'}; 
>                     my $uiHint = $schemaStatFields{$field}->{'uiHint'} || "Schema Stat"; 
1540c1425
<                     if ($estimate) {
---
>                     if ($estimate) {  
1543,1544c1428
<                     }
< 
---
>                     }  
1551,1552c1435,1436
<                         'crit' => $crit,
<                         'uiHint' => "$uiHint/Schema $schemaId",
---
>                         'crit' => $crit, 
>                         'uiHint' => "$uiHint/Schema $schemaId",  
1556,1558d1439
<                         'inf_field' => 'value',
<                         'inf_tags' => qq|schemaId=$schemaId,description="$queryName"|,
<                         'group_by' => qq|schemaId=$schemaId,description="$queryName"|,
1572,1573d1452
<             'inf_field' => 'active_presentation_load',
<             'group_by' => 'general',
1582,1583d1460
<             'inf_field' => 'active_SV_loads',
<             'group_by' => 'general',
1586,1588c1463
<         my %sql_queries;
< 
<         $sql_queries{"Realms with delayed loaddb in progress"} = {
---
>         $queries{"Realms with delayed loaddb in progress"} = {
1594,1595c1469
<             'sql' => "select name as realm_name from realmtab where state = 'loading'",
<             'inf_tags' => 'state_description="Realms with delayed loaddb in progress",state="loading"',
---
>             'sql' => "select name from realmtab where state = 'loading'",
1598c1472
<         $sql_queries{"Realms in error state"} = {
---
>         $queries{"Realms in error state"} = {
1606,1607c1480
<             'sql' => "select name as realm_name, id as id, TimeStateChanged as state_change_time from realmtab where state = 'loadingError'",
<             'inf_tags' => 'state_description="Realms in error state",state="loadingError"',
---
>             'sql' => "select name, state, TimeStateChanged from realmtab where state = 'loadingError'",
1610c1483
<         $sql_queries{"Realms in enablement error state"} = {
---
>         $queries{"Realms in enablement error state"} = {
1617,1628c1490
<             'sql' => "select name as realm_name,  id as id, TimeStateChanged as state_change_time from realmtab where state = 'enablementError'",
<             'inf_tags' => qq|state_description="Realms in enablement error state",state="enablementError"|,
<         };
<         $sql_queries{"Realms in enablement error state count"} = {
<             'recordMaxResults' => 110000,
<             'recordDataType' => "gauge",
<             'recordItem' => 'numrows',
<             'info' => 1,
<             'skip' => $skip,
<             'crit' => "numrows > 0",
<             'sql' => "select count(1) as realm_enablementError_count from realmtab where state = 'enablementError'",
<             'inf_tags' => qq|state_description="Realms in enablement error state count",state="enablementError"|,
---
>             'sql' => "select name, state, TimeStateChanged from realmtab where state = 'enablementError'",
1631c1493
<         $sql_queries{"Delayed loaddb stuck for more than $hours hrs"} = {
---
>         $queries{"Delayed loaddb stuck for more than $hours hrs"} = {
1636,1645c1498
<             'sql' => "SELECT sts_PartitionName as PartitionName FROM ScheduledTaskStatusTab WHERE sts_TaskName = 'LateLoadDBTask'  AND sts_StartTime IS NOT NULL  AND sts_EndTime IS NULL  AND sts_Active = 1 AND sts_PurgeState = 0 AND (sysdate - sts_TimeUpdated)*24 > $hours ORDER BY sts_TimeCreated ASC",
<             'inf_tags' => qq|state_description="Delayed loaddb stuck for more than $hours hrs",state=stuck|,
<         };
<         $sql_queries{"Delayed loaddb stuck for more than $hours hrs count"} = {
<             'info' => 1,
<             'warn' => "numrows > 0",
<             'crit' => "numrows > 3",
<             'skip' => $skip,
<             'sql' => "SELECT count(1) as sts_PartitionName_count FROM ScheduledTaskStatusTab WHERE sts_TaskName = 'LateLoadDBTask'  AND sts_StartTime IS NOT NULL  AND sts_EndTime IS NULL  AND sts_Active = 1 AND sts_PurgeState = 0 AND (sysdate - sts_TimeUpdated)*24 > $hours ORDER BY sts_TimeCreated ASC",
<             'inf_tags' => qq|state_description="Delayed loaddb stuck for more than $hours hrs count",state=stuck|,
---
>             'sql' => "SELECT sts_PartitionName FROM ScheduledTaskStatusTab WHERE sts_TaskName = 'LateLoadDBTask'  AND sts_StartTime IS NOT NULL  AND sts_EndTime IS NULL  AND sts_Active = 1 AND sts_PurgeState = 0 AND (sysdate - sts_TimeUpdated)*24 > $hours ORDER BY sts_TimeCreated ASC",
1648,1649d1500
<         my (%general_queries,%spot_quote_queries,%data_load_queries);
<         extract_queries(\%queries,\%general_queries,\%spot_quote_queries,\%data_load_queries);
1653d1503
<         $queries{"influx_details"} = {measurement => "s4_current_activity"};
1659,1710c1509
<         $q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         $sql_queries{"influx_details"} = {measurement => "s4_realms_state"};
<         my $sql_q = ariba::monitor::QueryManager->newWithDetails(
<                 "current-activity", $product->name(), $service, $product->customer(), \%sql_queries
<                 );
<         $sql_q->setSQLConnectInfo($product->connectInfoForOracleClient());
<         $sql_q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         $general_queries{"influx_details"} = {measurement => "s4_general_current_activity"};
<         my $general_q = ariba::monitor::QueryManager->newWithDetails(
<                 "current-activity", $product->name(), $service, $product->customer(), \%general_queries
<                 );
<         $general_q->setSQLConnectInfo($product->connectInfoForOracleClient());
<         $general_q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         $spot_quote_queries{"influx_details"} = {measurement => "s4_spot_quote_current_activity"};
<         my $sq_q = ariba::monitor::QueryManager->newWithDetails(
<                 "current-activity", $product->name(), $service, $product->customer(), \%spot_quote_queries
<                 );
<         $sq_q->setSQLConnectInfo($product->connectInfoForOracleClient());
<         $sq_q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<         $data_load_queries{"influx_details"} = {measurement => "s4_data_load_current_activity"};
<         my $dl_q = ariba::monitor::QueryManager->newWithDetails(
<                 "current-activity", $product->name(), $service, $product->customer(), \%data_load_queries
<                 );
<         $dl_q->setSQLConnectInfo($product->connectInfoForOracleClient());
<         $dl_q->processQueries($debug, $email, $sendEmail, $sendPage);
< 
<     }
< }
< 
< sub extract_queries {
<     my $queries = shift;
<     my $general_queries = shift;
<     my $spot_quote_queries = shift;
<     my $data_load_queries = shift;
<     foreach my $k (keys %$queries){
<         if ($queries->{$k}->{group_by} eq 'general'){
<             $general_queries->{$k} = $queries->{$k};
<             delete $queries->{$k};
<         } elsif ($queries->{$k}->{group_by} eq 'Spot Quote') {
<             $spot_quote_queries->{$k} = $queries->{$k};
<             $spot_quote_queries->{$k}->{inf_default} = 0;
<             delete $queries->{$k};
<         } elsif ($queries->{$k}->{uiHint} =~ /Data Load/){
<             $data_load_queries->{$k} = $queries->{$k};
<             delete $queries->{$k};
<         } else {
<             $queries->{$k}->{inf_default} = 0;
<         }
---
>         $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage);
1716a1516
>     
1733c1533
< 
---
>     
filename:./lib/ariba/Automation/CleanAction.pm
5d4
< 
82a82,88
>       my $personalServiceSQLLogs = join "/",
>                 "/var",
>                 "tmp",
>                 $productName,
>                 ariba::rc::Globals::personalServicePrefix() . $ENV{'USER'},
>                 "application";
> 
92a99
>                 $personalServiceSQLLogs,
104c111,112
< 		$days,
---
>                 $days,  
> 		0, #delete all the SQL Collector logs before the run starts.
108d115
< 
111a119
> 		$logger->info("$logPrefix Cleaning logs dir : $logdir older than $expire days");
113c121
< 		my $cleanLogsCmd = "$cleaner -d $days $logdir";
---
> 		my $cleanLogsCmd = "$cleaner -d $expire $logdir";
filename:./lib/ariba/DBA/SampleSQLQueries.pm
3c3
< # $Id: //ariba/services/monitor/lib/ariba/DBA/SampleSQLQueries.pm#26 $
---
> # $Id: //ariba/services/monitor/lib/ariba/DBA/SampleSQLQueries.pm#27 $
65,66c65,67
<         checkBackupMode => q`select t.tablespace_name, b.status from dba_data_files t, 
<                             v$backup b where file_id = file#`,
---
>         checkBackupMode => q`select distinct t.tablespace_name, b.status from dba_data_files t,
>                             v$backup b ,dba_tablespaces tb where file_id = file# 
>                             and t.tablespace_name=tb.tablespace_name and tb.STATUS != 'READ ONLY'`,
filename:./lib/ariba/HTTPWatcherPlugin/Community.pm
1c1
< # $Id: //ariba/services/monitor/lib/ariba/HTTPWatcherPlugin/Community.pm#17 $
---
> # $Id: //ariba/services/monitor/lib/ariba/HTTPWatcherPlugin/Community.pm#18 $
73c73
<         'http://connect.ariba.com/XML_Export/1,,Modified_IDs,00.xml?Count=1',
---
>         'https://support.ariba.com/XML_Export/Modified_IDs?Count=1',
filename:./lib/ariba/Ops/CFEngine/MonitoringGlueUtils.pm
3c3
< # $Id: //ariba/services/tools/lib/perl/ariba/Ops/CFEngine/MonitoringGlueUtils.pm#6 $
---
> # $Id: //ariba/services/tools/lib/perl/ariba/Ops/CFEngine/MonitoringGlueUtils.pm#7 $
13a14,19
> # These globals are used to store results and speed up subsequent calls.
> my @monServerList;
> my @monMarkedServerList;
> my $currentDc;
> my $checkedForMarkedServers;
> 
17a24,43
> # Input: a hosts's name
> # Output: array of all service names that run in the same datacenter for the host
> sub allMonitoringServers {
>     my $host = shift || ariba::Ops::NetworkUtils::hostname();
> 
>     my $machine = ariba::Ops::Machine->new($host);
>     my $datacenter = $machine->monitoringDatacenter() || $machine->datacenter();
>     if ( !@monServerList || ( $currentDc ne $datacenter )) {
>         $currentDc = $datacenter;
>         my %match = (
>                 datacenter  => $datacenter,
>                 providesServices => 'mon',
>                 status => 'inservice',
>         );
>         @monServerList = ariba::Ops::Machine->machinesWithProperties(%match);
>     }
> 
>     return @monServerList;
> }
> 
42,46c68,78
< 	my %match = (
< 		datacenter  => $monitoringDatacenter,
< 		providesServices => 'mon',
< 		status => 'inservice',
< 		monserverForDatacenter => 1,
---
> 	my @monitoringServers;
>     if ( @monMarkedServerList && ( $monitoringDatacenter eq $currentDc )) {
>         # If we created @monMarkedServerList on a previous pass and the datacenter is the same, just return it.
>         @monitoringServers = @monMarkedServerList;
>     }
>     elsif ( !$checkedForMarkedServers ) {
>         my %match = (
>             datacenter  => $monitoringDatacenter,
>             providesServices => 'mon',
>             status => 'inservice',
>             monserverForDatacenter => 1,
48,56c80,84
< 	my @monitoringServers = ariba::Ops::Machine->machinesWithProperties(%match);
< 	unless (@monitoringServers) {
< 		%match = (
< 				datacenter  => $monitoringDatacenter,
< 				providesServices => 'mon',
< 				status => 'inservice',
< 			    );
< 		@monitoringServers = ariba::Ops::Machine->machinesWithProperties(%match);
< 	}
---
> 	    @monitoringServers = @monMarkedServerList = ariba::Ops::Machine->machinesWithProperties(%match);
>         $currentDc = $monitoringDatacenter;
>         $checkedForMarkedServers = 1;
>     }
>     @monitoringServers = allMonitoringServers( $host ) unless @monitoringServers;
70a99,120
> # Input: a service name
> # Output: the host name of the monitoring server for the service
> sub monitoringServerForService {
>     my $service = shift;
> 
>     my @allMonServers = allMonitoringServers();
> 
>     my $monserver;
>     # First try to match $service to $opsService within a machinedb file.
>     foreach my $server ( @allMonServers ) {
>         my $opsService = $server->opsService();
>         if ( $opsService && $opsService eq $service ) {
>             $monserver = $server->hostname();
>             last;
>         }
>     } 
> 
>     # Otherwise use the old math
>     $monserver = monitorServer() unless ( $monserver );
> 
>     return $monserver;
> }
filename:./lib/ariba/Ops/CFEngine/PackageHelper.pm
3c3
< # $Id: //ariba/services/tools/lib/perl/ariba/Ops/CFEngine/PackageHelper.pm#26 $
---
> # $Id: //ariba/services/tools/lib/perl/ariba/Ops/CFEngine/PackageHelper.pm#27 $
31a32
> 		'installkernel' => '/bin/rpm -ivh %s %s',
74a76,77
>         my $kernel_regex = qr'kernel\-((large)?smp-)?[0-9]';
> 
79c82
< 		if ( defined($installedRpm) && ( $installedRpm ne '' and $installedRpm !~ /^kernel\-(large)?smp-[0-9]|^rpm\-[0-9]|^bash-/ and rpmHasUninstallScripts($installedRpm) ) ) {
---
> 		if ( defined($installedRpm) && ( $installedRpm ne '' and $installedRpm !~ /^$kernel_regex|^rpm\-[0-9]|^bash-/ and rpmHasUninstallScripts($installedRpm) ) ) {
91,92c94,99
< 
< 	my $ret = runPackageCommand('install', $file);
---
>         my $ret;
>         if ($file =~ /$kernel_regex/i) {
>            $ret = runPackageCommand('installkernel', $file);
>         } else {
>            $ret = runPackageCommand('install', $file);
>         }
filename:./lib/ariba/Ops/DatabasePeers.pm
1a2,3
> # vi:et ts=4 sw=4
> 
144c146
<         $methodsRef->{'primary'} = undef;
---
>         $methodsRef->{'primary'}   = undef;
146,148c148,151
<         $methodsRef->{'sid'} = undef;
<         $methodsRef->{'type'} = undef;
<         $methodsRef->{'debug'} = undef;
---
>         $methodsRef->{'sid'}       = undef;
>         $methodsRef->{'type'}      = undef;
>         $methodsRef->{'debug'}     = undef;
>         $methodsRef->{'adminID'}   = undef;
206,210c209
< 	my $includeHana = $product->default('Ops.IncludeHanaDatabaseInPeers');
< 	unless($includeHana) {
< 		@dbConnections = grep { $_->dbServerType() ne 'hana' } @dbConnections;
< 	}
< 
---
> 	my $isHana = $dbc0->isHana; # dbc peers should always be of the same db type
218c217
<     my $onlySid = $optionsRef->{'sid'};
---
> 	my $onlySid = $optionsRef->{'sid'};
223c222,229
< 	my @uniqueDbcs = ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbConnections);
---
> 	my @uniqueDbcs;
> 	if($isHana) {
> 		# hana dbc's are unique by host and port
> 		@uniqueDbcs = ariba::Ops::DBConnection->uniqueConnectionsByHostAndPort(@dbConnections);
> 	}
> 	else {
> 		@uniqueDbcs = ariba::Ops::DBConnection->uniqueConnectionsByHostAndSid(@dbConnections);
> 	}
256,257c262
< #			if($dbc->dbServerType() eq 'hana') {
< 			if($dbc->host() =~ /hana/) {
---
> 			if($dbc->isHana) {
273a279
>                 $self->setAdminID($dbPeer->adminID) if $dbc->isHana; # HOA-163618: adminID only valid for hana type
filename:./lib/ariba/Ops/MCL/Step.pm
4a5
> use Data::Dumper;
11c12
< 	my $self = shift;
---
>         my $self = shift;
13,42c14,43
< 	my $name = $self->name();
< 	my $title = $self->title();
< 	my $depends = join(" ", $self->depends());
< 	my $expando = $self->expando();
< 	my $group = $self->runGroup();
< 	my $retries = $self->retries();
< 	my $retryInt = $self->retryInterval();
< 	my $options;
< 	my @opts;
< 	push(@opts, "Optional") if($self->status() eq 'Optional');
< 	push(@opts, "Rerun") if($self->rerunOnRestart());
< 	push(@opts, "ContinueOnError") if($self->continueOnError());
< 	push(@opts, "NoInherit") if($self->noinherit());
< 	$options = join(',',@opts) if(scalar(@opts));
< 	my $other;
< 	my @oth;
< 	foreach my $sv ($self->storedVariables()) {
< 		push(@oth, "Store: " . $sv);
< 	}
< 	push(@oth, "StoreSuccess: " . $self->storeSuccess()) if($self->storeSuccess());
< 	push(@oth, "ExecuteIf: " . $self->executeIf()) if($self->executeIf());
< 	push(@oth, "ExecuteUnless: " . $self->executeUnless()) if($self->executeUnless());
< 	push(@oth, "AlertTimeout: " . $self->alertTime()) if($self->alertTime());
< 	$other = join("\n", @oth) . "\n" if(scalar(@oth));
< 
< 	my $ret = defineStep($name, $title, $depends, $expando, $group, $options, $retries, $retryInt, $other);
< 
< 	foreach my $action ($self->actions()) {
< 		$ret .= $action->definition();
< 	}
---
>         my $name = $self->name();
>         my $title = $self->title();
>         my $depends = join(" ", $self->depends());
>         my $expando = $self->expando();
>         my $group = $self->runGroup();
>         my $retries = $self->retries();
>         my $retryInt = $self->retryInterval();
>         my $options;
>         my @opts;
>         push(@opts, "Optional") if($self->status() eq 'Optional');
>         push(@opts, "Rerun") if($self->rerunOnRestart());
>         push(@opts, "ContinueOnError") if($self->continueOnError());
>         push(@opts, "NoInherit") if($self->noinherit());
>         $options = join(',',@opts) if(scalar(@opts));
>         my $other;
>         my @oth;
>         foreach my $sv ($self->storedVariables()) {
>                 push(@oth, "Store: " . $sv);
>         }
>         push(@oth, "StoreSuccess: " . $self->storeSuccess()) if($self->storeSuccess());
>         push(@oth, "ExecuteIf: " . $self->executeIf()) if($self->executeIf());
>         push(@oth, "ExecuteUnless: " . $self->executeUnless()) if($self->executeUnless());
>         push(@oth, "AlertTimeout: " . $self->alertTime()) if($self->alertTime());
>         $other = join("\n", @oth) . "\n" if(scalar(@oth));
> 
>         my $ret = defineStep($name, $title, $depends, $expando, $group, $options, $retries, $retryInt, $other);
> 
>         foreach my $action ($self->actions()) {
>                 $ret .= $action->definition();
>         }
44c45
< 	return($ret);
---
>         return($ret);
48,49c49,50
< 	my $self = shift;
< 	my $info = shift;
---
>         my $self = shift;
>         my $info = shift;
51,58c52,59
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 	my $dir = $mcl->messagedir();
< 	my $file = "$dir/message-" . $self->name() . "-" . time();
< 
< 	my $FH;
< 	open($FH, "> $file");
< 	print $FH $self->name() . ":" . "$info\n";
< 	close($FH);
---
>         my $mcl = ariba::Ops::MCL->currentMclObject();
>         my $dir = $mcl->messagedir();
>         my $file = "$dir/message-" . $self->name() . "-" . time();
> 
>         my $FH;
>         open($FH, "> $file");
>         print $FH $self->name() . ":" . "$info\n";
>         close($FH);
62c63
< 	my $class = shift;
---
>         my $class = shift;
64,65c65,66
< 	my $ref = $class->SUPER::validAccessorMethods();
< 	my @accessors = qw( actions alerted alertTime continueOnError depends endTime executeIf executeUnless expando folderStatus isExpandoParent logfile mcl name noinherit num output parentStep retries retryInterval runGroup startTime status storeSuccess storedVariables title logdata logtime remoteLogdata remoteLogtime rerunOnRestart metaInfo );
---
>         my $ref = $class->SUPER::validAccessorMethods();
>         my @accessors = qw( actions alerted alertTime continueOnError depends endTime executeIf executeUnless expando folderStatus isExpandoParent logfile mcl name noinherit num output parentStep retries retryInterval runGroup startTime status storeSuccess storedVariables title logdata logtime remoteLogdata remoteLogtime rerunOnRestart metaInfo );
67,69c68,70
< 	foreach my $accessor (@accessors) {
< 		$ref->{$accessor} = 1;
< 	}
---
>         foreach my $accessor (@accessors) {
>                 $ref->{$accessor} = 1;
>         }
71c72
< 	return($ref);
---
>         return($ref);
75c76
< 	my $self = shift;
---
>         my $self = shift;
77,83c78,84
< 	if($self->isExpandoParent()) {
< 		return($self->attribute('status')) if($self->attribute('status'));
< 		$self->setStatus($self->expandoStatus()); # cache "Not Started" too
< 		return($self->attribute('status'));
< 	} else {
< 		return($self->attribute('status'));
< 	}
---
>         if($self->isExpandoParent()) {
>                 return($self->attribute('status')) if($self->attribute('status'));
>                 $self->setStatus($self->expandoStatus()); # cache "Not Started" too
>                 return($self->attribute('status'));
>         } else {
>                 return($self->attribute('status'));
>         }
87,113c88,114
< 	my $self = shift;
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 	my %status;
< 	my $completed = 1;
< 	my $started = 0;
< 
< 	return("No MCL") unless($mcl);
< 
< 	my @steps = $mcl->stepsForExpando($self->name());
< 
< 	foreach my $child ($mcl->steps()) {
< 		next unless($child->expando() eq $self->name());
< 		my $childStatus = $child->status() || "";
< 		$status{ $childStatus } = 1;
< 		$completed = 0 if($completed && $childStatus ne 'Completed' && $childStatus ne 'Error OK' && $childStatus ne 'Skipped');
< 		$started = 1 if(!$started && $childStatus && $childStatus ne 'Not Started' && $childStatus ne 'Optional');
< 	}
< 
< 	return('Completed') if($completed);
< 
< 	return('Failed') if($status{'Failed'});
< 	return('Crashed') if($status{'Crashed'});
< 	return('Confused') if($status{'Confused'});
< 	return('Waiting') if($status{'Waiting'});
< 	return('Running') if($status{'Running'} || $started);
< 	return('Optional') if($status{'Optional'});
< 	return('Not Started');
---
>         my $self = shift;
>         my $mcl = ariba::Ops::MCL->currentMclObject();
>         my %status;
>         my $completed = 1;
>         my $started = 0;
> 
>         return("No MCL") unless($mcl);
> 
>         my @steps = $mcl->stepsForExpando($self->name());
> 
>         foreach my $child ($mcl->steps()) {
>                 next unless($child->expando() eq $self->name());
>                 my $childStatus = $child->status() || "";
>                 $status{ $childStatus } = 1;
>                 $completed = 0 if($completed && $childStatus ne 'Completed' && $childStatus ne 'Error OK' && $childStatus ne 'Skipped');
>                 $started = 1 if(!$started && $childStatus && $childStatus ne 'Not Started' && $childStatus ne 'Optional');
>         }
> 
>         return('Completed') if($completed);
> 
>         return('Failed') if($status{'Failed'});
>         return('Crashed') if($status{'Crashed'});
>         return('Confused') if($status{'Confused'});
>         return('Waiting') if($status{'Waiting'});
>         return('Running') if($status{'Running'} || $started);
>         return('Optional') if($status{'Optional'});
>         return('Not Started');
117,119c118,120
< 	my $self = shift;
< 	return 1 if($self->status() eq 'Optional');
< 	return 0;
---
>         my $self = shift;
>         return 1 if($self->status() eq 'Optional');
>         return 0;
123,128c124,129
< 	my $self = shift;
< 	return 1 if($self->status() eq 'Completed');
< 	return 1 if($self->status() eq 'Error OK');
< 	return 1 if($self->status() eq 'Skipped');
< 	return 1 if($self->status() eq 'Optional');
< 	return 0;
---
>         my $self = shift;
>         return 1 if($self->status() eq 'Completed');
>         return 1 if($self->status() eq 'Error OK');
>         return 1 if($self->status() eq 'Skipped');
>         return 1 if($self->status() eq 'Optional');
>         return 0;
132,136c133,137
< 	my $self = shift;
< 	return 1 if($self->status() eq 'Failed');
< 	return 1 if($self->status() eq 'Crashed');
< 	return 1 if($self->status() eq 'Confused');
< 	return 0;
---
>         my $self = shift;
>         return 1 if($self->status() eq 'Failed');
>         return 1 if($self->status() eq 'Crashed');
>         return 1 if($self->status() eq 'Confused');
>         return 0;
140,142c141,143
< 	my $self = shift;
< 	return 1 if($self->status() eq 'Waiting');
< 	return 0;
---
>         my $self = shift;
>         return 1 if($self->status() eq 'Waiting');
>         return 0;
146,148c147,149
< 	my $self = shift;
< 	return 1 if($self->status() eq 'Running');
< 	return 0;
---
>         my $self = shift;
>         return 1 if($self->status() eq 'Running');
>         return 0;
152,155c153,156
< 	my $self = shift;
< 	return 1 if($self->status eq 'Failed Rollback');
< 	return 1 if($self->status eq 'Rollback Attempted');
< 	return 0;
---
>         my $self = shift;
>         return 1 if($self->status eq 'Failed Rollback');
>         return 1 if($self->status eq 'Rollback Attempted');
>         return 0;
159,176c160,161
< 	my $self = shift;
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
<     
< 	$self->SUPER::setStatus(@_);
< 
< 	#
< 	# this can get called during initial loadMCL before currentMclObject
< 	# is set.  this is an optimization for run time tho, so we just skip
< 	# during initialization.
< 	#
< 	if($mcl) {
< 		if($self->expando()) {
< 			my $ex = $mcl->stepForName($self->expando());
< 			if($ex) {
< 				$ex->setAttribute('status', $ex->expandoStatus());
< 			}
< 		}
< 	}
---
>         my $self = shift;
>         my $mcl = ariba::Ops::MCL->currentMclObject();
178c163,179
< 	$self->save();
---
>         $self->SUPER::setStatus(@_);
> 
>         #
>         # this can get called during initial loadMCL before currentMclObject
>         # is set.  this is an optimization for run time tho, so we just skip
>         # during initialization.
>         #
>         if($mcl) {
>                 if($self->expando()) {
>                         my $ex = $mcl->stepForName($self->expando());
>                         if($ex) {
>                                 $ex->setAttribute('status', $ex->expandoStatus());
>                         }
>                 }
>         }
> 
>         $self->save();
182c183
< 	my $self = shift;
---
>         my $self = shift;
184,185c185,186
< 	my $file = $self->SUPER::logfile() || $self->nextLogfile();
< 	return($file);
---
>         my $file = $self->SUPER::logfile() || $self->nextLogfile();
>         return($file);
189,200c190,201
< 	my $self = shift;
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 	my $dir = $mcl->logdir();
< 	my $basefile = "$dir/Step-" . $self->name() . ".log";
< 	my $file;
< 	my $c = 0;
< 
< 	while(1) {
< 		$file = $basefile . ".$c";
< 		last unless( -e $file );
< 		$c++;
< 	}
---
>         my $self = shift;
>         my $mcl = ariba::Ops::MCL->currentMclObject();
>         my $dir = $mcl->logdir();
>         my $basefile = "$dir/Step-" . $self->name() . ".log";
>         my $file;
>         my $c = 0;
> 
>         while(1) {
>                 $file = $basefile . ".$c";
>                 last unless( -e $file );
>                 $c++;
>         }
202,203c203,204
< 	$self->setLogfile($file);
< 	return($file);
---
>         $self->setLogfile($file);
>         return($file);
207,220c208,221
< 	my $self = shift;
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 	my $dir = $mcl->logdir();
< 	my $basefile = "$dir/Step-" . $self->name() . ".log";
< 	my $file;
< 	my $c = 0;
< 	my @ret;
< 
< 	while(1) {
< 		$file = $basefile . ".$c";
< 		last unless( -e $file );
< 		push(@ret, $file);
< 		$c++;
< 	}
---
>         my $self = shift;
>         my $mcl = ariba::Ops::MCL->currentMclObject();
>         my $dir = $mcl->logdir();
>         my $basefile = "$dir/Step-" . $self->name() . ".log";
>         my $file;
>         my $c = 0;
>         my @ret;
> 
>         while(1) {
>                 $file = $basefile . ".$c";
>                 last unless( -e $file );
>                 push(@ret, $file);
>                 $c++;
>         }
222c223
< 	return(@ret);
---
>         return(@ret);
226c227
< 	return('/var/mcl');
---
>         return('/var/mcl');
230,231c231,232
< 	my $self = shift;
< 	my $number = shift;
---
>         my $self = shift;
>         my $number = shift;
233,235c234,236
< 	foreach my $a ($self->actions()) {
< 		return($a) if($a->actionNumber() eq $number);
< 	}
---
>         foreach my $a ($self->actions()) {
>                 return($a) if($a->actionNumber() eq $number);
>         }
237c238
< 	return undef;
---
>         return undef;
241,242c242,243
< 	my $class = shift;
< 	my $instance = shift;
---
>         my $class = shift;
>         my $instance = shift;
244,247c245,248
< 	my ($mclname, $stepname, $rollback) = split(/\-\-/, $instance);
< 	$stepname .= "--rollback" if($rollback);
< 	my $store = "/var/mcl/$mclname/steps/$stepname";
< 	return($store);
---
>         my ($mclname, $stepname, $rollback) = split(/\-\-/, $instance);
>         $stepname .= "--rollback" if($rollback);
>         my $store = "/var/mcl/$mclname/steps/$stepname";
>         return($store);
251c252
< 	my $class = shift;
---
>         my $class = shift;
253c254
< 	my $map = $class->SUPER::objectLoadMap();
---
>         my $map = $class->SUPER::objectLoadMap();
255,257c256,258
< 	$map->{'actions'} = '@ariba::Ops::MCL::BaseAction';
< 	$map->{'storedVariables'} = '@SCALAR';
< 	$map->{'depends'} = '@SCALAR';
---
>         $map->{'actions'} = '@ariba::Ops::MCL::BaseAction';
>         $map->{'storedVariables'} = '@SCALAR';
>         $map->{'depends'} = '@SCALAR';
259c260
< 	return($map);
---
>         return($map);
263c264
< 	my $self = shift;
---
>         my $self = shift;
265,276c266,277
< 	return($self->attribute('output')) if($self->attribute('output'));
< 	my $output="";
< 	foreach my $action ($self->actions()) {
< 		if($action->header()) {
< 			$output .= $action->header() . "\n\n";
< 		}
< 		$output .= $action->output();
< 		chomp($output);
< 		$output .= "\n";
< 	}
< 	$self->setOutput($output);
< 	return($output);
---
>         return($self->attribute('output')) if($self->attribute('output'));
>         my $output="";
>         foreach my $action ($self->actions()) {
>                 if($action->header()) {
>                         $output .= $action->header() . "\n\n";
>                 }
>                 $output .= $action->output();
>                 chomp($output);
>                 $output .= "\n";
>         }
>         $self->setOutput($output);
>         return($output);
280,317c281,318
< 	my $self = shift;
< 	my $data = "";
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 
< 	unless($self->isRunning()) {
< 		$self->setRemoteLogdata(undef);
< 		$self->setRemoteLogtime(undef);
< 		return(undef);
< 	}
< 
< 	if($self->attribute('remoteLogdata')) {
< 		if($self->remoteLogtime() + 1 > time()) {
< 			return($self->attribute('remoteLogdata'));
< 		}
< 	}
< 
< 	foreach my $action ($self->actions()) {
< 		if(my $remoteType = $action->isRemote()) {
< 			my $step = $action->step();
< 			my $actionNumber = $action->actionNumber();
< 			my $file = $mcl->logdir() . "/main.remote-${step}-${actionNumber}.log";
< 			my $IN;
< 			open($IN, "< $file");
< 			my @input = <$IN>;
< 			close($IN);
< 
< 			$data .= "\n" if($data);
< 			$data .= join("", "==== main.remote-${step}-${actionNumber}.log ====\n", @input);
< 		}
< 	}
< 
< 	unless($data) {
< 		return(undef);
< 	}
< 
< 	$self->setRemoteLogdata($data);
< 	$self->setRemoteLogtime(time());
< 	return($data);
---
>         my $self = shift;
>         my $data = "";
>         my $mcl = ariba::Ops::MCL->currentMclObject();
> 
>         unless($self->isRunning()) {
>                 $self->setRemoteLogdata(undef);
>                 $self->setRemoteLogtime(undef);
>                 return(undef);
>         }
> 
>         if($self->attribute('remoteLogdata')) {
>                 if($self->remoteLogtime() + 1 > time()) {
>                         return($self->attribute('remoteLogdata'));
>                 }
>         }
> 
>         foreach my $action ($self->actions()) {
>                 if(my $remoteType = $action->isRemote()) {
>                         my $step = $action->step();
>                         my $actionNumber = $action->actionNumber();
>                         my $file = $mcl->logdir() . "/main.remote-${step}-${actionNumber}.log";
>                         my $IN;
>                         open($IN, "< $file");
>                         my @input = <$IN>;
>                         close($IN);
> 
>                         $data .= "\n" if($data);
>                         $data .= join("", "==== main.remote-${step}-${actionNumber}.log ====\n", @input);
>                 }
>         }
> 
>         unless($data) {
>                 return(undef);
>         }
> 
>         $self->setRemoteLogdata($data);
>         $self->setRemoteLogtime(time());
>         return($data);
321,322c322,323
< 	my $self = shift;
< 	my $ret = 0;
---
>         my $self = shift;
>         my $ret = 0;
324,327c325,328
< 	foreach my $action ($self->actions()) {
< 		my $try = $action->isRemote();
< 		$ret = $try if($try > $ret);
< 	}
---
>         foreach my $action ($self->actions()) {
>                 my $try = $action->isRemote();
>                 $ret = $try if($try > $ret);
>         }
329c330
< 	return($ret);
---
>         return($ret);
333,334c334,335
< 	my $self = shift;
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
---
>         my $self = shift;
>         my $mcl = ariba::Ops::MCL->currentMclObject();
336,338c337,339
< 	foreach my $action($self->actions()) {
< 		my $host = $action->host();
< 		my $user = $action->user();
---
>         foreach my $action($self->actions()) {
>                 my $host = $action->host();
>                 my $user = $action->user();
340,368c341,369
< 		my $password = ariba::rc::Passwords::lookup( $user );
< 		my $mclctl = $FindBin::Bin . "/" . basename($0);
< 		unless( $mclctl =~ /mcl-control/ && -e $mclctl ) {
< 			$mclctl = "/usr/local/ariba/bin/mcl-control";
< 		}
< 		my $step = $action->step();
< 		my $actionNumber = $action->actionNumber();
< 			
< 		my $command = "ssh -l $user $host $mclctl logdata -mcl " . $action->mcl() . " -step $step -action $actionNumber -dir /tmp -started " . $self->startTime();
< 
< 		my @input;
< 		my $ret = ariba::rc::Utils::executeRemoteCommand(
< 			$command,
< 			$password,
< 			0,
< 			undef,
< 			undef,
< 			\@input
< 		);
< 
< 		my $data = join("\n", @input, "");
< 		next unless($data);
< 		my $file = $mcl->logdir() . "/main.remote-${step}-${actionNumber}.log";
< 
< 		my $IN;
< 		open($IN, "> $file");
< 		print $IN $data;
< 		close($IN);
< 	}
---
>                 my $password = ariba::rc::Passwords::lookup( $user );
>                 my $mclctl = $FindBin::Bin . "/" . basename($0);
>                 unless( $mclctl =~ /mcl-control/ && -e $mclctl ) {
>                         $mclctl = "/usr/local/ariba/bin/mcl-control";
>                 }
>                 my $step = $action->step();
>                 my $actionNumber = $action->actionNumber();
> 
>                 my $command = "ssh -l $user $host $mclctl logdata -mcl " . $action->mcl() . " -step $step -action $actionNumber -dir /tmp -started " . $self->startTime();
> 
>                 my @input;
>                 my $ret = ariba::rc::Utils::executeRemoteCommand(
>                         $command,
>                         $password,
>                         0,
>                         undef,
>                         undef,
>                         \@input
>                 );
> 
>                 my $data = join("\n", @input, "");
>                 next unless($data);
>                 my $file = $mcl->logdir() . "/main.remote-${step}-${actionNumber}.log";
> 
>                 my $IN;
>                 open($IN, "> $file");
>                 print $IN $data;
>                 close($IN);
>         }
372c373
< 	my $self = shift;
---
>         my $self = shift;
374,402c375,403
< 	if($self->attribute('logdata')) {
< 		if(!$self->isRunning() && $self->logtime() > $self->endTime()) {
< 			return($self->attribute('logdata'));
< 		}
< 		if($self->logtime() + 1 > time()) {
< 			return($self->attribute('logdata'));
< 		}
< 	}
< 
< 	# not cached, reload it
< 	my $data;
< 
< 	my @logs = $self->logFiles();
< 
< 	while(my $log = shift(@logs)) {
< 		my $IN;
< 		open($IN, "< $log");
< 		my @input = <$IN>;
< 		close($IN);
< 		# my $logfile = basename($log);
< 		my $logfile = $log;
< 
< 		$data .= "\n" if($data);
< 		$data .= "==== $logfile ====\n";
< 		$data .= join("", @input);
< 	}
< 
< 	$data .= "\n" if($data);
< 	$data .= $self->remoteLogdata() || "";
---
>         if($self->attribute('logdata')) {
>                 if(!$self->isRunning() && $self->logtime() > $self->endTime()) {
>                         return($self->attribute('logdata'));
>                 }
>                 if($self->logtime() + 1 > time()) {
>                         return($self->attribute('logdata'));
>                 }
>         }
> 
>         # not cached, reload it
>         my $data;
> 
>         my @logs = $self->logFiles();
> 
>         while(my $log = shift(@logs)) {
>                 my $IN;
>                 open($IN, "< $log");
>                 my @input = <$IN>;
>                 close($IN);
>                 # my $logfile = basename($log);
>                 my $logfile = $log;
> 
>                 $data .= "\n" if($data);
>                 $data .= "==== $logfile ====\n";
>                 $data .= join("", @input);
>         }
> 
>         $data .= "\n" if($data);
>         $data .= $self->remoteLogdata() || "";
404c405
< 	return(undef) unless($data);
---
>         return(undef) unless($data);
406,407c407,408
< 	$self->setLogdata($data);
< 	$self->setLogtime(time());
---
>         $self->setLogdata($data);
>         $self->setLogtime(time());
409c410
< 	return($data);
---
>         return($data);
413,416c414,417
< 	my $class = shift;
< 	my $mcl = shift;
< 	my $stepname = shift;
< 	my $rollback = shift;
---
>         my $class = shift;
>         my $mcl = shift;
>         my $stepname = shift;
>         my $rollback = shift;
418,419c419,420
< 	my $instance = $mcl . "--" . $stepname;
< 	$instance .= "--rollback" if ($rollback);
---
>         my $instance = $mcl . "--" . $stepname;
>         $instance .= "--rollback" if ($rollback);
421,422c422,423
< 	my $self = $class->SUPER::new($instance);
< 	$self->setIsRollback(1) if($rollback);
---
>         my $self = $class->SUPER::new($instance);
>         $self->setIsRollback(1) if($rollback);
424,425c425,426
< 	$self->setMcl($mcl);
< 	$self->setName($stepname);
---
>         $self->setMcl($mcl);
>         $self->setName($stepname);
427c428
< 	return($self);
---
>         return($self);
431c432
< 	my $self = shift;
---
>         my $self = shift;
433,437c434,438
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 	my $dir = $mcl->logdir();
< 	$dir =~ s/logfiles/output/;
< 	ariba::rc::Utils::mkdirRecursively($dir);
< 	my $file = "$dir/Step-" . $self->name();
---
>         my $mcl = ariba::Ops::MCL->currentMclObject();
>         my $dir = $mcl->logdir();
>         $dir =~ s/logfiles/output/;
>         ariba::rc::Utils::mkdirRecursively($dir);
>         my $file = "$dir/Step-" . $self->name();
439c440
< 	return($file);
---
>         return($file);
443c444
< 	my $self = shift;
---
>         my $self = shift;
445c446
< 	unlink($self->sharedOutputFile());
---
>         unlink($self->sharedOutputFile());
449c450
< 	my $self = shift;
---
>         my $self = shift;
451,456c452,457
< 	my $f = $self->sharedOutputFile();
< 	open(F, "> $f");
< 	print F $self->status(), "\n";
< 	print F $self->endTime(), "\n";
< 	print F $self->output();
< 	close(F);
---
>         my $f = $self->sharedOutputFile();
>         open(F, "> $f");
>         print F $self->status(), "\n";
>         print F $self->endTime(), "\n";
>         print F $self->output();
>         close(F);
460c461
< 	my $self = shift;
---
>         my $self = shift;
462,474c463,475
< 	my $f = $self->sharedOutputFile();
< 	open(F,$f) || return;
< 	my $status = <F>;
< 	my $endTime = <F>;
< 	my @output = <F>;
< 	close(F);
< 
< 	chomp($status);
< 	chomp($endTime);
< 	$self->setEndTime($endTime);
< 	my $output = join("",@output);
< 	$self->setOutput($output);
< 	$self->setStatus($status);
---
>         my $f = $self->sharedOutputFile();
>         open(F,$f) || return;
>         my $status = <F>;
>         my $endTime = <F>;
>         my @output = <F>;
>         close(F);
> 
>         chomp($status);
>         chomp($endTime);
>         $self->setEndTime($endTime);
>         my $output = join("",@output);
>         $self->setOutput($output);
>         $self->setStatus($status);
480c481
< # will then be passed along as part of the remote command such that the remote command 
---
> # will then be passed along as part of the remote command such that the remote command
486c487
<     
---
> 
493c494
< 	my $self = shift;
---
>         my $self = shift;
495c496
< 	my $retVal;
---
>         my $retVal;
497,599c498,604
< 	#
< 	# force it to rebuild this
< 	#
< 	$self->setOutput(0);
< 
< 	#
< 	# if no actions are defined, we fail in the UI -- this is likely an MCL
< 	# definition error by the user, and if we are skipping intended actions,
< 	# that could be bad... but let's fail with a useful error in the "output".
< 	#
< 	unless(scalar($self->actions())) {
< 		$self->setStatus("Failed");
< 		$self->setOutput("Step " . $self->name() . " not run because there are no actions defined.");
< 		return(0);
< 	}
< 
< 	if($self->executeIf()) {
< 		my $mcl = ariba::Ops::MCL::currentMclObject();
< 		my $v = $mcl->variableForName($self->executeIf());
< 		if($self->executeIf() =~ /^\s*([a-zA-Z0-9]+)\(\s*([^\)]*)\s*\)\s*$/) {
< 			my $func = $1;
< 			my $arg = $2;
< 			my $rep = eval "ariba::Ops::MCL::Checks::$func($arg);";
< 			if($@ || !$rep) {
< 				my $reason = "returned false";
< 				$reason = "failed to compile: $@" if($@);
< 				$self->setOutput("Step " . $self->name() . " not run because " . $self->executeIf() . " $reason.");
< 				$self->setStatus('Skipped');
< 				return(1);
< 			}
< 		} else {
< 			if(!$v || !$v->value()) {
< 				$self->setOutput("Step " . $self->name() . " not run because " . $self->executeIf() . " is false or not set.");
< 				$self->setStatus('Skipped');
< 				return(1);
< 			}
< 		}
< 	}
< 
< 	if($self->executeUnless()) {
< 		my $mcl = ariba::Ops::MCL::currentMclObject();
< 		if($self->executeUnless() =~ /^\s*([a-zA-Z0-9]+)\(\s*([^\)]*)\s*\)\s*$/) {
< 			my $func = $1;
< 			my $arg = $2;
< 			my $rep = eval "ariba::Ops::MCL::Checks::$func($arg);";
< 			if(!$@ && $rep) {
< 				$self->setOutput("Step " . $self->name() . " not run because " . $self->executeUnless() . " returned true.");
< 				$self->setStatus('Skipped');
< 				return(1);
< 			}
< 		} else {
< 			my $v = $mcl->variableForName($self->executeUnless());
< 			if($v && $v->value()) {
< 				$self->setOutput("Step " . $self->name() . " not run because " . $self->executeUnless() . " is set to true.");
< 				$self->setStatus('Skipped');
< 				return(1);
< 			}
< 		}
< 	}
< 
< 	my $tries = $self->retries() || 1;
< 	my $sleep = $self->retryInterval() || 5;
< 	my $attempts = 0;
< 
< 	my $loopedOutput = "";
< 	while($tries) {
< 		$tries--;
< 		foreach my $action ($self->actions()) {
< 			$action->setStatus('Attempted');
<             $self->setPasswordEnv( $action->user(), $action->service() );
< 			my $ret = $action->execute();
< 			if($ret) {
< 				if($ret == -1) {
< 					$action->setStatus('Waiting');
< 					$retVal = -1;
< 					last;
< 				} else {
< 					$action->setStatus('Completed');
< 					$retVal = 1;
< 				}
< 			} else {
< 				$action->setStatus('Failed');
< 				$retVal = 0;
< 				last;
< 			}
< 		}
< 		$loopedOutput .= "\n==== retry $attempts ====\n\n" if($loopedOutput);
< 		$loopedOutput .= $self->output();
< 		$attempts++;
< 
< 
< 		#
< 		# this forces the next call to $self->output() to reconstruct from
< 		# the sub actions.
< 		#
< 		$self->setOutput(0);
< 
< 		last if($retVal);
< 		if($tries) {
< 			$self->sendInfoToUI("Retry #$attempts");
< 			sleep($sleep);
< 		}
< 	}
---
>         #
>         # force it to rebuild this
>         #
>         $self->setOutput(0);
> 
>         #
>         # if no actions are defined, we fail in the UI -- this is likely an MCL
>         # definition error by the user, and if we are skipping intended actions,
>         # that could be bad... but let's fail with a useful error in the "output".
>         #
>         unless(scalar($self->actions())) {
>                 $self->setStatus("Failed");
>                 $self->setOutput("Step " . $self->name() . " not run because there are no actions defined.");
>                 return(0);
>         }
> 
>         if($self->executeIf()) {
>                 my $mcl = ariba::Ops::MCL::currentMclObject();
>                 my $v = $mcl->variableForName($self->executeIf());
>                 if($self->executeIf() =~ /^\s*([a-zA-Z0-9]+)\(\s*([^\)]*)\s*\)\s*$/) {
>                         my $func = $1;
>                         my $arg = $2;
>                         my $rep = eval "ariba::Ops::MCL::Checks::$func($arg);";
>                         if($@ || !$rep) {
>                                 my $reason = "returned false";
>                                 $reason = "failed to compile: $@" if($@);
>                                 $self->setOutput("Step " . $self->name() . " not run because " . $self->executeIf() . " $reason.");
>                                 $self->setStatus('Skipped');
>                                 return(1);
>                         }
>                 } else {
>                         if(!$v || !$v->value()) {
>                                 $self->setOutput("Step " . $self->name() . " not run because " . $self->executeIf() . " is false or not set.");
>                                 $self->setStatus('Skipped');
>                                 return(1);
>                         }
>                 }
>         }
> 
>         if($self->executeUnless()) {
>                 my $mcl = ariba::Ops::MCL::currentMclObject();
>                 if($self->executeUnless() =~ /^\s*([a-zA-Z0-9]+)\(\s*([^\)]*)\s*\)\s*$/) {
>                         my $func = $1;
>                         my $arg = $2;
>                         my $rep = eval "ariba::Ops::MCL::Checks::$func($arg);";
>                         if(!$@ && $rep) {
>                                 $self->setOutput("Step " . $self->name() . " not run because " . $self->executeUnless() . " returned true.");
>                                 $self->setStatus('Skipped');
>                                 return(1);
>                         }
>                 } else {
>                         my $v = $mcl->variableForName($self->executeUnless());
>                         if($v && $v->value()) {
>                                 $self->setOutput("Step " . $self->name() . " not run because " . $self->executeUnless() . " is set to true.");
>                                 $self->setStatus('Skipped');
>                                 return(1);
>                         }
>                 }
>         }
> 
>         my $tries = $self->retries() || 1;
>         my $sleep = $self->retryInterval() || 5;
>         my $attempts = 0;
> 
>         my $loopedOutput = "";
>         while($tries) {
>                 $tries--;
>                 foreach my $action ($self->actions()) {
>                         $action->setStatus('Attempted');
>                         # This command assumes the step has a user.  This makes NetworkDevice steps and other
>                         # steps that don't have a user ambiguous.  Need to expand these step definitions and
>                         # parsing to have a service somehow.  Only then can we do cross service NetworkDevice
>                         # steps from a single MCL
>                         $self->setPasswordEnv( $action->user(), $action->service() ) if $action->user();
>                         my $ret = $action->execute();
>                         if($ret) {
>                                 if($ret == -1) {
>                                         $action->setStatus('Waiting');
>                                         $retVal = -1;
>                                         last;
>                                 } else {
>                                         $action->setStatus('Completed');
>                                         $retVal = 1;
>                                 }
>                         } else {
>                                 $action->setStatus('Failed');
>                                 $retVal = 0;
>                                 last;
>                         }
>                 }
>                 $loopedOutput .= "\n==== retry $attempts ====\n\n" if($loopedOutput);
>                 $loopedOutput .= $self->output();
>                 $attempts++;
> 
> 
>                 #
>                 # this forces the next call to $self->output() to reconstruct from
>                 # the sub actions.
>                 #
>                 $self->setOutput(0);
> 
>                 last if($retVal);
>                 if($tries) {
>                         $self->sendInfoToUI("Retry #$attempts");
>                         sleep($sleep);
>                 }
>         }
601c606
< 	$self->setOutput($loopedOutput);
---
>         $self->setOutput($loopedOutput);
603c608
< 	return($retVal);
---
>         return($retVal);
607,608c612,613
< 	my $self = shift;
< 	my $retVal = 0;
---
>         my $self = shift;
>         my $retVal = 0;
610,627c615,632
< 	foreach my $action ($self->actions()) {
< 		my $ret = $action->dryrun();
< 		if($ret) {
< 			if($ret == -1) {
< 				$action->setStatus('Waiting');
< 				$retVal = -1;
< 				last;
< 			} else {
< 				$action->setStatus('Completed');
< 				$retVal = 1;
< 			}
< 		} else {
< 			$action->setStatus('Failed');
< 			$retVal = 0;
< 			last;
< 		}
< 	}
< 	$self->setOutput(0); # force next call to $self->output() to rebuild
---
>         foreach my $action ($self->actions()) {
>                 my $ret = $action->dryrun();
>                 if($ret) {
>                         if($ret == -1) {
>                                 $action->setStatus('Waiting');
>                                 $retVal = -1;
>                                 last;
>                         } else {
>                                 $action->setStatus('Completed');
>                                 $retVal = 1;
>                         }
>                 } else {
>                         $action->setStatus('Failed');
>                         $retVal = 0;
>                         last;
>                 }
>         }
>         $self->setOutput(0); # force next call to $self->output() to rebuild
629,630c634,635
< 	sleep(5); # make the dry run take a little time so a human can observe
< 	return($retVal);
---
>         sleep(5); # make the dry run take a little time so a human can observe
>         return($retVal);
634,706c639,711
< 	my $self = shift;
< 	my $reload;
< 	my $mcl = ariba::Ops::MCL->currentMclObject();
< 
< 	if($self->storeSuccess()) {
< 		my $v = $mcl->variableForName($self->storeSuccess());
< 
< 		if($v) {
< 			if($self->status() eq 'Completed') {
< 				$v->setValue(1);
< 			} else {
< 				$v->setValue(0);
< 			}
< 		}
< 	}
< 
< 	my @storedVars = $self->storedVariables();
< 	if(scalar(@storedVars)) {
< 		my $output = $self->output();
< 
< 		#
< 		# sanitize
< 		#
< 		my @out = split(/\n/, $output);
< 		$output = "";
< 		foreach my $o (@out) {
< 			next if($o =~ /^\+\+\+/);
< 			$output .= " " if($output);
< 			$output .= $o;
< 		}
< 
< 		foreach my $store ($self->storedVariables()) {
< 			my ($var, $regex);
< 			if($store =~ /=/) {
< 				($var, $regex) = split(/\=/,$store,2);
< 			} else {
< 				$var = $store;
< 			}
< 			next unless($var);
< 
< 			my $val;
< 			if($regex) {
< 				if($output =~ /$regex/m) {
< 					$val = $1;
< 				}
< 			} else {
< 				$val = $output;
< 			}
< 
< 			if($val) {
< 				#
< 				# remove the last newline
< 				#
< 				chomp $val;
< 				my $v = $mcl->variableForName($var);
< 				unless($v) {
< 					$v = ariba::Ops::MCL::Variable->newFromParser($mcl->instance(), $var);
< 					$mcl->appendToVariables($v);
< 				}
< 				$v->setValue($val);
< 				$v->setType('dynamic');
< 				$v->save();
< 				$reload = 1;
< 			}
< 		}
< 	}
< 	#
< 	# reparse the MCL to account for the new variable values
< 	#
< 	if($reload) {
< 		$mcl->clearTransferList();
< 		$mcl->loadMCL();
< 	}
---
>         my $self = shift;
>         my $reload;
>         my $mcl = ariba::Ops::MCL->currentMclObject();
> 
>         if($self->storeSuccess()) {
>                 my $v = $mcl->variableForName($self->storeSuccess());
> 
>                 if($v) {
>                         if($self->status() eq 'Completed') {
>                                 $v->setValue(1);
>                         } else {
>                                 $v->setValue(0);
>                         }
>                 }
>         }
> 
>         my @storedVars = $self->storedVariables();
>         if(scalar(@storedVars)) {
>                 my $output = $self->output();
> 
>                 #
>                 # sanitize
>                 #
>                 my @out = split(/\n/, $output);
>                 $output = "";
>                 foreach my $o (@out) {
>                         next if($o =~ /^\+\+\+/);
>                         $output .= " " if($output);
>                         $output .= $o;
>                 }
> 
>                 foreach my $store ($self->storedVariables()) {
>                         my ($var, $regex);
>                         if($store =~ /=/) {
>                                 ($var, $regex) = split(/\=/,$store,2);
>                         } else {
>                                 $var = $store;
>                         }
>                         next unless($var);
> 
>                         my $val;
>                         if($regex) {
>                                 if($output =~ /$regex/m) {
>                                         $val = $1;
>                                 }
>                         } else {
>                                 $val = $output;
>                         }
> 
>                         if($val) {
>                                 #
>                                 # remove the last newline
>                                 #
>                                 chomp $val;
>                                 my $v = $mcl->variableForName($var);
>                                 unless($v) {
>                                         $v = ariba::Ops::MCL::Variable->newFromParser($mcl->instance(), $var);
>                                         $mcl->appendToVariables($v);
>                                 }
>                                 $v->setValue($val);
>                                 $v->setType('dynamic');
>                                 $v->save();
>                                 $reload = 1;
>                         }
>                 }
>         }
>         #
>         # reparse the MCL to account for the new variable values
>         #
>         if($reload) {
>                 $mcl->clearTransferList();
>                 $mcl->loadMCL();
>         }
708c713
< 	return($reload);
---
>         return($reload);
filename:./lib/ariba/Ops/NetworkUtils.pm
3c3
< # $Id: //ariba/services/tools/lib/perl/ariba/Ops/NetworkUtils.pm#38 $
---
> # $Id: //ariba/services/tools/lib/perl/ariba/Ops/NetworkUtils.pm#39 $
19c19
<     macAddressForHost ping vendorForMacAddress
---
>     macAddressForHost ping vendorForMacAddress snmpOctetstrToNumbers
612a613,646
> # in snmp queries, some returned integer values such as port or index lists
> # are in packed string form with length 4 and need converted back to numbers
> # in case multiple of these object values are packed into one string
> # this subroutine split them and convert each into numbers.
> # an example of these is CISCO-LAG-MIB::clagAggPortListInterfaceIndexList
> #
> sub snmpOctetstrToNumbers {
>     my $packedstr = shift;
>     my @numlist = ();
>     
>     # process it only if the string length is multiple of 4
>     unless ( length($packedstr) % 4 ) {
>         my $i = 0;
>         while ( my $ss = substr($packedstr, $i, 4) ) {
>             $i += 4;
> 
>             # convert to d.d.d.d form
>             my $octstr = inet_ntoa($ss); 
> 
>             # convert to integers
>             my @octets = split(/\./, $octstr);
>             $octets[0] <<= 24;
>             $octets[1] <<= 16;
>             $octets[2] <<= 8;
> 
>             my $val = $octets[0] + $octets[1] + $octets[2] + $octets[3];
>             
>             push @numlist, $val;
>         }
>     }
> 
>     return @numlist;
> }
> 
filename:./lib/ariba/Ops/Page.pm
3c3
< #$Id: //ariba/services/tools/lib/perl/ariba/Ops/Page.pm#24 $
---
> #$Id: //ariba/services/tools/lib/perl/ariba/Ops/Page.pm#26 $
378,379c378,389
<     ariba::Ops::Utils::email($to, $subject, $body, $cc, undef, undef, 'special-delivery');
< 
---
>     if (-e '/var/tmp/no_stratus' && $self->pageRequest()->subject() =~ /Stratus/)
>     {
>         print "page email is suppressed\n" if ($debug);
>     }
>     elsif (-e '/var/tmp/no_cookies' && $self->pageRequest()->subject() !~ /Stratus/)
>     {
>         print "page email is suppressed\n" if ($debug);
>     }
>     else
>     {
>         ariba::Ops::Utils::email($to, $subject, $body, $cc, undef, undef, 'special-delivery');
>     }
filename:./lib/ariba/Ops/ProductAPIExtensions.pm
299,300d298
< {
< my $local_storage;
303c301
<     return @{$local_storage->{$product->name()}} if (exists $local_storage->{$product->name()}); 
---
> 
311,313c309
<     $local_storage->{$product->name()} = [(sort keys(%ids))];
<     return @{$local_storage->{$product->name()}};
< }
---
>     return (sort keys(%ids));
filename:./lib/ariba/monitor/misc.pm
106c106
< 		'arches', 
---
>         ariba::rc::Globals::archesProducts(),
filename:./lib/ariba/rc/Patch.pm
4c4
< # $Id: //ariba/services/tools/lib/perl/ariba/rc/Patch.pm#41 $
---
> # $Id: //ariba/services/tools/lib/perl/ariba/rc/Patch.pm#42 $
102c102
< 	} elsif ( grep  { $productName eq $_ } ( "arches", "sdb", "help", "doc", ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts()) ) {
---
> 	} elsif ( grep  { $productName eq $_ } ( ariba::rc::Globals::archesProducts(), "sdb", "help", "doc", ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts()) ) {
filename:./lib/ariba/rc/RolesManager.pm
2c2
< # $Id: //ariba/services/tools/lib/perl/ariba/rc/RolesManager.pm#17 $
---
> # $Id: //ariba/services/tools/lib/perl/ariba/rc/RolesManager.pm#19 $
1183c1183,1193
< 	return @hosts;
---
> 	# PFS-14014: dedup!
> 	my @unique_hosts = ();
> 	my %host_seen;
> 	foreach my $host ( @hosts ) {
> 		next if ( exists $host_seen{$host} );
> 
> 		$host_seen{$host} = 1;
> 		push(@unique_hosts, $host);
> 	}
> 
> 	return @unique_hosts;
