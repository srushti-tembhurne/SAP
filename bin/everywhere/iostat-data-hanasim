#!/usr/local/bin/perl

## This program is specifically designed to set threshold value for the Average Wait Time for Request which is one of the Parameter of the iostat command
# $Id: //ariba/services/monitor/bin/everywhere/iostat-data-hanasim#8 $
#

use strict;

use lib "/usr/local/ariba/lib";

use ariba::monitor::IOStatData;
use ariba::Veritas::Mapping;
use ariba::monitor::QueryManager;
use ariba::monitor::StatusPage;
use ariba::Ops::NetworkUtils;
use ariba::rc::InstalledProduct;
use ariba::Ops::Machine;
use ariba::Ops::Startup::Common;
use ariba::Ops::Constants;
use ariba::Ops::CFEngine::MonitoringGlueUtils;
use ariba::monitor::CircularDB;
use dmail::LockLib;

use Data::Dumper;
use File::Tail;


my $debug = 0;
my $numOfRecords = 3; ## To get Average of last 3 records from cdb file;
my $username = (getpwuid($<))[0];
my $lockfile = "/tmp/iostat-data-hanasim.${username}";
my @storeData = qw( averageWaitTimeForRequests);
my $monServer;
my $service;
my $redhatVersion;

my $logFile = "/var/tmp/iostat-data.${username}.log";

sub redhatRelease {
    open(F,"/etc/redhat-release");
    my $rel = <F>;
    close(F);

    return($rel);
}

sub cleanLock {
    dmail::LockLib::releaselock($lockfile);
    exit 0;
}

## This program reads the log file,  /var/tmp/iostat-data.${username}.log which is generated by iostat-data in each host
## and run the query against averageWaitTimeForRequests - await parameter along with the threshold value.

# This program  off iostat processes, gathers the data, and aggregates
# it by veritas storage foundation structure.
#
sub main {
    my $sendEmail = 0;
    my $sendPage = 0;
    my $exit = 0;
    my $runBefore = 6;


    #
    # parse args here -- we should have args for interval, duration, debug, etc
    #
    while(my $arg=shift(@_)){
        if( $arg =~ /^-e/o ) { $sendEmail = 1; };
        if( $arg =~ /^-p/o ) { $sendPage = 1; };
        if( $arg =~ /^-d/o ) { $debug = 1; };
        if( $arg =~ /^-exit/o ) { $exit = 1; };
    }

    $sendPage = 0 ; ##Intentionally disabling paging for iostat-data-hanasim

    my $lFile = "$lockfile.lock";
    killOldProcess($lFile, $runBefore); ##Kill Process if it's running for more than $runBefore hour

    my $release = redhatRelease();
    if($release =~ /release ([\d\.]+)/) {
        $redhatVersion = $1;
    } else {
        $redhatVersion = "unknown";
    }

    my $hostname = ariba::Ops::NetworkUtils::hostname();
    my $machine = ariba::Ops::Machine->new($hostname);
    my $datacenter = $machine->datacenter();
    $service = (ariba::rc::Globals::servicesForDatacenter($datacenter))[0];

    #
    # set a lock in case multiple services try to start this job
    #
    dmail::LockLib::forceQuiet();
    unless (dmail::LockLib::requestlock($lockfile,5)) {
        exit; # it's not an "error" that we don't get a lock -- exit quietly
    }

    #
    # Write a PID file
    #
    my $pidFile = "/tmp/" . ariba::Ops::Constants->iostatDataPidFile();
    $pidFile = "$pidFile-hanasim";

    if(open(PID, "> $pidFile")) {
        print PID "$$\n";
        close(PID); # this also gives us a time stamp of when we started.
    }

    #
    # lookup the monserver for this host
    #
    $monServer = ariba::Ops::CFEngine::MonitoringGlueUtils::monitorServer();

    #
    # clean up lockfile when we exit based on a signal
    #
    $SIG{'INT'} = \&cleanLock;
    $SIG{'TERM'} = \&cleanLock;
    $SIG{'QUIT'} = \&cleanLock;
    $SIG{'HUP'} = \&cleanLock;

    while(1) {
        readIostatLogs($sendEmail, $sendPage, $hostname );
        if($debug || $exit) {
            dmail::LockLib::releaselock($lockfile);
            exit(0);
        }
    }

}

sub readIostatLogs {
    my $sendEmail = shift;
    my $sendPage = shift;
    my $hostname = shift;
    my $numRecords = 600000; # save about 6 months of data
    my $skippedFirst = 0;
    my $data = {};
    #
    # clear the object cache before we create a new vxMap
    #
    ariba::Veritas::Mapping->clearCache();
    my $vxMap = ariba::Veritas::Mapping->new();

    my $machine = ariba::Ops::Machine->new($hostname);

    my $tab = ariba::monitor::StatusPage::fakeProductNameForDatacenter(
        $machine->datacenter()
    );
    my $expando = "iostat-data-$hostname";

    my $file=File::Tail->new(name=>$logFile, maxinterval=>300, adjustafter=>7);

    #
    # Parsing output that looks like:
    #
    # Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
    # sda          0.07   0.00  0.02  0.05    0.88    0.86     0.44     0.43    25.27     0.00    1.13   1.12   0.01
    # (other disks)
    # (empty line)
    # (repeat)
    #
    my $HEADER = "Device:         rrqm/s   wrqm/s   r/s   w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %utila";
   
    IOSTAT:
    while (defined(my $line=$file->read)) {
        chomp $line;
        next if($line =~ m/===============|Starting a new iostat/); # this starts a new block of data
        my $header = $HEADER;
        my %dataHash;
        my $invalid = 0;
        while(1) {
            my @info = split(/IN: /,$line);
            $line = $info[1];
            my $diskData = $line;

            # an empty line ends a block o data
            last if ($diskData =~ /^$/);
            $diskData =~ m/^(\w+)/;
            my $disk = $1;
            my $vDisk = $vxMap->diskFromOsName($disk);

            my ($type, $device);
            if($vDisk) {
                $disk = $vDisk->instance(); # use VX name for disk
                $type = "disk";
            } else {
                $disk = "Local:/dev/$disk";
                $type = "local disk";
            }
            
            my $dataObj = $data->{$disk};
            unless($dataObj) {
                $dataObj = ariba::monitor::IOStatData->new($disk);
                $dataObj->setType($type);
                $data->{$disk} = $dataObj;
            }

            $invalid |= $dataObj->recordData($header, $diskData);
            $dataHash{$disk} = $diskData;
            next IOSTAT;
        }
        next if($invalid); # we got bogus iostat data back, so skip this pass

        #
        # now store by plex, volume, diskgroup, and channel
        #
        # we are only recording by volume and channelfor now, but let's
        # gather it all
        #
        my %queries = ();
        print "The value of the data is ", Dumper($data), "\n", if ($debug > 1);

        foreach my $dataObjName (sort keys %{$data}) {
            my $dataObj = $data->{$dataObjName};
            next unless($dataObj->type() eq 'volume' || $dataObj->type() eq 'channel' || $dataObj->type() eq 'local disk');
            my $volume = $vxMap->volumeFromName($dataObj->volumeName());
            my $channel = $dataObj->channel();
            my $volName;
            my $uiVolName;
            if($volume) {
                next unless($volume->mountPoint());
                $volName = $volume->mountPoint();
                $uiVolName = $volName; # remove the slash from uiHint
                $uiVolName =~ s|/||g;
            }

            foreach my $key (@storeData) {
                next unless ($key =~ /averageWaitTimeForRequests/);
                my $dataField;
                my $uiHint;
                my $crit = 0;
                my $warn = 0;
                if($dataObj->type() eq 'volume') {
                    if($channel eq 'ALL') {
                        $dataField = "$hostname:$volName : " . ariba::monitor::IOStatData->prettyNameForField($key);
                        $uiHint = $hostname . "/" . $uiVolName;
                    } else {
                        $dataField = "$hostname:$volName:$channel : " . ariba::monitor::IOStatData->prettyNameForField($key);
                        $uiHint = $hostname . "/" . $uiVolName . "/" . $channel;
                    }
                } elsif($dataObj->type() eq 'channel') {
                    $dataField = "$hostname:$channel : " . ariba::monitor::IOStatData->prettyNameForField($key);
                    $uiHint = $hostname . "/" . $channel;
                } elsif($dataObj->type() eq 'local disk') {
                    my $diskname = $dataObj->instance();
                    $diskname =~ s|^Local:/dev/||;
                    $diskname =~ s|/|_|g;
                    $dataField = "$hostname:/dev/$diskname : " . ariba::monitor::IOStatData->prettyNameForField($key);
                    $uiHint = $hostname . "/Non Veritas Disks/" . $diskname;
                }

                my $units = ariba::monitor::IOStatData->unitsForField($key);
                my $dataValue = $dataObj->$key();

                #
                # HACK -- uiHints are broken.  For now I'm reducing this to
                # just hostname to save CPU.  This is a clobber rather than
                # a logic change so we can revert if we ever fix the expando
                # code.
                #
                $uiHint = $hostname;
                my $avg = 0;
                if ( ($key =~ /averageWaitTimeForRequests/ ) ){
                    my $avg = getAverage($dataField, $numOfRecords, $tab);
                    $crit = "$avg > 500";
                    $warn = "$avg > 400";
                }

                $queries{$dataField} = {
                    warn => $warn,
                    crit => $crit,
                    info => 1,
                    uiHint => $uiHint,
                    description => 'Warn and Crit are set against average of previous three result not on actual Result', 
                    recordMaxResults => $numRecords,
                    recordDataUnits => $units,
                    perl => sub { return $dataValue; },
                };
            }
        }

        my $email = ariba::Ops::Constants->operationsEmailNotificationAddress();

        #
        # XXX - HACK! This will reclaim /var/mon -- needed in load since other
        # services claim the monitor dir on startup, and we need it more  ;)
        #
        ariba::Ops::Startup::Common::createMonitoringArchiveDirFromService($service);
        my $q = ariba::monitor::QueryManager->newWithDetails(
            $expando, $tab, $service, undef, \%queries
        );
        $q->setUiManager('iostat-data');
        $q->processQueriesUsingServer($debug, $email, $sendEmail, $sendPage, $monServer);
    }
    close(FH);
}

sub getAverage{

    my $filter = shift;
    my $numOfRecords = shift;
    my $product = shift;
    my $avg = 0;

    $filter =~ s/\s+|\(|\)|\//_/g;
    $filter =~ s/\:/\\:/g;

    my $cdbs = ariba::monitor::CircularDB->listDBs( $product,$filter);

    my $cdb = shift @$cdbs;

    if ($cdb) {
        #print "Content of CDB Object is \n", Dumper($cdb), if $debug;
        my @records = $cdb->readRecords(undef, undef, $numOfRecords);

        my $sum = 0;
        my $cnt = 1;
        foreach my $record (@records){
            my $time = localtime($record->[0]);
            print "Record $cnt] , $record->[1]  at $time \n", if $debug;
            $sum += $record->[1];
            $cnt += 1;
        }

        $avg = sprintf("%.2f", ($sum/3));
    }

    else {
       print "Unable to read cdb file for $filter\n", if $debug;
       $avg = "Unable to read cdb file for $filter";

    }

    print "The average of the last 3 records is $avg\n", if $debug;
    return $avg;
}

sub killOldProcess{
## Killing the Process if it's running for more than 6 hours
my $lFile = shift;
my $runBefore = shift;
    if (-e $lFile){
        print "Lock FILE ", $lFile, "exist\n", if($debug);
        my $startTime = (stat($lFile))[9];
        my $ctime = time;
        exit unless(defined $startTime);

        my $diff = sprintf("%d", (($ctime - $startTime)/3600));
        print "Current Time , $ctime, Process Start Time: $startTime  Difference: $diff \n", if($debug);

        if ($diff > $runBefore){
            my $killPid = `cat $lFile`;
            chomp($killPid);
            print "We are going to kill this pid ", $killPid, "\n", if($debug);
            my $task = system("kill -9 $killPid");
            if ($task == 0){
                print "Successfully terminated $killPid \n", if($debug);
                my $deleteFile = system("rm -rf $lFile");
                print "Successfully deleted lock file $lFile \n", if($deleteFile == 0 && $debug);
            }
        }
}


}

main(@ARGV);
