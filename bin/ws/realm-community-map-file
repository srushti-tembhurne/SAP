#!/usr/local/bin/perl -w
#
# Make sure that the realm-community map file is up-to-date by checking
# timestamps generated by generate-realm-to-community-map daemon
#

use strict;
use FindBin;
use lib "$FindBin::RealBin/../../lib";

use File::Basename;

use ariba::rc::InstalledProduct;
use ariba::rc::CipherStore;
use ariba::rc::Utils;
use ariba::Ops::Startup::Apache;
use ariba::Ops::NetworkUtils;
use ariba::monitor::QueryManager;

my $vers = '$Id: //ariba/services/monitor/bin/ws/realm-community-map-file#7 $';
$main::quiet	= 1;	# silence transferFromSrcToDest output

# need this for rsync to work from crontab
$ENV{'PATH'} = '/usr/local/bin:' . $ENV{'PATH'};

sub main {
	my $sendEmail = 0;
	my $sendPage = 0;
	my $debug = 0;

	while (my $arg = shift(@ARGV)) {
		if ($arg =~ /^-d/o) { $debug     = 1; next; }
		if ($arg =~ /^-e/o) { $sendEmail = 1; next; }
		if ($arg =~ /^-p/o) { $sendPage  = 1; next; }
	}

	if ($debug) {
		$main::quiet = 0;
	}

	my $me = ariba::rc::InstalledProduct->new();

	my %queries = ();
	my $service = $me->service();

	my $ssws = ariba::rc::InstalledProduct->new("ssws", $service);
	my $username = $ssws->deploymentUser();

	my $cipherStore = ariba::rc::CipherStore->new($service);
	my $password    = $cipherStore->valueForName($username);

	for my $prodname  (ariba::rc::Globals::sharedServiceSourcingProducts(), ariba::rc::Globals::sharedServiceBuyerProducts()) {

		next unless ariba::rc::InstalledProduct->isInstalled($prodname, $service);

		my $product = ariba::rc::InstalledProduct->new($prodname, $service);
		my $mapFileTimestampName = ariba::Ops::Startup::Apache::realmToCommunityMapFileTimestampNameForProduct($ssws, $product);

		for my $webserver ($ssws->hostsForRoleInCluster("ss-webserver")) {

			$queries{"$prodname realm-to-community map file on $webserver last checked"} = {
				info => "defined(answer) && answer < 10",
				warn => "defined(answer) && answer >= 10",
				crit => "!defined(answer) || answer eq '' || answer >= 20",
				format => "%d minutes ago",
				perl => sub {
					return main::mtimeForFileFromHost($mapFileTimestampName, $webserver, $username, $password, $service);
				},
                inf_field => "last_checked",
                inf_tags  => "webserver=\"$webserver\",product_name=\"$prodname\"",
                group_by  => "$webserver,$prodname",
                inf_default => 0
			};
		}
	}

    $queries{'influx_details'} = { measurement => 'ssws_realm_community_map' };
	my $email = $me->default('notify.email');
	my $qm = ariba::monitor::QueryManager->newWithDetails( "realm-community-map-file", $ssws->name(), $service, undef, \%queries);
	$qm->processQueries($debug, $email, $sendEmail, $sendPage);
}

sub mtimeForFileFromHost {
	my ($mapFileTimestampName, $webserver, $username, $password, $service) = @_;
	my $minutesAgo = undef;

	my ($mapFile, $mapFilePath) = fileparse($mapFileTimestampName);

	my $tmpDir = ariba::Ops::Startup::Common::tmpdir() .  "/realm-community-map-file-$service/$webserver/";
	ariba::rc::Utils::mkdirRecursively($tmpDir) unless -d $tmpDir;

	my $outputRef = [];

	my $ret = ariba::rc::Utils::transferFromSrcToDestNoCheck(
			$webserver,
			$username,
			$mapFilePath,
			$mapFile,

			undef,
			undef,
			$tmpDir,
			undef,

			0,0,0,

			$password,
			$outputRef,
	);

	if ($ret) {
		my ($modtime) = (stat("$tmpDir/$mapFile"))[9];
		if ($modtime) {
			$minutesAgo = time() - $modtime;
			$minutesAgo /= 60;
		}

		# reset error flag on query after successful run
		$ariba::monitor::Query::_ourGlobalQuerySelf->setError();

	} else {
 
		# make the error show up as the results
		$minutesAgo = join("", @$outputRef);

		# TMID 84282
		# if there was a previous error, page for it, else return the
		# error and deal with it in the query

		my $prevError = $ariba::monitor::Query::_ourGlobalQuerySelf->error();

		if ($prevError) { # cause a page by setting error
			$ariba::monitor::Query::_ourGlobalQuerySelf->setNoCritOnError(0);
		} else {
			$ariba::monitor::Query::_ourGlobalQuerySelf->setNoCritOnError(1);
		}


		$ariba::monitor::Query::_ourGlobalQuerySelf->setError(join("\n", @$outputRef));
		$ariba::monitor::Query::_ourGlobalQuerySelf->setNoErrorReset(1);
	}
	return $minutesAgo;
}

main();

__END__

